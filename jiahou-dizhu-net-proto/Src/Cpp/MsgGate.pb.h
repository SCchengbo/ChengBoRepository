// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MsgGate.proto

#ifndef PROTOBUF_MsgGate_2eproto__INCLUDED
#define PROTOBUF_MsgGate_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "MsgCode.pb.h"
// @@protoc_insertion_point(includes)

namespace ProtoNet {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_MsgGate_2eproto();
void protobuf_AssignDesc_MsgGate_2eproto();
void protobuf_ShutdownFile_MsgGate_2eproto();

class AccountInfo;
class LastGameInfo;
class LastGameInfoDetail;
class GameZoneInfo;
class ServerInfoIpsSafeDetail;
class SafeIpAndPortDetail;
class GoldRoomServerInfos;
class OpenRoomReplaceRecordInfo;
class ReplaceRecordOver;
class TimesInfo;
class ReqGateLogin;
class ResGateLogin;
class ReqGetAccountInfo;
class ResGetAccountInfo;
class ReqGetGameZoneInfoList;
class ResGetGameZoneInfoList;
class ReqGetGameZoneDetail;
class ResGetGameZoneDetail;
class ReqJoinLogicGameRoom;
class ResJoinLogicGameRoom;
class ReqQuickJoinGameRoom;
class ResQuickJoinGameRoom;
class ResNotifyBroadPlatMarquee;
class ResNotifySelfDataChange;
class ReqGetRoomBrifeList;
class ResGetRoomBrifeList;
class ReqCheckInMatch;
class ResCheckInMatch;
class ReqOpenRoomReplace;
class ResOpenRoomReplace;
class ReqOpenRoomReplaceRecordList;
class ResOpenRoomReplaceRecord_List;
class ReqDissolutionOpenRoomReplace;
class ResDissolutionOpenRoomReplace;
class ReqGameRoomList;
class ResGameRoomList;
class GameRoomList;
class ReqClubGameRoomList;
class ResClubGameRoomList;
class ClubGameRoomList;
class RoomRoleInfo;
class ReqClubPipeiRoom;
class ResClubPipeiRoom;
class ReqExitClubPipeiRoom;
class ResExitClubPipeiRoom;
class ReqClubPipeiRoomStatus;
class ResClubPipeiRoomStatus;
class ResNotifyClubPipeiSuc;
class ResNotifyRefreshClubGameRoomList;
class ResNotifyRefreshClubRedBotNews;
class ResNotifyClubDismiss;
class ResNotifyClubKickedOut;
class ResNotifyClubChangeGameType;

// ===================================================================

class AccountInfo : public ::google::protobuf::Message {
 public:
  AccountInfo();
  virtual ~AccountInfo();

  AccountInfo(const AccountInfo& from);

  inline AccountInfo& operator=(const AccountInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountInfo& default_instance();

  void Swap(AccountInfo* other);

  // implements Message ----------------------------------------------

  AccountInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccountInfo& from);
  void MergeFrom(const AccountInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string nick = 2;
  inline bool has_nick() const;
  inline void clear_nick();
  static const int kNickFieldNumber = 2;
  inline const ::std::string& nick() const;
  inline void set_nick(const ::std::string& value);
  inline void set_nick(const char* value);
  inline void set_nick(const char* value, size_t size);
  inline ::std::string* mutable_nick();
  inline ::std::string* release_nick();
  inline void set_allocated_nick(::std::string* nick);

  // optional int32 uid = 3;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 3;
  inline ::google::protobuf::int32 uid() const;
  inline void set_uid(::google::protobuf::int32 value);

  // optional int32 sex = 4;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 4;
  inline ::google::protobuf::int32 sex() const;
  inline void set_sex(::google::protobuf::int32 value);

  // optional string phone = 5;
  inline bool has_phone() const;
  inline void clear_phone();
  static const int kPhoneFieldNumber = 5;
  inline const ::std::string& phone() const;
  inline void set_phone(const ::std::string& value);
  inline void set_phone(const char* value);
  inline void set_phone(const char* value, size_t size);
  inline ::std::string* mutable_phone();
  inline ::std::string* release_phone();
  inline void set_allocated_phone(::std::string* phone);

  // optional string email = 6;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 6;
  inline const ::std::string& email() const;
  inline void set_email(const ::std::string& value);
  inline void set_email(const char* value);
  inline void set_email(const char* value, size_t size);
  inline ::std::string* mutable_email();
  inline ::std::string* release_email();
  inline void set_allocated_email(::std::string* email);

  // optional int32 head = 7;
  inline bool has_head() const;
  inline void clear_head();
  static const int kHeadFieldNumber = 7;
  inline ::google::protobuf::int32 head() const;
  inline void set_head(::google::protobuf::int32 value);

  // optional string headUrl = 8;
  inline bool has_headurl() const;
  inline void clear_headurl();
  static const int kHeadUrlFieldNumber = 8;
  inline const ::std::string& headurl() const;
  inline void set_headurl(const ::std::string& value);
  inline void set_headurl(const char* value);
  inline void set_headurl(const char* value, size_t size);
  inline ::std::string* mutable_headurl();
  inline ::std::string* release_headurl();
  inline void set_allocated_headurl(::std::string* headurl);

  // optional int32 lv = 9;
  inline bool has_lv() const;
  inline void clear_lv();
  static const int kLvFieldNumber = 9;
  inline ::google::protobuf::int32 lv() const;
  inline void set_lv(::google::protobuf::int32 value);

  // optional int32 vip = 10;
  inline bool has_vip() const;
  inline void clear_vip();
  static const int kVipFieldNumber = 10;
  inline ::google::protobuf::int32 vip() const;
  inline void set_vip(::google::protobuf::int32 value);

  // optional string ipaddress = 11;
  inline bool has_ipaddress() const;
  inline void clear_ipaddress();
  static const int kIpaddressFieldNumber = 11;
  inline const ::std::string& ipaddress() const;
  inline void set_ipaddress(const ::std::string& value);
  inline void set_ipaddress(const char* value);
  inline void set_ipaddress(const char* value, size_t size);
  inline ::std::string* mutable_ipaddress();
  inline ::std::string* release_ipaddress();
  inline void set_allocated_ipaddress(::std::string* ipaddress);

  // optional string address = 12;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 12;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // optional int32 inviter = 13;
  inline bool has_inviter() const;
  inline void clear_inviter();
  static const int kInviterFieldNumber = 13;
  inline ::google::protobuf::int32 inviter() const;
  inline void set_inviter(::google::protobuf::int32 value);

  // repeated .ProtoNet.PlayerAccount counts = 14;
  inline int counts_size() const;
  inline void clear_counts();
  static const int kCountsFieldNumber = 14;
  inline const ::ProtoNet::PlayerAccount& counts(int index) const;
  inline ::ProtoNet::PlayerAccount* mutable_counts(int index);
  inline ::ProtoNet::PlayerAccount* add_counts();
  inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::PlayerAccount >&
      counts() const;
  inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::PlayerAccount >*
      mutable_counts();

  // optional .ProtoNet.LastGameInfo lastGameInfo = 15;
  inline bool has_lastgameinfo() const;
  inline void clear_lastgameinfo();
  static const int kLastGameInfoFieldNumber = 15;
  inline const ::ProtoNet::LastGameInfo& lastgameinfo() const;
  inline ::ProtoNet::LastGameInfo* mutable_lastgameinfo();
  inline ::ProtoNet::LastGameInfo* release_lastgameinfo();
  inline void set_allocated_lastgameinfo(::ProtoNet::LastGameInfo* lastgameinfo);

  // @@protoc_insertion_point(class_scope:ProtoNet.AccountInfo)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_nick();
  inline void clear_has_nick();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_phone();
  inline void clear_has_phone();
  inline void set_has_email();
  inline void clear_has_email();
  inline void set_has_head();
  inline void clear_has_head();
  inline void set_has_headurl();
  inline void clear_has_headurl();
  inline void set_has_lv();
  inline void clear_has_lv();
  inline void set_has_vip();
  inline void clear_has_vip();
  inline void set_has_ipaddress();
  inline void clear_has_ipaddress();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_inviter();
  inline void clear_has_inviter();
  inline void set_has_lastgameinfo();
  inline void clear_has_lastgameinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* nick_;
  ::google::protobuf::int32 uid_;
  ::google::protobuf::int32 sex_;
  ::std::string* phone_;
  ::std::string* email_;
  ::std::string* headurl_;
  ::google::protobuf::int32 head_;
  ::google::protobuf::int32 lv_;
  ::std::string* ipaddress_;
  ::google::protobuf::int32 vip_;
  ::google::protobuf::int32 inviter_;
  ::std::string* address_;
  ::google::protobuf::RepeatedPtrField< ::ProtoNet::PlayerAccount > counts_;
  ::ProtoNet::LastGameInfo* lastgameinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(15 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static AccountInfo* default_instance_;
};
// -------------------------------------------------------------------

class LastGameInfo : public ::google::protobuf::Message {
 public:
  LastGameInfo();
  virtual ~LastGameInfo();

  LastGameInfo(const LastGameInfo& from);

  inline LastGameInfo& operator=(const LastGameInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LastGameInfo& default_instance();

  void Swap(LastGameInfo* other);

  // implements Message ----------------------------------------------

  LastGameInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LastGameInfo& from);
  void MergeFrom(const LastGameInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);

  // optional .ProtoNet.LastGameInfoDetail detail = 2;
  inline bool has_detail() const;
  inline void clear_detail();
  static const int kDetailFieldNumber = 2;
  inline const ::ProtoNet::LastGameInfoDetail& detail() const;
  inline ::ProtoNet::LastGameInfoDetail* mutable_detail();
  inline ::ProtoNet::LastGameInfoDetail* release_detail();
  inline void set_allocated_detail(::ProtoNet::LastGameInfoDetail* detail);

  // optional .ProtoNet.ServerInfoIpsSafeDetail gate = 3;
  inline bool has_gate() const;
  inline void clear_gate();
  static const int kGateFieldNumber = 3;
  inline const ::ProtoNet::ServerInfoIpsSafeDetail& gate() const;
  inline ::ProtoNet::ServerInfoIpsSafeDetail* mutable_gate();
  inline ::ProtoNet::ServerInfoIpsSafeDetail* release_gate();
  inline void set_allocated_gate(::ProtoNet::ServerInfoIpsSafeDetail* gate);

  // optional .ProtoNet.ServerInfoIpsSafeDetail logic = 4;
  inline bool has_logic() const;
  inline void clear_logic();
  static const int kLogicFieldNumber = 4;
  inline const ::ProtoNet::ServerInfoIpsSafeDetail& logic() const;
  inline ::ProtoNet::ServerInfoIpsSafeDetail* mutable_logic();
  inline ::ProtoNet::ServerInfoIpsSafeDetail* release_logic();
  inline void set_allocated_logic(::ProtoNet::ServerInfoIpsSafeDetail* logic);

  // @@protoc_insertion_point(class_scope:ProtoNet.LastGameInfo)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_detail();
  inline void clear_has_detail();
  inline void set_has_gate();
  inline void clear_has_gate();
  inline void set_has_logic();
  inline void clear_has_logic();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoNet::LastGameInfoDetail* detail_;
  ::ProtoNet::ServerInfoIpsSafeDetail* gate_;
  ::ProtoNet::ServerInfoIpsSafeDetail* logic_;
  ::google::protobuf::int32 gameid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static LastGameInfo* default_instance_;
};
// -------------------------------------------------------------------

class LastGameInfoDetail : public ::google::protobuf::Message {
 public:
  LastGameInfoDetail();
  virtual ~LastGameInfoDetail();

  LastGameInfoDetail(const LastGameInfoDetail& from);

  inline LastGameInfoDetail& operator=(const LastGameInfoDetail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LastGameInfoDetail& default_instance();

  void Swap(LastGameInfoDetail* other);

  // implements Message ----------------------------------------------

  LastGameInfoDetail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LastGameInfoDetail& from);
  void MergeFrom(const LastGameInfoDetail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional string roomId = 2;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 2;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const char* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  inline void set_allocated_roomid(::std::string* roomid);

  // optional int32 status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ProtoNet.LastGameInfoDetail)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* roomid_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static LastGameInfoDetail* default_instance_;
};
// -------------------------------------------------------------------

class GameZoneInfo : public ::google::protobuf::Message {
 public:
  GameZoneInfo();
  virtual ~GameZoneInfo();

  GameZoneInfo(const GameZoneInfo& from);

  inline GameZoneInfo& operator=(const GameZoneInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameZoneInfo& default_instance();

  void Swap(GameZoneInfo* other);

  // implements Message ----------------------------------------------

  GameZoneInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameZoneInfo& from);
  void MergeFrom(const GameZoneInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);

  // optional bool isOpen = 3;
  inline bool has_isopen() const;
  inline void clear_isopen();
  static const int kIsOpenFieldNumber = 3;
  inline bool isopen() const;
  inline void set_isopen(bool value);

  // @@protoc_insertion_point(class_scope:ProtoNet.GameZoneInfo)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_isopen();
  inline void clear_has_isopen();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 gameid_;
  bool isopen_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static GameZoneInfo* default_instance_;
};
// -------------------------------------------------------------------

class ServerInfoIpsSafeDetail : public ::google::protobuf::Message {
 public:
  ServerInfoIpsSafeDetail();
  virtual ~ServerInfoIpsSafeDetail();

  ServerInfoIpsSafeDetail(const ServerInfoIpsSafeDetail& from);

  inline ServerInfoIpsSafeDetail& operator=(const ServerInfoIpsSafeDetail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerInfoIpsSafeDetail& default_instance();

  void Swap(ServerInfoIpsSafeDetail* other);

  // implements Message ----------------------------------------------

  ServerInfoIpsSafeDetail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerInfoIpsSafeDetail& from);
  void MergeFrom(const ServerInfoIpsSafeDetail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 serverId = 1;
  inline bool has_serverid() const;
  inline void clear_serverid();
  static const int kServerIdFieldNumber = 1;
  inline ::google::protobuf::int32 serverid() const;
  inline void set_serverid(::google::protobuf::int32 value);

  // optional string serverName = 2;
  inline bool has_servername() const;
  inline void clear_servername();
  static const int kServerNameFieldNumber = 2;
  inline const ::std::string& servername() const;
  inline void set_servername(const ::std::string& value);
  inline void set_servername(const char* value);
  inline void set_servername(const char* value, size_t size);
  inline ::std::string* mutable_servername();
  inline ::std::string* release_servername();
  inline void set_allocated_servername(::std::string* servername);

  // optional int32 playerNum = 3;
  inline bool has_playernum() const;
  inline void clear_playernum();
  static const int kPlayerNumFieldNumber = 3;
  inline ::google::protobuf::int32 playernum() const;
  inline void set_playernum(::google::protobuf::int32 value);

  // optional bool isOpen = 4;
  inline bool has_isopen() const;
  inline void clear_isopen();
  static const int kIsOpenFieldNumber = 4;
  inline bool isopen() const;
  inline void set_isopen(bool value);

  // repeated .ProtoNet.SafeIpAndPortDetail safeIpAndPortDetails = 5;
  inline int safeipandportdetails_size() const;
  inline void clear_safeipandportdetails();
  static const int kSafeIpAndPortDetailsFieldNumber = 5;
  inline const ::ProtoNet::SafeIpAndPortDetail& safeipandportdetails(int index) const;
  inline ::ProtoNet::SafeIpAndPortDetail* mutable_safeipandportdetails(int index);
  inline ::ProtoNet::SafeIpAndPortDetail* add_safeipandportdetails();
  inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::SafeIpAndPortDetail >&
      safeipandportdetails() const;
  inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::SafeIpAndPortDetail >*
      mutable_safeipandportdetails();

  // @@protoc_insertion_point(class_scope:ProtoNet.ServerInfoIpsSafeDetail)
 private:
  inline void set_has_serverid();
  inline void clear_has_serverid();
  inline void set_has_servername();
  inline void clear_has_servername();
  inline void set_has_playernum();
  inline void clear_has_playernum();
  inline void set_has_isopen();
  inline void clear_has_isopen();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* servername_;
  ::google::protobuf::int32 serverid_;
  ::google::protobuf::int32 playernum_;
  ::google::protobuf::RepeatedPtrField< ::ProtoNet::SafeIpAndPortDetail > safeipandportdetails_;
  bool isopen_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static ServerInfoIpsSafeDetail* default_instance_;
};
// -------------------------------------------------------------------

class SafeIpAndPortDetail : public ::google::protobuf::Message {
 public:
  SafeIpAndPortDetail();
  virtual ~SafeIpAndPortDetail();

  SafeIpAndPortDetail(const SafeIpAndPortDetail& from);

  inline SafeIpAndPortDetail& operator=(const SafeIpAndPortDetail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SafeIpAndPortDetail& default_instance();

  void Swap(SafeIpAndPortDetail* other);

  // implements Message ----------------------------------------------

  SafeIpAndPortDetail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SafeIpAndPortDetail& from);
  void MergeFrom(const SafeIpAndPortDetail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string safeIp = 1;
  inline bool has_safeip() const;
  inline void clear_safeip();
  static const int kSafeIpFieldNumber = 1;
  inline const ::std::string& safeip() const;
  inline void set_safeip(const ::std::string& value);
  inline void set_safeip(const char* value);
  inline void set_safeip(const char* value, size_t size);
  inline ::std::string* mutable_safeip();
  inline ::std::string* release_safeip();
  inline void set_allocated_safeip(::std::string* safeip);

  // optional string safePort = 2;
  inline bool has_safeport() const;
  inline void clear_safeport();
  static const int kSafePortFieldNumber = 2;
  inline const ::std::string& safeport() const;
  inline void set_safeport(const ::std::string& value);
  inline void set_safeport(const char* value);
  inline void set_safeport(const char* value, size_t size);
  inline ::std::string* mutable_safeport();
  inline ::std::string* release_safeport();
  inline void set_allocated_safeport(::std::string* safeport);

  // optional string evironment = 3;
  inline bool has_evironment() const;
  inline void clear_evironment();
  static const int kEvironmentFieldNumber = 3;
  inline const ::std::string& evironment() const;
  inline void set_evironment(const ::std::string& value);
  inline void set_evironment(const char* value);
  inline void set_evironment(const char* value, size_t size);
  inline ::std::string* mutable_evironment();
  inline ::std::string* release_evironment();
  inline void set_allocated_evironment(::std::string* evironment);

  // optional string safeHttpPort = 4;
  inline bool has_safehttpport() const;
  inline void clear_safehttpport();
  static const int kSafeHttpPortFieldNumber = 4;
  inline const ::std::string& safehttpport() const;
  inline void set_safehttpport(const ::std::string& value);
  inline void set_safehttpport(const char* value);
  inline void set_safehttpport(const char* value, size_t size);
  inline ::std::string* mutable_safehttpport();
  inline ::std::string* release_safehttpport();
  inline void set_allocated_safehttpport(::std::string* safehttpport);

  // @@protoc_insertion_point(class_scope:ProtoNet.SafeIpAndPortDetail)
 private:
  inline void set_has_safeip();
  inline void clear_has_safeip();
  inline void set_has_safeport();
  inline void clear_has_safeport();
  inline void set_has_evironment();
  inline void clear_has_evironment();
  inline void set_has_safehttpport();
  inline void clear_has_safehttpport();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* safeip_;
  ::std::string* safeport_;
  ::std::string* evironment_;
  ::std::string* safehttpport_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static SafeIpAndPortDetail* default_instance_;
};
// -------------------------------------------------------------------

class GoldRoomServerInfos : public ::google::protobuf::Message {
 public:
  GoldRoomServerInfos();
  virtual ~GoldRoomServerInfos();

  GoldRoomServerInfos(const GoldRoomServerInfos& from);

  inline GoldRoomServerInfos& operator=(const GoldRoomServerInfos& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GoldRoomServerInfos& default_instance();

  void Swap(GoldRoomServerInfos* other);

  // implements Message ----------------------------------------------

  GoldRoomServerInfos* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GoldRoomServerInfos& from);
  void MergeFrom(const GoldRoomServerInfos& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string roomId = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 1;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const char* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  inline void set_allocated_roomid(::std::string* roomid);

  // required string roomName = 2;
  inline bool has_roomname() const;
  inline void clear_roomname();
  static const int kRoomNameFieldNumber = 2;
  inline const ::std::string& roomname() const;
  inline void set_roomname(const ::std::string& value);
  inline void set_roomname(const char* value);
  inline void set_roomname(const char* value, size_t size);
  inline ::std::string* mutable_roomname();
  inline ::std::string* release_roomname();
  inline void set_allocated_roomname(::std::string* roomname);

  // required string roomerUniqueId = 3;
  inline bool has_roomeruniqueid() const;
  inline void clear_roomeruniqueid();
  static const int kRoomerUniqueIdFieldNumber = 3;
  inline const ::std::string& roomeruniqueid() const;
  inline void set_roomeruniqueid(const ::std::string& value);
  inline void set_roomeruniqueid(const char* value);
  inline void set_roomeruniqueid(const char* value, size_t size);
  inline ::std::string* mutable_roomeruniqueid();
  inline ::std::string* release_roomeruniqueid();
  inline void set_allocated_roomeruniqueid(::std::string* roomeruniqueid);

  // required string roomerNickName = 4;
  inline bool has_roomernickname() const;
  inline void clear_roomernickname();
  static const int kRoomerNickNameFieldNumber = 4;
  inline const ::std::string& roomernickname() const;
  inline void set_roomernickname(const ::std::string& value);
  inline void set_roomernickname(const char* value);
  inline void set_roomernickname(const char* value, size_t size);
  inline ::std::string* mutable_roomernickname();
  inline ::std::string* release_roomernickname();
  inline void set_allocated_roomernickname(::std::string* roomernickname);

  // required string roomerHeadImg = 5;
  inline bool has_roomerheadimg() const;
  inline void clear_roomerheadimg();
  static const int kRoomerHeadImgFieldNumber = 5;
  inline const ::std::string& roomerheadimg() const;
  inline void set_roomerheadimg(const ::std::string& value);
  inline void set_roomerheadimg(const char* value);
  inline void set_roomerheadimg(const char* value, size_t size);
  inline ::std::string* mutable_roomerheadimg();
  inline ::std::string* release_roomerheadimg();
  inline void set_allocated_roomerheadimg(::std::string* roomerheadimg);

  // required int32 roomerHeadType = 6;
  inline bool has_roomerheadtype() const;
  inline void clear_roomerheadtype();
  static const int kRoomerHeadTypeFieldNumber = 6;
  inline ::google::protobuf::int32 roomerheadtype() const;
  inline void set_roomerheadtype(::google::protobuf::int32 value);

  // required int32 roomType = 7;
  inline bool has_roomtype() const;
  inline void clear_roomtype();
  static const int kRoomTypeFieldNumber = 7;
  inline ::google::protobuf::int32 roomtype() const;
  inline void set_roomtype(::google::protobuf::int32 value);

  // required int32 gameId = 8;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 8;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);

  // required int32 timesType = 9;
  inline bool has_timestype() const;
  inline void clear_timestype();
  static const int kTimesTypeFieldNumber = 9;
  inline ::google::protobuf::int32 timestype() const;
  inline void set_timestype(::google::protobuf::int32 value);

  // required .ProtoNet.ServerInfoIpsSafeDetail serverInfo = 10;
  inline bool has_serverinfo() const;
  inline void clear_serverinfo();
  static const int kServerInfoFieldNumber = 10;
  inline const ::ProtoNet::ServerInfoIpsSafeDetail& serverinfo() const;
  inline ::ProtoNet::ServerInfoIpsSafeDetail* mutable_serverinfo();
  inline ::ProtoNet::ServerInfoIpsSafeDetail* release_serverinfo();
  inline void set_allocated_serverinfo(::ProtoNet::ServerInfoIpsSafeDetail* serverinfo);

  // @@protoc_insertion_point(class_scope:ProtoNet.GoldRoomServerInfos)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_roomname();
  inline void clear_has_roomname();
  inline void set_has_roomeruniqueid();
  inline void clear_has_roomeruniqueid();
  inline void set_has_roomernickname();
  inline void clear_has_roomernickname();
  inline void set_has_roomerheadimg();
  inline void clear_has_roomerheadimg();
  inline void set_has_roomerheadtype();
  inline void clear_has_roomerheadtype();
  inline void set_has_roomtype();
  inline void clear_has_roomtype();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_timestype();
  inline void clear_has_timestype();
  inline void set_has_serverinfo();
  inline void clear_has_serverinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* roomid_;
  ::std::string* roomname_;
  ::std::string* roomeruniqueid_;
  ::std::string* roomernickname_;
  ::std::string* roomerheadimg_;
  ::google::protobuf::int32 roomerheadtype_;
  ::google::protobuf::int32 roomtype_;
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 timestype_;
  ::ProtoNet::ServerInfoIpsSafeDetail* serverinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static GoldRoomServerInfos* default_instance_;
};
// -------------------------------------------------------------------

class OpenRoomReplaceRecordInfo : public ::google::protobuf::Message {
 public:
  OpenRoomReplaceRecordInfo();
  virtual ~OpenRoomReplaceRecordInfo();

  OpenRoomReplaceRecordInfo(const OpenRoomReplaceRecordInfo& from);

  inline OpenRoomReplaceRecordInfo& operator=(const OpenRoomReplaceRecordInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OpenRoomReplaceRecordInfo& default_instance();

  void Swap(OpenRoomReplaceRecordInfo* other);

  // implements Message ----------------------------------------------

  OpenRoomReplaceRecordInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OpenRoomReplaceRecordInfo& from);
  void MergeFrom(const OpenRoomReplaceRecordInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string roomId = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 1;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const char* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  inline void set_allocated_roomid(::std::string* roomid);

  // required string roomerUniqueId = 2;
  inline bool has_roomeruniqueid() const;
  inline void clear_roomeruniqueid();
  static const int kRoomerUniqueIdFieldNumber = 2;
  inline const ::std::string& roomeruniqueid() const;
  inline void set_roomeruniqueid(const ::std::string& value);
  inline void set_roomeruniqueid(const char* value);
  inline void set_roomeruniqueid(const char* value, size_t size);
  inline ::std::string* mutable_roomeruniqueid();
  inline ::std::string* release_roomeruniqueid();
  inline void set_allocated_roomeruniqueid(::std::string* roomeruniqueid);

  // required string roomerNickName = 3;
  inline bool has_roomernickname() const;
  inline void clear_roomernickname();
  static const int kRoomerNickNameFieldNumber = 3;
  inline const ::std::string& roomernickname() const;
  inline void set_roomernickname(const ::std::string& value);
  inline void set_roomernickname(const char* value);
  inline void set_roomernickname(const char* value, size_t size);
  inline ::std::string* mutable_roomernickname();
  inline ::std::string* release_roomernickname();
  inline void set_allocated_roomernickname(::std::string* roomernickname);

  // required int64 createTime = 4;
  inline bool has_createtime() const;
  inline void clear_createtime();
  static const int kCreateTimeFieldNumber = 4;
  inline ::google::protobuf::int64 createtime() const;
  inline void set_createtime(::google::protobuf::int64 value);

  // required int32 gameId = 5;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 5;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);

  // required int32 roomType = 6;
  inline bool has_roomtype() const;
  inline void clear_roomtype();
  static const int kRoomTypeFieldNumber = 6;
  inline ::google::protobuf::int32 roomtype() const;
  inline void set_roomtype(::google::protobuf::int32 value);

  // required int32 timesType = 7;
  inline bool has_timestype() const;
  inline void clear_timestype();
  static const int kTimesTypeFieldNumber = 7;
  inline ::google::protobuf::int32 timestype() const;
  inline void set_timestype(::google::protobuf::int32 value);

  // required int32 totalTime = 8;
  inline bool has_totaltime() const;
  inline void clear_totaltime();
  static const int kTotalTimeFieldNumber = 8;
  inline ::google::protobuf::int32 totaltime() const;
  inline void set_totaltime(::google::protobuf::int32 value);

  // required .ProtoNet.ServerInfoIpsSafeDetail serverInfo = 9;
  inline bool has_serverinfo() const;
  inline void clear_serverinfo();
  static const int kServerInfoFieldNumber = 9;
  inline const ::ProtoNet::ServerInfoIpsSafeDetail& serverinfo() const;
  inline ::ProtoNet::ServerInfoIpsSafeDetail* mutable_serverinfo();
  inline ::ProtoNet::ServerInfoIpsSafeDetail* release_serverinfo();
  inline void set_allocated_serverinfo(::ProtoNet::ServerInfoIpsSafeDetail* serverinfo);

  // required int32 totalNum = 10;
  inline bool has_totalnum() const;
  inline void clear_totalnum();
  static const int kTotalNumFieldNumber = 10;
  inline ::google::protobuf::int32 totalnum() const;
  inline void set_totalnum(::google::protobuf::int32 value);

  // repeated .ProtoNet.ReplaceRecordOver replaceRecordOver = 11;
  inline int replacerecordover_size() const;
  inline void clear_replacerecordover();
  static const int kReplaceRecordOverFieldNumber = 11;
  inline const ::ProtoNet::ReplaceRecordOver& replacerecordover(int index) const;
  inline ::ProtoNet::ReplaceRecordOver* mutable_replacerecordover(int index);
  inline ::ProtoNet::ReplaceRecordOver* add_replacerecordover();
  inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::ReplaceRecordOver >&
      replacerecordover() const;
  inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::ReplaceRecordOver >*
      mutable_replacerecordover();

  // required string jsonParam = 12;
  inline bool has_jsonparam() const;
  inline void clear_jsonparam();
  static const int kJsonParamFieldNumber = 12;
  inline const ::std::string& jsonparam() const;
  inline void set_jsonparam(const ::std::string& value);
  inline void set_jsonparam(const char* value);
  inline void set_jsonparam(const char* value, size_t size);
  inline ::std::string* mutable_jsonparam();
  inline ::std::string* release_jsonparam();
  inline void set_allocated_jsonparam(::std::string* jsonparam);

  // required int32 status = 13;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 13;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ProtoNet.OpenRoomReplaceRecordInfo)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_roomeruniqueid();
  inline void clear_has_roomeruniqueid();
  inline void set_has_roomernickname();
  inline void clear_has_roomernickname();
  inline void set_has_createtime();
  inline void clear_has_createtime();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_roomtype();
  inline void clear_has_roomtype();
  inline void set_has_timestype();
  inline void clear_has_timestype();
  inline void set_has_totaltime();
  inline void clear_has_totaltime();
  inline void set_has_serverinfo();
  inline void clear_has_serverinfo();
  inline void set_has_totalnum();
  inline void clear_has_totalnum();
  inline void set_has_jsonparam();
  inline void clear_has_jsonparam();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* roomid_;
  ::std::string* roomeruniqueid_;
  ::std::string* roomernickname_;
  ::google::protobuf::int64 createtime_;
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 roomtype_;
  ::google::protobuf::int32 timestype_;
  ::google::protobuf::int32 totaltime_;
  ::ProtoNet::ServerInfoIpsSafeDetail* serverinfo_;
  ::google::protobuf::RepeatedPtrField< ::ProtoNet::ReplaceRecordOver > replacerecordover_;
  ::google::protobuf::int32 totalnum_;
  ::google::protobuf::int32 status_;
  ::std::string* jsonparam_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static OpenRoomReplaceRecordInfo* default_instance_;
};
// -------------------------------------------------------------------

class ReplaceRecordOver : public ::google::protobuf::Message {
 public:
  ReplaceRecordOver();
  virtual ~ReplaceRecordOver();

  ReplaceRecordOver(const ReplaceRecordOver& from);

  inline ReplaceRecordOver& operator=(const ReplaceRecordOver& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReplaceRecordOver& default_instance();

  void Swap(ReplaceRecordOver* other);

  // implements Message ----------------------------------------------

  ReplaceRecordOver* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReplaceRecordOver& from);
  void MergeFrom(const ReplaceRecordOver& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string uniqueId = 1;
  inline bool has_uniqueid() const;
  inline void clear_uniqueid();
  static const int kUniqueIdFieldNumber = 1;
  inline const ::std::string& uniqueid() const;
  inline void set_uniqueid(const ::std::string& value);
  inline void set_uniqueid(const char* value);
  inline void set_uniqueid(const char* value, size_t size);
  inline ::std::string* mutable_uniqueid();
  inline ::std::string* release_uniqueid();
  inline void set_allocated_uniqueid(::std::string* uniqueid);

  // required string nick = 2;
  inline bool has_nick() const;
  inline void clear_nick();
  static const int kNickFieldNumber = 2;
  inline const ::std::string& nick() const;
  inline void set_nick(const ::std::string& value);
  inline void set_nick(const char* value);
  inline void set_nick(const char* value, size_t size);
  inline ::std::string* mutable_nick();
  inline ::std::string* release_nick();
  inline void set_allocated_nick(::std::string* nick);

  // required string headImg = 3;
  inline bool has_headimg() const;
  inline void clear_headimg();
  static const int kHeadImgFieldNumber = 3;
  inline const ::std::string& headimg() const;
  inline void set_headimg(const ::std::string& value);
  inline void set_headimg(const char* value);
  inline void set_headimg(const char* value, size_t size);
  inline ::std::string* mutable_headimg();
  inline ::std::string* release_headimg();
  inline void set_allocated_headimg(::std::string* headimg);

  // required int32 head = 4;
  inline bool has_head() const;
  inline void clear_head();
  static const int kHeadFieldNumber = 4;
  inline ::google::protobuf::int32 head() const;
  inline void set_head(::google::protobuf::int32 value);

  // optional double score = 5;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 5;
  inline double score() const;
  inline void set_score(double value);

  // @@protoc_insertion_point(class_scope:ProtoNet.ReplaceRecordOver)
 private:
  inline void set_has_uniqueid();
  inline void clear_has_uniqueid();
  inline void set_has_nick();
  inline void clear_has_nick();
  inline void set_has_headimg();
  inline void clear_has_headimg();
  inline void set_has_head();
  inline void clear_has_head();
  inline void set_has_score();
  inline void clear_has_score();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uniqueid_;
  ::std::string* nick_;
  ::std::string* headimg_;
  double score_;
  ::google::protobuf::int32 head_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static ReplaceRecordOver* default_instance_;
};
// -------------------------------------------------------------------

class TimesInfo : public ::google::protobuf::Message {
 public:
  TimesInfo();
  virtual ~TimesInfo();

  TimesInfo(const TimesInfo& from);

  inline TimesInfo& operator=(const TimesInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TimesInfo& default_instance();

  void Swap(TimesInfo* other);

  // implements Message ----------------------------------------------

  TimesInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TimesInfo& from);
  void MergeFrom(const TimesInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 timesType = 1;
  inline bool has_timestype() const;
  inline void clear_timestype();
  static const int kTimesTypeFieldNumber = 1;
  inline ::google::protobuf::int32 timestype() const;
  inline void set_timestype(::google::protobuf::int32 value);

  // required string timesName = 2;
  inline bool has_timesname() const;
  inline void clear_timesname();
  static const int kTimesNameFieldNumber = 2;
  inline const ::std::string& timesname() const;
  inline void set_timesname(const ::std::string& value);
  inline void set_timesname(const char* value);
  inline void set_timesname(const char* value, size_t size);
  inline ::std::string* mutable_timesname();
  inline ::std::string* release_timesname();
  inline void set_allocated_timesname(::std::string* timesname);

  // required double minNeed = 3;
  inline bool has_minneed() const;
  inline void clear_minneed();
  static const int kMinNeedFieldNumber = 3;
  inline double minneed() const;
  inline void set_minneed(double value);

  // required double yazhu = 4;
  inline bool has_yazhu() const;
  inline void clear_yazhu();
  static const int kYazhuFieldNumber = 4;
  inline double yazhu() const;
  inline void set_yazhu(double value);

  // required int32 atype = 5;
  inline bool has_atype() const;
  inline void clear_atype();
  static const int kAtypeFieldNumber = 5;
  inline ::google::protobuf::int32 atype() const;
  inline void set_atype(::google::protobuf::int32 value);

  // required int32 roomType = 6;
  inline bool has_roomtype() const;
  inline void clear_roomtype();
  static const int kRoomTypeFieldNumber = 6;
  inline ::google::protobuf::int32 roomtype() const;
  inline void set_roomtype(::google::protobuf::int32 value);

  // optional string extendStr = 7;
  inline bool has_extendstr() const;
  inline void clear_extendstr();
  static const int kExtendStrFieldNumber = 7;
  inline const ::std::string& extendstr() const;
  inline void set_extendstr(const ::std::string& value);
  inline void set_extendstr(const char* value);
  inline void set_extendstr(const char* value, size_t size);
  inline ::std::string* mutable_extendstr();
  inline ::std::string* release_extendstr();
  inline void set_allocated_extendstr(::std::string* extendstr);

  // @@protoc_insertion_point(class_scope:ProtoNet.TimesInfo)
 private:
  inline void set_has_timestype();
  inline void clear_has_timestype();
  inline void set_has_timesname();
  inline void clear_has_timesname();
  inline void set_has_minneed();
  inline void clear_has_minneed();
  inline void set_has_yazhu();
  inline void clear_has_yazhu();
  inline void set_has_atype();
  inline void clear_has_atype();
  inline void set_has_roomtype();
  inline void clear_has_roomtype();
  inline void set_has_extendstr();
  inline void clear_has_extendstr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* timesname_;
  double minneed_;
  ::google::protobuf::int32 timestype_;
  ::google::protobuf::int32 atype_;
  double yazhu_;
  ::std::string* extendstr_;
  ::google::protobuf::int32 roomtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static TimesInfo* default_instance_;
};
// -------------------------------------------------------------------

class ReqGateLogin : public ::google::protobuf::Message {
 public:
  ReqGateLogin();
  virtual ~ReqGateLogin();

  ReqGateLogin(const ReqGateLogin& from);

  inline ReqGateLogin& operator=(const ReqGateLogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqGateLogin& default_instance();

  void Swap(ReqGateLogin* other);

  // implements Message ----------------------------------------------

  ReqGateLogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqGateLogin& from);
  void MergeFrom(const ReqGateLogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 playerId = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::int32 playerid() const;
  inline void set_playerid(::google::protobuf::int32 value);

  // required string ticket = 2;
  inline bool has_ticket() const;
  inline void clear_ticket();
  static const int kTicketFieldNumber = 2;
  inline const ::std::string& ticket() const;
  inline void set_ticket(const ::std::string& value);
  inline void set_ticket(const char* value);
  inline void set_ticket(const char* value, size_t size);
  inline ::std::string* mutable_ticket();
  inline ::std::string* release_ticket();
  inline void set_allocated_ticket(::std::string* ticket);

  // required string evironment = 3;
  inline bool has_evironment() const;
  inline void clear_evironment();
  static const int kEvironmentFieldNumber = 3;
  inline const ::std::string& evironment() const;
  inline void set_evironment(const ::std::string& value);
  inline void set_evironment(const char* value);
  inline void set_evironment(const char* value, size_t size);
  inline ::std::string* mutable_evironment();
  inline ::std::string* release_evironment();
  inline void set_allocated_evironment(::std::string* evironment);

  // @@protoc_insertion_point(class_scope:ProtoNet.ReqGateLogin)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_ticket();
  inline void clear_has_ticket();
  inline void set_has_evironment();
  inline void clear_has_evironment();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* ticket_;
  ::std::string* evironment_;
  ::google::protobuf::int32 playerid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static ReqGateLogin* default_instance_;
};
// -------------------------------------------------------------------

class ResGateLogin : public ::google::protobuf::Message {
 public:
  ResGateLogin();
  virtual ~ResGateLogin();

  ResGateLogin(const ResGateLogin& from);

  inline ResGateLogin& operator=(const ResGateLogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResGateLogin& default_instance();

  void Swap(ResGateLogin* other);

  // implements Message ----------------------------------------------

  ResGateLogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResGateLogin& from);
  void MergeFrom(const ResGateLogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoNet.ResponseResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::ProtoNet::ResponseResult& result() const;
  inline ::ProtoNet::ResponseResult* mutable_result();
  inline ::ProtoNet::ResponseResult* release_result();
  inline void set_allocated_result(::ProtoNet::ResponseResult* result);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResGateLogin)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoNet::ResponseResult* result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static ResGateLogin* default_instance_;
};
// -------------------------------------------------------------------

class ReqGetAccountInfo : public ::google::protobuf::Message {
 public:
  ReqGetAccountInfo();
  virtual ~ReqGetAccountInfo();

  ReqGetAccountInfo(const ReqGetAccountInfo& from);

  inline ReqGetAccountInfo& operator=(const ReqGetAccountInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqGetAccountInfo& default_instance();

  void Swap(ReqGetAccountInfo* other);

  // implements Message ----------------------------------------------

  ReqGetAccountInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqGetAccountInfo& from);
  void MergeFrom(const ReqGetAccountInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 playerId = 1;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 1;
  inline ::google::protobuf::int32 playerid() const;
  inline void set_playerid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ProtoNet.ReqGetAccountInfo)
 private:
  inline void set_has_playerid();
  inline void clear_has_playerid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 playerid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static ReqGetAccountInfo* default_instance_;
};
// -------------------------------------------------------------------

class ResGetAccountInfo : public ::google::protobuf::Message {
 public:
  ResGetAccountInfo();
  virtual ~ResGetAccountInfo();

  ResGetAccountInfo(const ResGetAccountInfo& from);

  inline ResGetAccountInfo& operator=(const ResGetAccountInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResGetAccountInfo& default_instance();

  void Swap(ResGetAccountInfo* other);

  // implements Message ----------------------------------------------

  ResGetAccountInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResGetAccountInfo& from);
  void MergeFrom(const ResGetAccountInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoNet.ResponseResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::ProtoNet::ResponseResult& result() const;
  inline ::ProtoNet::ResponseResult* mutable_result();
  inline ::ProtoNet::ResponseResult* release_result();
  inline void set_allocated_result(::ProtoNet::ResponseResult* result);

  // optional .ProtoNet.AccountInfo accountInfo = 2;
  inline bool has_accountinfo() const;
  inline void clear_accountinfo();
  static const int kAccountInfoFieldNumber = 2;
  inline const ::ProtoNet::AccountInfo& accountinfo() const;
  inline ::ProtoNet::AccountInfo* mutable_accountinfo();
  inline ::ProtoNet::AccountInfo* release_accountinfo();
  inline void set_allocated_accountinfo(::ProtoNet::AccountInfo* accountinfo);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResGetAccountInfo)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_accountinfo();
  inline void clear_has_accountinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoNet::ResponseResult* result_;
  ::ProtoNet::AccountInfo* accountinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static ResGetAccountInfo* default_instance_;
};
// -------------------------------------------------------------------

class ReqGetGameZoneInfoList : public ::google::protobuf::Message {
 public:
  ReqGetGameZoneInfoList();
  virtual ~ReqGetGameZoneInfoList();

  ReqGetGameZoneInfoList(const ReqGetGameZoneInfoList& from);

  inline ReqGetGameZoneInfoList& operator=(const ReqGetGameZoneInfoList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqGetGameZoneInfoList& default_instance();

  void Swap(ReqGetGameZoneInfoList* other);

  // implements Message ----------------------------------------------

  ReqGetGameZoneInfoList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqGetGameZoneInfoList& from);
  void MergeFrom(const ReqGetGameZoneInfoList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ProtoNet.ReqGetGameZoneInfoList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static ReqGetGameZoneInfoList* default_instance_;
};
// -------------------------------------------------------------------

class ResGetGameZoneInfoList : public ::google::protobuf::Message {
 public:
  ResGetGameZoneInfoList();
  virtual ~ResGetGameZoneInfoList();

  ResGetGameZoneInfoList(const ResGetGameZoneInfoList& from);

  inline ResGetGameZoneInfoList& operator=(const ResGetGameZoneInfoList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResGetGameZoneInfoList& default_instance();

  void Swap(ResGetGameZoneInfoList* other);

  // implements Message ----------------------------------------------

  ResGetGameZoneInfoList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResGetGameZoneInfoList& from);
  void MergeFrom(const ResGetGameZoneInfoList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoNet.ResponseResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::ProtoNet::ResponseResult& result() const;
  inline ::ProtoNet::ResponseResult* mutable_result();
  inline ::ProtoNet::ResponseResult* release_result();
  inline void set_allocated_result(::ProtoNet::ResponseResult* result);

  // repeated .ProtoNet.GameZoneInfo gameZoneInfos = 2;
  inline int gamezoneinfos_size() const;
  inline void clear_gamezoneinfos();
  static const int kGameZoneInfosFieldNumber = 2;
  inline const ::ProtoNet::GameZoneInfo& gamezoneinfos(int index) const;
  inline ::ProtoNet::GameZoneInfo* mutable_gamezoneinfos(int index);
  inline ::ProtoNet::GameZoneInfo* add_gamezoneinfos();
  inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::GameZoneInfo >&
      gamezoneinfos() const;
  inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::GameZoneInfo >*
      mutable_gamezoneinfos();

  // @@protoc_insertion_point(class_scope:ProtoNet.ResGetGameZoneInfoList)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoNet::ResponseResult* result_;
  ::google::protobuf::RepeatedPtrField< ::ProtoNet::GameZoneInfo > gamezoneinfos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static ResGetGameZoneInfoList* default_instance_;
};
// -------------------------------------------------------------------

class ReqGetGameZoneDetail : public ::google::protobuf::Message {
 public:
  ReqGetGameZoneDetail();
  virtual ~ReqGetGameZoneDetail();

  ReqGetGameZoneDetail(const ReqGetGameZoneDetail& from);

  inline ReqGetGameZoneDetail& operator=(const ReqGetGameZoneDetail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqGetGameZoneDetail& default_instance();

  void Swap(ReqGetGameZoneDetail* other);

  // implements Message ----------------------------------------------

  ReqGetGameZoneDetail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqGetGameZoneDetail& from);
  void MergeFrom(const ReqGetGameZoneDetail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);

  // required int32 roomType = 2;
  inline bool has_roomtype() const;
  inline void clear_roomtype();
  static const int kRoomTypeFieldNumber = 2;
  inline ::google::protobuf::int32 roomtype() const;
  inline void set_roomtype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ProtoNet.ReqGetGameZoneDetail)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_roomtype();
  inline void clear_has_roomtype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 roomtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static ReqGetGameZoneDetail* default_instance_;
};
// -------------------------------------------------------------------

class ResGetGameZoneDetail : public ::google::protobuf::Message {
 public:
  ResGetGameZoneDetail();
  virtual ~ResGetGameZoneDetail();

  ResGetGameZoneDetail(const ResGetGameZoneDetail& from);

  inline ResGetGameZoneDetail& operator=(const ResGetGameZoneDetail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResGetGameZoneDetail& default_instance();

  void Swap(ResGetGameZoneDetail* other);

  // implements Message ----------------------------------------------

  ResGetGameZoneDetail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResGetGameZoneDetail& from);
  void MergeFrom(const ResGetGameZoneDetail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoNet.ResponseResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::ProtoNet::ResponseResult& result() const;
  inline ::ProtoNet::ResponseResult* mutable_result();
  inline ::ProtoNet::ResponseResult* release_result();
  inline void set_allocated_result(::ProtoNet::ResponseResult* result);

  // optional int32 gameId = 2;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 2;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);

  // repeated .ProtoNet.ServerInfoIpsSafeDetail logicDetails = 3;
  inline int logicdetails_size() const;
  inline void clear_logicdetails();
  static const int kLogicDetailsFieldNumber = 3;
  inline const ::ProtoNet::ServerInfoIpsSafeDetail& logicdetails(int index) const;
  inline ::ProtoNet::ServerInfoIpsSafeDetail* mutable_logicdetails(int index);
  inline ::ProtoNet::ServerInfoIpsSafeDetail* add_logicdetails();
  inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::ServerInfoIpsSafeDetail >&
      logicdetails() const;
  inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::ServerInfoIpsSafeDetail >*
      mutable_logicdetails();

  // repeated .ProtoNet.TimesInfo timesInfos = 4;
  inline int timesinfos_size() const;
  inline void clear_timesinfos();
  static const int kTimesInfosFieldNumber = 4;
  inline const ::ProtoNet::TimesInfo& timesinfos(int index) const;
  inline ::ProtoNet::TimesInfo* mutable_timesinfos(int index);
  inline ::ProtoNet::TimesInfo* add_timesinfos();
  inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::TimesInfo >&
      timesinfos() const;
  inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::TimesInfo >*
      mutable_timesinfos();

  // @@protoc_insertion_point(class_scope:ProtoNet.ResGetGameZoneDetail)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_gameid();
  inline void clear_has_gameid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoNet::ResponseResult* result_;
  ::google::protobuf::RepeatedPtrField< ::ProtoNet::ServerInfoIpsSafeDetail > logicdetails_;
  ::google::protobuf::RepeatedPtrField< ::ProtoNet::TimesInfo > timesinfos_;
  ::google::protobuf::int32 gameid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static ResGetGameZoneDetail* default_instance_;
};
// -------------------------------------------------------------------

class ReqJoinLogicGameRoom : public ::google::protobuf::Message {
 public:
  ReqJoinLogicGameRoom();
  virtual ~ReqJoinLogicGameRoom();

  ReqJoinLogicGameRoom(const ReqJoinLogicGameRoom& from);

  inline ReqJoinLogicGameRoom& operator=(const ReqJoinLogicGameRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqJoinLogicGameRoom& default_instance();

  void Swap(ReqJoinLogicGameRoom* other);

  // implements Message ----------------------------------------------

  ReqJoinLogicGameRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqJoinLogicGameRoom& from);
  void MergeFrom(const ReqJoinLogicGameRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string roomId = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 1;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const char* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  inline void set_allocated_roomid(::std::string* roomid);

  // @@protoc_insertion_point(class_scope:ProtoNet.ReqJoinLogicGameRoom)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* roomid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static ReqJoinLogicGameRoom* default_instance_;
};
// -------------------------------------------------------------------

class ResJoinLogicGameRoom : public ::google::protobuf::Message {
 public:
  ResJoinLogicGameRoom();
  virtual ~ResJoinLogicGameRoom();

  ResJoinLogicGameRoom(const ResJoinLogicGameRoom& from);

  inline ResJoinLogicGameRoom& operator=(const ResJoinLogicGameRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResJoinLogicGameRoom& default_instance();

  void Swap(ResJoinLogicGameRoom* other);

  // implements Message ----------------------------------------------

  ResJoinLogicGameRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResJoinLogicGameRoom& from);
  void MergeFrom(const ResJoinLogicGameRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoNet.ResponseResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::ProtoNet::ResponseResult& result() const;
  inline ::ProtoNet::ResponseResult* mutable_result();
  inline ::ProtoNet::ResponseResult* release_result();
  inline void set_allocated_result(::ProtoNet::ResponseResult* result);

  // optional .ProtoNet.ServerInfoIpsSafeDetail bestServerInfo = 2;
  inline bool has_bestserverinfo() const;
  inline void clear_bestserverinfo();
  static const int kBestServerInfoFieldNumber = 2;
  inline const ::ProtoNet::ServerInfoIpsSafeDetail& bestserverinfo() const;
  inline ::ProtoNet::ServerInfoIpsSafeDetail* mutable_bestserverinfo();
  inline ::ProtoNet::ServerInfoIpsSafeDetail* release_bestserverinfo();
  inline void set_allocated_bestserverinfo(::ProtoNet::ServerInfoIpsSafeDetail* bestserverinfo);

  // optional int32 gameId = 3;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 3;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);

  // optional int32 roomType = 4;
  inline bool has_roomtype() const;
  inline void clear_roomtype();
  static const int kRoomTypeFieldNumber = 4;
  inline ::google::protobuf::int32 roomtype() const;
  inline void set_roomtype(::google::protobuf::int32 value);

  // optional int32 timesType = 5;
  inline bool has_timestype() const;
  inline void clear_timestype();
  static const int kTimesTypeFieldNumber = 5;
  inline ::google::protobuf::int32 timestype() const;
  inline void set_timestype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResJoinLogicGameRoom)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_bestserverinfo();
  inline void clear_has_bestserverinfo();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_roomtype();
  inline void clear_has_roomtype();
  inline void set_has_timestype();
  inline void clear_has_timestype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoNet::ResponseResult* result_;
  ::ProtoNet::ServerInfoIpsSafeDetail* bestserverinfo_;
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 roomtype_;
  ::google::protobuf::int32 timestype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static ResJoinLogicGameRoom* default_instance_;
};
// -------------------------------------------------------------------

class ReqQuickJoinGameRoom : public ::google::protobuf::Message {
 public:
  ReqQuickJoinGameRoom();
  virtual ~ReqQuickJoinGameRoom();

  ReqQuickJoinGameRoom(const ReqQuickJoinGameRoom& from);

  inline ReqQuickJoinGameRoom& operator=(const ReqQuickJoinGameRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqQuickJoinGameRoom& default_instance();

  void Swap(ReqQuickJoinGameRoom* other);

  // implements Message ----------------------------------------------

  ReqQuickJoinGameRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqQuickJoinGameRoom& from);
  void MergeFrom(const ReqQuickJoinGameRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);

  // required int32 roomType = 2;
  inline bool has_roomtype() const;
  inline void clear_roomtype();
  static const int kRoomTypeFieldNumber = 2;
  inline ::google::protobuf::int32 roomtype() const;
  inline void set_roomtype(::google::protobuf::int32 value);

  // required int32 timesType = 3;
  inline bool has_timestype() const;
  inline void clear_timestype();
  static const int kTimesTypeFieldNumber = 3;
  inline ::google::protobuf::int32 timestype() const;
  inline void set_timestype(::google::protobuf::int32 value);

  // optional string pipeiParam = 4;
  inline bool has_pipeiparam() const;
  inline void clear_pipeiparam();
  static const int kPipeiParamFieldNumber = 4;
  inline const ::std::string& pipeiparam() const;
  inline void set_pipeiparam(const ::std::string& value);
  inline void set_pipeiparam(const char* value);
  inline void set_pipeiparam(const char* value, size_t size);
  inline ::std::string* mutable_pipeiparam();
  inline ::std::string* release_pipeiparam();
  inline void set_allocated_pipeiparam(::std::string* pipeiparam);

  // @@protoc_insertion_point(class_scope:ProtoNet.ReqQuickJoinGameRoom)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_roomtype();
  inline void clear_has_roomtype();
  inline void set_has_timestype();
  inline void clear_has_timestype();
  inline void set_has_pipeiparam();
  inline void clear_has_pipeiparam();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 roomtype_;
  ::std::string* pipeiparam_;
  ::google::protobuf::int32 timestype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static ReqQuickJoinGameRoom* default_instance_;
};
// -------------------------------------------------------------------

class ResQuickJoinGameRoom : public ::google::protobuf::Message {
 public:
  ResQuickJoinGameRoom();
  virtual ~ResQuickJoinGameRoom();

  ResQuickJoinGameRoom(const ResQuickJoinGameRoom& from);

  inline ResQuickJoinGameRoom& operator=(const ResQuickJoinGameRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResQuickJoinGameRoom& default_instance();

  void Swap(ResQuickJoinGameRoom* other);

  // implements Message ----------------------------------------------

  ResQuickJoinGameRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResQuickJoinGameRoom& from);
  void MergeFrom(const ResQuickJoinGameRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoNet.ResponseResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::ProtoNet::ResponseResult& result() const;
  inline ::ProtoNet::ResponseResult* mutable_result();
  inline ::ProtoNet::ResponseResult* release_result();
  inline void set_allocated_result(::ProtoNet::ResponseResult* result);

  // optional int32 operate = 2;
  inline bool has_operate() const;
  inline void clear_operate();
  static const int kOperateFieldNumber = 2;
  inline ::google::protobuf::int32 operate() const;
  inline void set_operate(::google::protobuf::int32 value);

  // optional int32 roomType = 3;
  inline bool has_roomtype() const;
  inline void clear_roomtype();
  static const int kRoomTypeFieldNumber = 3;
  inline ::google::protobuf::int32 roomtype() const;
  inline void set_roomtype(::google::protobuf::int32 value);

  // optional .ProtoNet.ServerInfoIpsSafeDetail bestServerInfo = 4;
  inline bool has_bestserverinfo() const;
  inline void clear_bestserverinfo();
  static const int kBestServerInfoFieldNumber = 4;
  inline const ::ProtoNet::ServerInfoIpsSafeDetail& bestserverinfo() const;
  inline ::ProtoNet::ServerInfoIpsSafeDetail* mutable_bestserverinfo();
  inline ::ProtoNet::ServerInfoIpsSafeDetail* release_bestserverinfo();
  inline void set_allocated_bestserverinfo(::ProtoNet::ServerInfoIpsSafeDetail* bestserverinfo);

  // optional string roomId = 5;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 5;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const char* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  inline void set_allocated_roomid(::std::string* roomid);

  // repeated .ProtoNet.ServerInfoIpsSafeDetail logicDetails = 6;
  inline int logicdetails_size() const;
  inline void clear_logicdetails();
  static const int kLogicDetailsFieldNumber = 6;
  inline const ::ProtoNet::ServerInfoIpsSafeDetail& logicdetails(int index) const;
  inline ::ProtoNet::ServerInfoIpsSafeDetail* mutable_logicdetails(int index);
  inline ::ProtoNet::ServerInfoIpsSafeDetail* add_logicdetails();
  inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::ServerInfoIpsSafeDetail >&
      logicdetails() const;
  inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::ServerInfoIpsSafeDetail >*
      mutable_logicdetails();

  // optional int32 gameId = 7;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 7;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);

  // optional int32 timesType = 8;
  inline bool has_timestype() const;
  inline void clear_timestype();
  static const int kTimesTypeFieldNumber = 8;
  inline ::google::protobuf::int32 timestype() const;
  inline void set_timestype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResQuickJoinGameRoom)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_operate();
  inline void clear_has_operate();
  inline void set_has_roomtype();
  inline void clear_has_roomtype();
  inline void set_has_bestserverinfo();
  inline void clear_has_bestserverinfo();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_timestype();
  inline void clear_has_timestype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoNet::ResponseResult* result_;
  ::google::protobuf::int32 operate_;
  ::google::protobuf::int32 roomtype_;
  ::ProtoNet::ServerInfoIpsSafeDetail* bestserverinfo_;
  ::std::string* roomid_;
  ::google::protobuf::RepeatedPtrField< ::ProtoNet::ServerInfoIpsSafeDetail > logicdetails_;
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 timestype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static ResQuickJoinGameRoom* default_instance_;
};
// -------------------------------------------------------------------

class ResNotifyBroadPlatMarquee : public ::google::protobuf::Message {
 public:
  ResNotifyBroadPlatMarquee();
  virtual ~ResNotifyBroadPlatMarquee();

  ResNotifyBroadPlatMarquee(const ResNotifyBroadPlatMarquee& from);

  inline ResNotifyBroadPlatMarquee& operator=(const ResNotifyBroadPlatMarquee& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResNotifyBroadPlatMarquee& default_instance();

  void Swap(ResNotifyBroadPlatMarquee* other);

  // implements Message ----------------------------------------------

  ResNotifyBroadPlatMarquee* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResNotifyBroadPlatMarquee& from);
  void MergeFrom(const ResNotifyBroadPlatMarquee& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required string msg = 2;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 2;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // required int32 count = 3;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 3;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResNotifyBroadPlatMarquee)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_msg();
  inline void clear_has_msg();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msg_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static ResNotifyBroadPlatMarquee* default_instance_;
};
// -------------------------------------------------------------------

class ResNotifySelfDataChange : public ::google::protobuf::Message {
 public:
  ResNotifySelfDataChange();
  virtual ~ResNotifySelfDataChange();

  ResNotifySelfDataChange(const ResNotifySelfDataChange& from);

  inline ResNotifySelfDataChange& operator=(const ResNotifySelfDataChange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResNotifySelfDataChange& default_instance();

  void Swap(ResNotifySelfDataChange* other);

  // implements Message ----------------------------------------------

  ResNotifySelfDataChange* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResNotifySelfDataChange& from);
  void MergeFrom(const ResNotifySelfDataChange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoNet.AccountInfo accountInfo = 1;
  inline bool has_accountinfo() const;
  inline void clear_accountinfo();
  static const int kAccountInfoFieldNumber = 1;
  inline const ::ProtoNet::AccountInfo& accountinfo() const;
  inline ::ProtoNet::AccountInfo* mutable_accountinfo();
  inline ::ProtoNet::AccountInfo* release_accountinfo();
  inline void set_allocated_accountinfo(::ProtoNet::AccountInfo* accountinfo);

  // optional int32 charge = 2;
  inline bool has_charge() const;
  inline void clear_charge();
  static const int kChargeFieldNumber = 2;
  inline ::google::protobuf::int32 charge() const;
  inline void set_charge(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResNotifySelfDataChange)
 private:
  inline void set_has_accountinfo();
  inline void clear_has_accountinfo();
  inline void set_has_charge();
  inline void clear_has_charge();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoNet::AccountInfo* accountinfo_;
  ::google::protobuf::int32 charge_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static ResNotifySelfDataChange* default_instance_;
};
// -------------------------------------------------------------------

class ReqGetRoomBrifeList : public ::google::protobuf::Message {
 public:
  ReqGetRoomBrifeList();
  virtual ~ReqGetRoomBrifeList();

  ReqGetRoomBrifeList(const ReqGetRoomBrifeList& from);

  inline ReqGetRoomBrifeList& operator=(const ReqGetRoomBrifeList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqGetRoomBrifeList& default_instance();

  void Swap(ReqGetRoomBrifeList* other);

  // implements Message ----------------------------------------------

  ReqGetRoomBrifeList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqGetRoomBrifeList& from);
  void MergeFrom(const ReqGetRoomBrifeList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ProtoNet.ReqGetRoomBrifeList)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 gameid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static ReqGetRoomBrifeList* default_instance_;
};
// -------------------------------------------------------------------

class ResGetRoomBrifeList : public ::google::protobuf::Message {
 public:
  ResGetRoomBrifeList();
  virtual ~ResGetRoomBrifeList();

  ResGetRoomBrifeList(const ResGetRoomBrifeList& from);

  inline ResGetRoomBrifeList& operator=(const ResGetRoomBrifeList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResGetRoomBrifeList& default_instance();

  void Swap(ResGetRoomBrifeList* other);

  // implements Message ----------------------------------------------

  ResGetRoomBrifeList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResGetRoomBrifeList& from);
  void MergeFrom(const ResGetRoomBrifeList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoNet.ResponseResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::ProtoNet::ResponseResult& result() const;
  inline ::ProtoNet::ResponseResult* mutable_result();
  inline ::ProtoNet::ResponseResult* release_result();
  inline void set_allocated_result(::ProtoNet::ResponseResult* result);

  // repeated .ProtoNet.GoldRoomServerInfos goldRoomServerInfos = 2;
  inline int goldroomserverinfos_size() const;
  inline void clear_goldroomserverinfos();
  static const int kGoldRoomServerInfosFieldNumber = 2;
  inline const ::ProtoNet::GoldRoomServerInfos& goldroomserverinfos(int index) const;
  inline ::ProtoNet::GoldRoomServerInfos* mutable_goldroomserverinfos(int index);
  inline ::ProtoNet::GoldRoomServerInfos* add_goldroomserverinfos();
  inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::GoldRoomServerInfos >&
      goldroomserverinfos() const;
  inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::GoldRoomServerInfos >*
      mutable_goldroomserverinfos();

  // @@protoc_insertion_point(class_scope:ProtoNet.ResGetRoomBrifeList)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoNet::ResponseResult* result_;
  ::google::protobuf::RepeatedPtrField< ::ProtoNet::GoldRoomServerInfos > goldroomserverinfos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static ResGetRoomBrifeList* default_instance_;
};
// -------------------------------------------------------------------

class ReqCheckInMatch : public ::google::protobuf::Message {
 public:
  ReqCheckInMatch();
  virtual ~ReqCheckInMatch();

  ReqCheckInMatch(const ReqCheckInMatch& from);

  inline ReqCheckInMatch& operator=(const ReqCheckInMatch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqCheckInMatch& default_instance();

  void Swap(ReqCheckInMatch* other);

  // implements Message ----------------------------------------------

  ReqCheckInMatch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqCheckInMatch& from);
  void MergeFrom(const ReqCheckInMatch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ProtoNet.ReqCheckInMatch)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static ReqCheckInMatch* default_instance_;
};
// -------------------------------------------------------------------

class ResCheckInMatch : public ::google::protobuf::Message {
 public:
  ResCheckInMatch();
  virtual ~ResCheckInMatch();

  ResCheckInMatch(const ResCheckInMatch& from);

  inline ResCheckInMatch& operator=(const ResCheckInMatch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResCheckInMatch& default_instance();

  void Swap(ResCheckInMatch* other);

  // implements Message ----------------------------------------------

  ResCheckInMatch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResCheckInMatch& from);
  void MergeFrom(const ResCheckInMatch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoNet.ResponseResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::ProtoNet::ResponseResult& result() const;
  inline ::ProtoNet::ResponseResult* mutable_result();
  inline ::ProtoNet::ResponseResult* release_result();
  inline void set_allocated_result(::ProtoNet::ResponseResult* result);

  // optional int32 inMatch = 2;
  inline bool has_inmatch() const;
  inline void clear_inmatch();
  static const int kInMatchFieldNumber = 2;
  inline ::google::protobuf::int32 inmatch() const;
  inline void set_inmatch(::google::protobuf::int32 value);

  // optional string randId = 3;
  inline bool has_randid() const;
  inline void clear_randid();
  static const int kRandIdFieldNumber = 3;
  inline const ::std::string& randid() const;
  inline void set_randid(const ::std::string& value);
  inline void set_randid(const char* value);
  inline void set_randid(const char* value, size_t size);
  inline ::std::string* mutable_randid();
  inline ::std::string* release_randid();
  inline void set_allocated_randid(::std::string* randid);

  // optional int32 matchConfigId = 4;
  inline bool has_matchconfigid() const;
  inline void clear_matchconfigid();
  static const int kMatchConfigIdFieldNumber = 4;
  inline ::google::protobuf::int32 matchconfigid() const;
  inline void set_matchconfigid(::google::protobuf::int32 value);

  // optional int32 gameId = 5;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 5;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);

  // optional int32 selfRank = 6;
  inline bool has_selfrank() const;
  inline void clear_selfrank();
  static const int kSelfRankFieldNumber = 6;
  inline ::google::protobuf::int32 selfrank() const;
  inline void set_selfrank(::google::protobuf::int32 value);

  // optional int32 from = 7;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 7;
  inline ::google::protobuf::int32 from() const;
  inline void set_from(::google::protobuf::int32 value);

  // optional int32 to = 8;
  inline bool has_to() const;
  inline void clear_to();
  static const int kToFieldNumber = 8;
  inline ::google::protobuf::int32 to() const;
  inline void set_to(::google::protobuf::int32 value);

  // optional int32 taotai = 9;
  inline bool has_taotai() const;
  inline void clear_taotai();
  static const int kTaotaiFieldNumber = 9;
  inline ::google::protobuf::int32 taotai() const;
  inline void set_taotai(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResCheckInMatch)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_inmatch();
  inline void clear_has_inmatch();
  inline void set_has_randid();
  inline void clear_has_randid();
  inline void set_has_matchconfigid();
  inline void clear_has_matchconfigid();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_selfrank();
  inline void clear_has_selfrank();
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_to();
  inline void clear_has_to();
  inline void set_has_taotai();
  inline void clear_has_taotai();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoNet::ResponseResult* result_;
  ::std::string* randid_;
  ::google::protobuf::int32 inmatch_;
  ::google::protobuf::int32 matchconfigid_;
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 selfrank_;
  ::google::protobuf::int32 from_;
  ::google::protobuf::int32 to_;
  ::google::protobuf::int32 taotai_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static ResCheckInMatch* default_instance_;
};
// -------------------------------------------------------------------

class ReqOpenRoomReplace : public ::google::protobuf::Message {
 public:
  ReqOpenRoomReplace();
  virtual ~ReqOpenRoomReplace();

  ReqOpenRoomReplace(const ReqOpenRoomReplace& from);

  inline ReqOpenRoomReplace& operator=(const ReqOpenRoomReplace& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqOpenRoomReplace& default_instance();

  void Swap(ReqOpenRoomReplace* other);

  // implements Message ----------------------------------------------

  ReqOpenRoomReplace* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqOpenRoomReplace& from);
  void MergeFrom(const ReqOpenRoomReplace& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 roomType = 1;
  inline bool has_roomtype() const;
  inline void clear_roomtype();
  static const int kRoomTypeFieldNumber = 1;
  inline ::google::protobuf::int32 roomtype() const;
  inline void set_roomtype(::google::protobuf::int32 value);

  // required int32 times = 2;
  inline bool has_times() const;
  inline void clear_times();
  static const int kTimesFieldNumber = 2;
  inline ::google::protobuf::int32 times() const;
  inline void set_times(::google::protobuf::int32 value);

  // optional string paramString = 3;
  inline bool has_paramstring() const;
  inline void clear_paramstring();
  static const int kParamStringFieldNumber = 3;
  inline const ::std::string& paramstring() const;
  inline void set_paramstring(const ::std::string& value);
  inline void set_paramstring(const char* value);
  inline void set_paramstring(const char* value, size_t size);
  inline ::std::string* mutable_paramstring();
  inline ::std::string* release_paramstring();
  inline void set_allocated_paramstring(::std::string* paramstring);

  // required int32 timesType = 4;
  inline bool has_timestype() const;
  inline void clear_timestype();
  static const int kTimesTypeFieldNumber = 4;
  inline ::google::protobuf::int32 timestype() const;
  inline void set_timestype(::google::protobuf::int32 value);

  // optional int32 halfWayJoin = 5;
  inline bool has_halfwayjoin() const;
  inline void clear_halfwayjoin();
  static const int kHalfWayJoinFieldNumber = 5;
  inline ::google::protobuf::int32 halfwayjoin() const;
  inline void set_halfwayjoin(::google::protobuf::int32 value);

  // optional int32 maxPlayerNum = 6;
  inline bool has_maxplayernum() const;
  inline void clear_maxplayernum();
  static const int kMaxPlayerNumFieldNumber = 6;
  inline ::google::protobuf::int32 maxplayernum() const;
  inline void set_maxplayernum(::google::protobuf::int32 value);

  // optional double yazhu = 7;
  inline bool has_yazhu() const;
  inline void clear_yazhu();
  static const int kYazhuFieldNumber = 7;
  inline double yazhu() const;
  inline void set_yazhu(double value);

  // required int32 gameId = 8;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 8;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ProtoNet.ReqOpenRoomReplace)
 private:
  inline void set_has_roomtype();
  inline void clear_has_roomtype();
  inline void set_has_times();
  inline void clear_has_times();
  inline void set_has_paramstring();
  inline void clear_has_paramstring();
  inline void set_has_timestype();
  inline void clear_has_timestype();
  inline void set_has_halfwayjoin();
  inline void clear_has_halfwayjoin();
  inline void set_has_maxplayernum();
  inline void clear_has_maxplayernum();
  inline void set_has_yazhu();
  inline void clear_has_yazhu();
  inline void set_has_gameid();
  inline void clear_has_gameid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 roomtype_;
  ::google::protobuf::int32 times_;
  ::std::string* paramstring_;
  ::google::protobuf::int32 timestype_;
  ::google::protobuf::int32 halfwayjoin_;
  double yazhu_;
  ::google::protobuf::int32 maxplayernum_;
  ::google::protobuf::int32 gameid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static ReqOpenRoomReplace* default_instance_;
};
// -------------------------------------------------------------------

class ResOpenRoomReplace : public ::google::protobuf::Message {
 public:
  ResOpenRoomReplace();
  virtual ~ResOpenRoomReplace();

  ResOpenRoomReplace(const ResOpenRoomReplace& from);

  inline ResOpenRoomReplace& operator=(const ResOpenRoomReplace& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResOpenRoomReplace& default_instance();

  void Swap(ResOpenRoomReplace* other);

  // implements Message ----------------------------------------------

  ResOpenRoomReplace* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResOpenRoomReplace& from);
  void MergeFrom(const ResOpenRoomReplace& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoNet.ResponseResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::ProtoNet::ResponseResult& result() const;
  inline ::ProtoNet::ResponseResult* mutable_result();
  inline ::ProtoNet::ResponseResult* release_result();
  inline void set_allocated_result(::ProtoNet::ResponseResult* result);

  // optional string roomId = 2;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 2;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const char* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  inline void set_allocated_roomid(::std::string* roomid);

  // optional int32 roomType = 3;
  inline bool has_roomtype() const;
  inline void clear_roomtype();
  static const int kRoomTypeFieldNumber = 3;
  inline ::google::protobuf::int32 roomtype() const;
  inline void set_roomtype(::google::protobuf::int32 value);

  // optional int32 times = 4;
  inline bool has_times() const;
  inline void clear_times();
  static const int kTimesFieldNumber = 4;
  inline ::google::protobuf::int32 times() const;
  inline void set_times(::google::protobuf::int32 value);

  // optional string paramString = 5;
  inline bool has_paramstring() const;
  inline void clear_paramstring();
  static const int kParamStringFieldNumber = 5;
  inline const ::std::string& paramstring() const;
  inline void set_paramstring(const ::std::string& value);
  inline void set_paramstring(const char* value);
  inline void set_paramstring(const char* value, size_t size);
  inline ::std::string* mutable_paramstring();
  inline ::std::string* release_paramstring();
  inline void set_allocated_paramstring(::std::string* paramstring);

  // optional int32 timesType = 6;
  inline bool has_timestype() const;
  inline void clear_timestype();
  static const int kTimesTypeFieldNumber = 6;
  inline ::google::protobuf::int32 timestype() const;
  inline void set_timestype(::google::protobuf::int32 value);

  // optional int32 halfWayJoin = 7;
  inline bool has_halfwayjoin() const;
  inline void clear_halfwayjoin();
  static const int kHalfWayJoinFieldNumber = 7;
  inline ::google::protobuf::int32 halfwayjoin() const;
  inline void set_halfwayjoin(::google::protobuf::int32 value);

  // optional int32 maxPlayerNum = 8;
  inline bool has_maxplayernum() const;
  inline void clear_maxplayernum();
  static const int kMaxPlayerNumFieldNumber = 8;
  inline ::google::protobuf::int32 maxplayernum() const;
  inline void set_maxplayernum(::google::protobuf::int32 value);

  // optional double yazhu = 9;
  inline bool has_yazhu() const;
  inline void clear_yazhu();
  static const int kYazhuFieldNumber = 9;
  inline double yazhu() const;
  inline void set_yazhu(double value);

  // optional int32 gameId = 10;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 10;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);

  // optional .ProtoNet.ServerInfoIpsSafeDetail serverInfo = 11;
  inline bool has_serverinfo() const;
  inline void clear_serverinfo();
  static const int kServerInfoFieldNumber = 11;
  inline const ::ProtoNet::ServerInfoIpsSafeDetail& serverinfo() const;
  inline ::ProtoNet::ServerInfoIpsSafeDetail* mutable_serverinfo();
  inline ::ProtoNet::ServerInfoIpsSafeDetail* release_serverinfo();
  inline void set_allocated_serverinfo(::ProtoNet::ServerInfoIpsSafeDetail* serverinfo);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResOpenRoomReplace)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_roomtype();
  inline void clear_has_roomtype();
  inline void set_has_times();
  inline void clear_has_times();
  inline void set_has_paramstring();
  inline void clear_has_paramstring();
  inline void set_has_timestype();
  inline void clear_has_timestype();
  inline void set_has_halfwayjoin();
  inline void clear_has_halfwayjoin();
  inline void set_has_maxplayernum();
  inline void clear_has_maxplayernum();
  inline void set_has_yazhu();
  inline void clear_has_yazhu();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_serverinfo();
  inline void clear_has_serverinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoNet::ResponseResult* result_;
  ::std::string* roomid_;
  ::google::protobuf::int32 roomtype_;
  ::google::protobuf::int32 times_;
  ::std::string* paramstring_;
  ::google::protobuf::int32 timestype_;
  ::google::protobuf::int32 halfwayjoin_;
  double yazhu_;
  ::google::protobuf::int32 maxplayernum_;
  ::google::protobuf::int32 gameid_;
  ::ProtoNet::ServerInfoIpsSafeDetail* serverinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static ResOpenRoomReplace* default_instance_;
};
// -------------------------------------------------------------------

class ReqOpenRoomReplaceRecordList : public ::google::protobuf::Message {
 public:
  ReqOpenRoomReplaceRecordList();
  virtual ~ReqOpenRoomReplaceRecordList();

  ReqOpenRoomReplaceRecordList(const ReqOpenRoomReplaceRecordList& from);

  inline ReqOpenRoomReplaceRecordList& operator=(const ReqOpenRoomReplaceRecordList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqOpenRoomReplaceRecordList& default_instance();

  void Swap(ReqOpenRoomReplaceRecordList* other);

  // implements Message ----------------------------------------------

  ReqOpenRoomReplaceRecordList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqOpenRoomReplaceRecordList& from);
  void MergeFrom(const ReqOpenRoomReplaceRecordList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ProtoNet.ReqOpenRoomReplaceRecordList)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static ReqOpenRoomReplaceRecordList* default_instance_;
};
// -------------------------------------------------------------------

class ResOpenRoomReplaceRecord_List : public ::google::protobuf::Message {
 public:
  ResOpenRoomReplaceRecord_List();
  virtual ~ResOpenRoomReplaceRecord_List();

  ResOpenRoomReplaceRecord_List(const ResOpenRoomReplaceRecord_List& from);

  inline ResOpenRoomReplaceRecord_List& operator=(const ResOpenRoomReplaceRecord_List& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResOpenRoomReplaceRecord_List& default_instance();

  void Swap(ResOpenRoomReplaceRecord_List* other);

  // implements Message ----------------------------------------------

  ResOpenRoomReplaceRecord_List* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResOpenRoomReplaceRecord_List& from);
  void MergeFrom(const ResOpenRoomReplaceRecord_List& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoNet.ResponseResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::ProtoNet::ResponseResult& result() const;
  inline ::ProtoNet::ResponseResult* mutable_result();
  inline ::ProtoNet::ResponseResult* release_result();
  inline void set_allocated_result(::ProtoNet::ResponseResult* result);

  // repeated .ProtoNet.OpenRoomReplaceRecordInfo infos = 2;
  inline int infos_size() const;
  inline void clear_infos();
  static const int kInfosFieldNumber = 2;
  inline const ::ProtoNet::OpenRoomReplaceRecordInfo& infos(int index) const;
  inline ::ProtoNet::OpenRoomReplaceRecordInfo* mutable_infos(int index);
  inline ::ProtoNet::OpenRoomReplaceRecordInfo* add_infos();
  inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::OpenRoomReplaceRecordInfo >&
      infos() const;
  inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::OpenRoomReplaceRecordInfo >*
      mutable_infos();

  // optional int32 daikaifangRecordNum = 3;
  inline bool has_daikaifangrecordnum() const;
  inline void clear_daikaifangrecordnum();
  static const int kDaikaifangRecordNumFieldNumber = 3;
  inline ::google::protobuf::int32 daikaifangrecordnum() const;
  inline void set_daikaifangrecordnum(::google::protobuf::int32 value);

  // optional int32 status = 4;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 4;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResOpenRoomReplaceRecord_List)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_daikaifangrecordnum();
  inline void clear_has_daikaifangrecordnum();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoNet::ResponseResult* result_;
  ::google::protobuf::RepeatedPtrField< ::ProtoNet::OpenRoomReplaceRecordInfo > infos_;
  ::google::protobuf::int32 daikaifangrecordnum_;
  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static ResOpenRoomReplaceRecord_List* default_instance_;
};
// -------------------------------------------------------------------

class ReqDissolutionOpenRoomReplace : public ::google::protobuf::Message {
 public:
  ReqDissolutionOpenRoomReplace();
  virtual ~ReqDissolutionOpenRoomReplace();

  ReqDissolutionOpenRoomReplace(const ReqDissolutionOpenRoomReplace& from);

  inline ReqDissolutionOpenRoomReplace& operator=(const ReqDissolutionOpenRoomReplace& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqDissolutionOpenRoomReplace& default_instance();

  void Swap(ReqDissolutionOpenRoomReplace* other);

  // implements Message ----------------------------------------------

  ReqDissolutionOpenRoomReplace* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqDissolutionOpenRoomReplace& from);
  void MergeFrom(const ReqDissolutionOpenRoomReplace& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string roomId = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 1;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const char* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  inline void set_allocated_roomid(::std::string* roomid);

  // @@protoc_insertion_point(class_scope:ProtoNet.ReqDissolutionOpenRoomReplace)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* roomid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static ReqDissolutionOpenRoomReplace* default_instance_;
};
// -------------------------------------------------------------------

class ResDissolutionOpenRoomReplace : public ::google::protobuf::Message {
 public:
  ResDissolutionOpenRoomReplace();
  virtual ~ResDissolutionOpenRoomReplace();

  ResDissolutionOpenRoomReplace(const ResDissolutionOpenRoomReplace& from);

  inline ResDissolutionOpenRoomReplace& operator=(const ResDissolutionOpenRoomReplace& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResDissolutionOpenRoomReplace& default_instance();

  void Swap(ResDissolutionOpenRoomReplace* other);

  // implements Message ----------------------------------------------

  ResDissolutionOpenRoomReplace* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResDissolutionOpenRoomReplace& from);
  void MergeFrom(const ResDissolutionOpenRoomReplace& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoNet.ResponseResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::ProtoNet::ResponseResult& result() const;
  inline ::ProtoNet::ResponseResult* mutable_result();
  inline ::ProtoNet::ResponseResult* release_result();
  inline void set_allocated_result(::ProtoNet::ResponseResult* result);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResDissolutionOpenRoomReplace)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoNet::ResponseResult* result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static ResDissolutionOpenRoomReplace* default_instance_;
};
// -------------------------------------------------------------------

class ReqGameRoomList : public ::google::protobuf::Message {
 public:
  ReqGameRoomList();
  virtual ~ReqGameRoomList();

  ReqGameRoomList(const ReqGameRoomList& from);

  inline ReqGameRoomList& operator=(const ReqGameRoomList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqGameRoomList& default_instance();

  void Swap(ReqGameRoomList* other);

  // implements Message ----------------------------------------------

  ReqGameRoomList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqGameRoomList& from);
  void MergeFrom(const ReqGameRoomList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);

  // required int32 timesType = 2;
  inline bool has_timestype() const;
  inline void clear_timestype();
  static const int kTimesTypeFieldNumber = 2;
  inline ::google::protobuf::int32 timestype() const;
  inline void set_timestype(::google::protobuf::int32 value);

  // required int32 fangkaJinbi = 3;
  inline bool has_fangkajinbi() const;
  inline void clear_fangkajinbi();
  static const int kFangkaJinbiFieldNumber = 3;
  inline ::google::protobuf::int32 fangkajinbi() const;
  inline void set_fangkajinbi(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ProtoNet.ReqGameRoomList)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_timestype();
  inline void clear_has_timestype();
  inline void set_has_fangkajinbi();
  inline void clear_has_fangkajinbi();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 timestype_;
  ::google::protobuf::int32 fangkajinbi_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static ReqGameRoomList* default_instance_;
};
// -------------------------------------------------------------------

class ResGameRoomList : public ::google::protobuf::Message {
 public:
  ResGameRoomList();
  virtual ~ResGameRoomList();

  ResGameRoomList(const ResGameRoomList& from);

  inline ResGameRoomList& operator=(const ResGameRoomList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResGameRoomList& default_instance();

  void Swap(ResGameRoomList* other);

  // implements Message ----------------------------------------------

  ResGameRoomList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResGameRoomList& from);
  void MergeFrom(const ResGameRoomList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoNet.ResponseResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::ProtoNet::ResponseResult& result() const;
  inline ::ProtoNet::ResponseResult* mutable_result();
  inline ::ProtoNet::ResponseResult* release_result();
  inline void set_allocated_result(::ProtoNet::ResponseResult* result);

  // repeated .ProtoNet.GameRoomList list = 2;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 2;
  inline const ::ProtoNet::GameRoomList& list(int index) const;
  inline ::ProtoNet::GameRoomList* mutable_list(int index);
  inline ::ProtoNet::GameRoomList* add_list();
  inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::GameRoomList >&
      list() const;
  inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::GameRoomList >*
      mutable_list();

  // @@protoc_insertion_point(class_scope:ProtoNet.ResGameRoomList)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoNet::ResponseResult* result_;
  ::google::protobuf::RepeatedPtrField< ::ProtoNet::GameRoomList > list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static ResGameRoomList* default_instance_;
};
// -------------------------------------------------------------------

class GameRoomList : public ::google::protobuf::Message {
 public:
  GameRoomList();
  virtual ~GameRoomList();

  GameRoomList(const GameRoomList& from);

  inline GameRoomList& operator=(const GameRoomList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameRoomList& default_instance();

  void Swap(GameRoomList* other);

  // implements Message ----------------------------------------------

  GameRoomList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameRoomList& from);
  void MergeFrom(const GameRoomList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string roomId = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 1;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const char* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  inline void set_allocated_roomid(::std::string* roomid);

  // required string paramString = 2;
  inline bool has_paramstring() const;
  inline void clear_paramstring();
  static const int kParamStringFieldNumber = 2;
  inline const ::std::string& paramstring() const;
  inline void set_paramstring(const ::std::string& value);
  inline void set_paramstring(const char* value);
  inline void set_paramstring(const char* value, size_t size);
  inline ::std::string* mutable_paramstring();
  inline ::std::string* release_paramstring();
  inline void set_allocated_paramstring(::std::string* paramstring);

  // required double yazhu = 3;
  inline bool has_yazhu() const;
  inline void clear_yazhu();
  static const int kYazhuFieldNumber = 3;
  inline double yazhu() const;
  inline void set_yazhu(double value);

  // required int32 halfWayJoin = 4;
  inline bool has_halfwayjoin() const;
  inline void clear_halfwayjoin();
  static const int kHalfWayJoinFieldNumber = 4;
  inline ::google::protobuf::int32 halfwayjoin() const;
  inline void set_halfwayjoin(::google::protobuf::int32 value);

  // required int32 maxPlayerNum = 5;
  inline bool has_maxplayernum() const;
  inline void clear_maxplayernum();
  static const int kMaxPlayerNumFieldNumber = 5;
  inline ::google::protobuf::int32 maxplayernum() const;
  inline void set_maxplayernum(::google::protobuf::int32 value);

  // required int32 fangkaJinbi = 6;
  inline bool has_fangkajinbi() const;
  inline void clear_fangkajinbi();
  static const int kFangkaJinbiFieldNumber = 6;
  inline ::google::protobuf::int32 fangkajinbi() const;
  inline void set_fangkajinbi(::google::protobuf::int32 value);

  // required double minNeed = 7;
  inline bool has_minneed() const;
  inline void clear_minneed();
  static const int kMinNeedFieldNumber = 7;
  inline double minneed() const;
  inline void set_minneed(double value);

  // required string pipeiParam = 8;
  inline bool has_pipeiparam() const;
  inline void clear_pipeiparam();
  static const int kPipeiParamFieldNumber = 8;
  inline const ::std::string& pipeiparam() const;
  inline void set_pipeiparam(const ::std::string& value);
  inline void set_pipeiparam(const char* value);
  inline void set_pipeiparam(const char* value, size_t size);
  inline ::std::string* mutable_pipeiparam();
  inline ::std::string* release_pipeiparam();
  inline void set_allocated_pipeiparam(::std::string* pipeiparam);

  // required .ProtoNet.ServerInfoIpsSafeDetail serverInfo = 9;
  inline bool has_serverinfo() const;
  inline void clear_serverinfo();
  static const int kServerInfoFieldNumber = 9;
  inline const ::ProtoNet::ServerInfoIpsSafeDetail& serverinfo() const;
  inline ::ProtoNet::ServerInfoIpsSafeDetail* mutable_serverinfo();
  inline ::ProtoNet::ServerInfoIpsSafeDetail* release_serverinfo();
  inline void set_allocated_serverinfo(::ProtoNet::ServerInfoIpsSafeDetail* serverinfo);

  // required int32 gameId = 10;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 10;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);

  // required int32 currentPlayerNum = 11;
  inline bool has_currentplayernum() const;
  inline void clear_currentplayernum();
  static const int kCurrentPlayerNumFieldNumber = 11;
  inline ::google::protobuf::int32 currentplayernum() const;
  inline void set_currentplayernum(::google::protobuf::int32 value);

  // required int32 roomStatus = 12;
  inline bool has_roomstatus() const;
  inline void clear_roomstatus();
  static const int kRoomStatusFieldNumber = 12;
  inline ::google::protobuf::int32 roomstatus() const;
  inline void set_roomstatus(::google::protobuf::int32 value);

  // required int32 currentWatchPlayerNum = 13;
  inline bool has_currentwatchplayernum() const;
  inline void clear_currentwatchplayernum();
  static const int kCurrentWatchPlayerNumFieldNumber = 13;
  inline ::google::protobuf::int32 currentwatchplayernum() const;
  inline void set_currentwatchplayernum(::google::protobuf::int32 value);

  // optional int32 roomType = 14;
  inline bool has_roomtype() const;
  inline void clear_roomtype();
  static const int kRoomTypeFieldNumber = 14;
  inline ::google::protobuf::int32 roomtype() const;
  inline void set_roomtype(::google::protobuf::int32 value);

  // optional int32 timesType = 15;
  inline bool has_timestype() const;
  inline void clear_timestype();
  static const int kTimesTypeFieldNumber = 15;
  inline ::google::protobuf::int32 timestype() const;
  inline void set_timestype(::google::protobuf::int32 value);

  // repeated .ProtoNet.RoomRoleInfo roomRoleInfo = 16;
  inline int roomroleinfo_size() const;
  inline void clear_roomroleinfo();
  static const int kRoomRoleInfoFieldNumber = 16;
  inline const ::ProtoNet::RoomRoleInfo& roomroleinfo(int index) const;
  inline ::ProtoNet::RoomRoleInfo* mutable_roomroleinfo(int index);
  inline ::ProtoNet::RoomRoleInfo* add_roomroleinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::RoomRoleInfo >&
      roomroleinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::RoomRoleInfo >*
      mutable_roomroleinfo();

  // optional string tableNum = 17;
  inline bool has_tablenum() const;
  inline void clear_tablenum();
  static const int kTableNumFieldNumber = 17;
  inline const ::std::string& tablenum() const;
  inline void set_tablenum(const ::std::string& value);
  inline void set_tablenum(const char* value);
  inline void set_tablenum(const char* value, size_t size);
  inline ::std::string* mutable_tablenum();
  inline ::std::string* release_tablenum();
  inline void set_allocated_tablenum(::std::string* tablenum);

  // @@protoc_insertion_point(class_scope:ProtoNet.GameRoomList)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_paramstring();
  inline void clear_has_paramstring();
  inline void set_has_yazhu();
  inline void clear_has_yazhu();
  inline void set_has_halfwayjoin();
  inline void clear_has_halfwayjoin();
  inline void set_has_maxplayernum();
  inline void clear_has_maxplayernum();
  inline void set_has_fangkajinbi();
  inline void clear_has_fangkajinbi();
  inline void set_has_minneed();
  inline void clear_has_minneed();
  inline void set_has_pipeiparam();
  inline void clear_has_pipeiparam();
  inline void set_has_serverinfo();
  inline void clear_has_serverinfo();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_currentplayernum();
  inline void clear_has_currentplayernum();
  inline void set_has_roomstatus();
  inline void clear_has_roomstatus();
  inline void set_has_currentwatchplayernum();
  inline void clear_has_currentwatchplayernum();
  inline void set_has_roomtype();
  inline void clear_has_roomtype();
  inline void set_has_timestype();
  inline void clear_has_timestype();
  inline void set_has_tablenum();
  inline void clear_has_tablenum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* roomid_;
  ::std::string* paramstring_;
  double yazhu_;
  ::google::protobuf::int32 halfwayjoin_;
  ::google::protobuf::int32 maxplayernum_;
  double minneed_;
  ::std::string* pipeiparam_;
  ::google::protobuf::int32 fangkajinbi_;
  ::google::protobuf::int32 gameid_;
  ::ProtoNet::ServerInfoIpsSafeDetail* serverinfo_;
  ::google::protobuf::int32 currentplayernum_;
  ::google::protobuf::int32 roomstatus_;
  ::google::protobuf::int32 currentwatchplayernum_;
  ::google::protobuf::int32 roomtype_;
  ::google::protobuf::RepeatedPtrField< ::ProtoNet::RoomRoleInfo > roomroleinfo_;
  ::std::string* tablenum_;
  ::google::protobuf::int32 timestype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static GameRoomList* default_instance_;
};
// -------------------------------------------------------------------

class ReqClubGameRoomList : public ::google::protobuf::Message {
 public:
  ReqClubGameRoomList();
  virtual ~ReqClubGameRoomList();

  ReqClubGameRoomList(const ReqClubGameRoomList& from);

  inline ReqClubGameRoomList& operator=(const ReqClubGameRoomList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqClubGameRoomList& default_instance();

  void Swap(ReqClubGameRoomList* other);

  // implements Message ----------------------------------------------

  ReqClubGameRoomList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqClubGameRoomList& from);
  void MergeFrom(const ReqClubGameRoomList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 roomType = 1;
  inline bool has_roomtype() const;
  inline void clear_roomtype();
  static const int kRoomTypeFieldNumber = 1;
  inline ::google::protobuf::int32 roomtype() const;
  inline void set_roomtype(::google::protobuf::int32 value);

  // required int32 gameId = 2;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 2;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);

  // required string clubId = 3;
  inline bool has_clubid() const;
  inline void clear_clubid();
  static const int kClubIdFieldNumber = 3;
  inline const ::std::string& clubid() const;
  inline void set_clubid(const ::std::string& value);
  inline void set_clubid(const char* value);
  inline void set_clubid(const char* value, size_t size);
  inline ::std::string* mutable_clubid();
  inline ::std::string* release_clubid();
  inline void set_allocated_clubid(::std::string* clubid);

  // required string clubPipeiParam = 4;
  inline bool has_clubpipeiparam() const;
  inline void clear_clubpipeiparam();
  static const int kClubPipeiParamFieldNumber = 4;
  inline const ::std::string& clubpipeiparam() const;
  inline void set_clubpipeiparam(const ::std::string& value);
  inline void set_clubpipeiparam(const char* value);
  inline void set_clubpipeiparam(const char* value, size_t size);
  inline ::std::string* mutable_clubpipeiparam();
  inline ::std::string* release_clubpipeiparam();
  inline void set_allocated_clubpipeiparam(::std::string* clubpipeiparam);

  // optional string clubGameTypeId = 5;
  inline bool has_clubgametypeid() const;
  inline void clear_clubgametypeid();
  static const int kClubGameTypeIdFieldNumber = 5;
  inline const ::std::string& clubgametypeid() const;
  inline void set_clubgametypeid(const ::std::string& value);
  inline void set_clubgametypeid(const char* value);
  inline void set_clubgametypeid(const char* value, size_t size);
  inline ::std::string* mutable_clubgametypeid();
  inline ::std::string* release_clubgametypeid();
  inline void set_allocated_clubgametypeid(::std::string* clubgametypeid);

  // @@protoc_insertion_point(class_scope:ProtoNet.ReqClubGameRoomList)
 private:
  inline void set_has_roomtype();
  inline void clear_has_roomtype();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_clubid();
  inline void clear_has_clubid();
  inline void set_has_clubpipeiparam();
  inline void clear_has_clubpipeiparam();
  inline void set_has_clubgametypeid();
  inline void clear_has_clubgametypeid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 roomtype_;
  ::google::protobuf::int32 gameid_;
  ::std::string* clubid_;
  ::std::string* clubpipeiparam_;
  ::std::string* clubgametypeid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static ReqClubGameRoomList* default_instance_;
};
// -------------------------------------------------------------------

class ResClubGameRoomList : public ::google::protobuf::Message {
 public:
  ResClubGameRoomList();
  virtual ~ResClubGameRoomList();

  ResClubGameRoomList(const ResClubGameRoomList& from);

  inline ResClubGameRoomList& operator=(const ResClubGameRoomList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResClubGameRoomList& default_instance();

  void Swap(ResClubGameRoomList* other);

  // implements Message ----------------------------------------------

  ResClubGameRoomList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResClubGameRoomList& from);
  void MergeFrom(const ResClubGameRoomList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoNet.ResponseResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::ProtoNet::ResponseResult& result() const;
  inline ::ProtoNet::ResponseResult* mutable_result();
  inline ::ProtoNet::ResponseResult* release_result();
  inline void set_allocated_result(::ProtoNet::ResponseResult* result);

  // repeated .ProtoNet.ClubGameRoomList list = 2;
  inline int list_size() const;
  inline void clear_list();
  static const int kListFieldNumber = 2;
  inline const ::ProtoNet::ClubGameRoomList& list(int index) const;
  inline ::ProtoNet::ClubGameRoomList* mutable_list(int index);
  inline ::ProtoNet::ClubGameRoomList* add_list();
  inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::ClubGameRoomList >&
      list() const;
  inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::ClubGameRoomList >*
      mutable_list();

  // optional int32 clubCurNum = 3;
  inline bool has_clubcurnum() const;
  inline void clear_clubcurnum();
  static const int kClubCurNumFieldNumber = 3;
  inline ::google::protobuf::int32 clubcurnum() const;
  inline void set_clubcurnum(::google::protobuf::int32 value);

  // optional int32 clubTotalNumLimit = 4;
  inline bool has_clubtotalnumlimit() const;
  inline void clear_clubtotalnumlimit();
  static const int kClubTotalNumLimitFieldNumber = 4;
  inline ::google::protobuf::int32 clubtotalnumlimit() const;
  inline void set_clubtotalnumlimit(::google::protobuf::int32 value);

  // optional int32 onlineTotal = 5;
  inline bool has_onlinetotal() const;
  inline void clear_onlinetotal();
  static const int kOnlineTotalFieldNumber = 5;
  inline ::google::protobuf::int32 onlinetotal() const;
  inline void set_onlinetotal(::google::protobuf::int32 value);

  // optional string clubId = 6;
  inline bool has_clubid() const;
  inline void clear_clubid();
  static const int kClubIdFieldNumber = 6;
  inline const ::std::string& clubid() const;
  inline void set_clubid(const ::std::string& value);
  inline void set_clubid(const char* value);
  inline void set_clubid(const char* value, size_t size);
  inline ::std::string* mutable_clubid();
  inline ::std::string* release_clubid();
  inline void set_allocated_clubid(::std::string* clubid);

  // optional int32 totalCard = 7;
  inline bool has_totalcard() const;
  inline void clear_totalcard();
  static const int kTotalCardFieldNumber = 7;
  inline ::google::protobuf::int32 totalcard() const;
  inline void set_totalcard(::google::protobuf::int32 value);

  // optional string intro = 8;
  inline bool has_intro() const;
  inline void clear_intro();
  static const int kIntroFieldNumber = 8;
  inline const ::std::string& intro() const;
  inline void set_intro(const ::std::string& value);
  inline void set_intro(const char* value);
  inline void set_intro(const char* value, size_t size);
  inline ::std::string* mutable_intro();
  inline ::std::string* release_intro();
  inline void set_allocated_intro(::std::string* intro);

  // optional int32 playingNum = 9;
  inline bool has_playingnum() const;
  inline void clear_playingnum();
  static const int kPlayingNumFieldNumber = 9;
  inline ::google::protobuf::int32 playingnum() const;
  inline void set_playingnum(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResClubGameRoomList)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_clubcurnum();
  inline void clear_has_clubcurnum();
  inline void set_has_clubtotalnumlimit();
  inline void clear_has_clubtotalnumlimit();
  inline void set_has_onlinetotal();
  inline void clear_has_onlinetotal();
  inline void set_has_clubid();
  inline void clear_has_clubid();
  inline void set_has_totalcard();
  inline void clear_has_totalcard();
  inline void set_has_intro();
  inline void clear_has_intro();
  inline void set_has_playingnum();
  inline void clear_has_playingnum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoNet::ResponseResult* result_;
  ::google::protobuf::RepeatedPtrField< ::ProtoNet::ClubGameRoomList > list_;
  ::google::protobuf::int32 clubcurnum_;
  ::google::protobuf::int32 clubtotalnumlimit_;
  ::std::string* clubid_;
  ::google::protobuf::int32 onlinetotal_;
  ::google::protobuf::int32 totalcard_;
  ::std::string* intro_;
  ::google::protobuf::int32 playingnum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static ResClubGameRoomList* default_instance_;
};
// -------------------------------------------------------------------

class ClubGameRoomList : public ::google::protobuf::Message {
 public:
  ClubGameRoomList();
  virtual ~ClubGameRoomList();

  ClubGameRoomList(const ClubGameRoomList& from);

  inline ClubGameRoomList& operator=(const ClubGameRoomList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClubGameRoomList& default_instance();

  void Swap(ClubGameRoomList* other);

  // implements Message ----------------------------------------------

  ClubGameRoomList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClubGameRoomList& from);
  void MergeFrom(const ClubGameRoomList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string roomId = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 1;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const char* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  inline void set_allocated_roomid(::std::string* roomid);

  // required string paramString = 2;
  inline bool has_paramstring() const;
  inline void clear_paramstring();
  static const int kParamStringFieldNumber = 2;
  inline const ::std::string& paramstring() const;
  inline void set_paramstring(const ::std::string& value);
  inline void set_paramstring(const char* value);
  inline void set_paramstring(const char* value, size_t size);
  inline ::std::string* mutable_paramstring();
  inline ::std::string* release_paramstring();
  inline void set_allocated_paramstring(::std::string* paramstring);

  // required double yazhu = 3;
  inline bool has_yazhu() const;
  inline void clear_yazhu();
  static const int kYazhuFieldNumber = 3;
  inline double yazhu() const;
  inline void set_yazhu(double value);

  // required int32 halfWayJoin = 4;
  inline bool has_halfwayjoin() const;
  inline void clear_halfwayjoin();
  static const int kHalfWayJoinFieldNumber = 4;
  inline ::google::protobuf::int32 halfwayjoin() const;
  inline void set_halfwayjoin(::google::protobuf::int32 value);

  // required int32 maxPlayerNum = 5;
  inline bool has_maxplayernum() const;
  inline void clear_maxplayernum();
  static const int kMaxPlayerNumFieldNumber = 5;
  inline ::google::protobuf::int32 maxplayernum() const;
  inline void set_maxplayernum(::google::protobuf::int32 value);

  // required int32 fangkaJinbi = 6;
  inline bool has_fangkajinbi() const;
  inline void clear_fangkajinbi();
  static const int kFangkaJinbiFieldNumber = 6;
  inline ::google::protobuf::int32 fangkajinbi() const;
  inline void set_fangkajinbi(::google::protobuf::int32 value);

  // required double minNeed = 7;
  inline bool has_minneed() const;
  inline void clear_minneed();
  static const int kMinNeedFieldNumber = 7;
  inline double minneed() const;
  inline void set_minneed(double value);

  // required string pipeiParam = 8;
  inline bool has_pipeiparam() const;
  inline void clear_pipeiparam();
  static const int kPipeiParamFieldNumber = 8;
  inline const ::std::string& pipeiparam() const;
  inline void set_pipeiparam(const ::std::string& value);
  inline void set_pipeiparam(const char* value);
  inline void set_pipeiparam(const char* value, size_t size);
  inline ::std::string* mutable_pipeiparam();
  inline ::std::string* release_pipeiparam();
  inline void set_allocated_pipeiparam(::std::string* pipeiparam);

  // required .ProtoNet.ServerInfoIpsSafeDetail serverInfo = 9;
  inline bool has_serverinfo() const;
  inline void clear_serverinfo();
  static const int kServerInfoFieldNumber = 9;
  inline const ::ProtoNet::ServerInfoIpsSafeDetail& serverinfo() const;
  inline ::ProtoNet::ServerInfoIpsSafeDetail* mutable_serverinfo();
  inline ::ProtoNet::ServerInfoIpsSafeDetail* release_serverinfo();
  inline void set_allocated_serverinfo(::ProtoNet::ServerInfoIpsSafeDetail* serverinfo);

  // required int32 gameId = 10;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 10;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);

  // required int32 currentPlayerNum = 11;
  inline bool has_currentplayernum() const;
  inline void clear_currentplayernum();
  static const int kCurrentPlayerNumFieldNumber = 11;
  inline ::google::protobuf::int32 currentplayernum() const;
  inline void set_currentplayernum(::google::protobuf::int32 value);

  // required int32 roomStatus = 12;
  inline bool has_roomstatus() const;
  inline void clear_roomstatus();
  static const int kRoomStatusFieldNumber = 12;
  inline ::google::protobuf::int32 roomstatus() const;
  inline void set_roomstatus(::google::protobuf::int32 value);

  // required int32 currentWatchPlayerNum = 13;
  inline bool has_currentwatchplayernum() const;
  inline void clear_currentwatchplayernum();
  static const int kCurrentWatchPlayerNumFieldNumber = 13;
  inline ::google::protobuf::int32 currentwatchplayernum() const;
  inline void set_currentwatchplayernum(::google::protobuf::int32 value);

  // required int32 roomType = 14;
  inline bool has_roomtype() const;
  inline void clear_roomtype();
  static const int kRoomTypeFieldNumber = 14;
  inline ::google::protobuf::int32 roomtype() const;
  inline void set_roomtype(::google::protobuf::int32 value);

  // required int32 timesType = 15;
  inline bool has_timestype() const;
  inline void clear_timestype();
  static const int kTimesTypeFieldNumber = 15;
  inline ::google::protobuf::int32 timestype() const;
  inline void set_timestype(::google::protobuf::int32 value);

  // optional string tableNum = 16;
  inline bool has_tablenum() const;
  inline void clear_tablenum();
  static const int kTableNumFieldNumber = 16;
  inline const ::std::string& tablenum() const;
  inline void set_tablenum(const ::std::string& value);
  inline void set_tablenum(const char* value);
  inline void set_tablenum(const char* value, size_t size);
  inline ::std::string* mutable_tablenum();
  inline ::std::string* release_tablenum();
  inline void set_allocated_tablenum(::std::string* tablenum);

  // repeated .ProtoNet.RoomRoleInfo roomRoleInfo = 17;
  inline int roomroleinfo_size() const;
  inline void clear_roomroleinfo();
  static const int kRoomRoleInfoFieldNumber = 17;
  inline const ::ProtoNet::RoomRoleInfo& roomroleinfo(int index) const;
  inline ::ProtoNet::RoomRoleInfo* mutable_roomroleinfo(int index);
  inline ::ProtoNet::RoomRoleInfo* add_roomroleinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::RoomRoleInfo >&
      roomroleinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::RoomRoleInfo >*
      mutable_roomroleinfo();

  // optional string roomerUniqueId = 18;
  inline bool has_roomeruniqueid() const;
  inline void clear_roomeruniqueid();
  static const int kRoomerUniqueIdFieldNumber = 18;
  inline const ::std::string& roomeruniqueid() const;
  inline void set_roomeruniqueid(const ::std::string& value);
  inline void set_roomeruniqueid(const char* value);
  inline void set_roomeruniqueid(const char* value, size_t size);
  inline ::std::string* mutable_roomeruniqueid();
  inline ::std::string* release_roomeruniqueid();
  inline void set_allocated_roomeruniqueid(::std::string* roomeruniqueid);

  // @@protoc_insertion_point(class_scope:ProtoNet.ClubGameRoomList)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_paramstring();
  inline void clear_has_paramstring();
  inline void set_has_yazhu();
  inline void clear_has_yazhu();
  inline void set_has_halfwayjoin();
  inline void clear_has_halfwayjoin();
  inline void set_has_maxplayernum();
  inline void clear_has_maxplayernum();
  inline void set_has_fangkajinbi();
  inline void clear_has_fangkajinbi();
  inline void set_has_minneed();
  inline void clear_has_minneed();
  inline void set_has_pipeiparam();
  inline void clear_has_pipeiparam();
  inline void set_has_serverinfo();
  inline void clear_has_serverinfo();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_currentplayernum();
  inline void clear_has_currentplayernum();
  inline void set_has_roomstatus();
  inline void clear_has_roomstatus();
  inline void set_has_currentwatchplayernum();
  inline void clear_has_currentwatchplayernum();
  inline void set_has_roomtype();
  inline void clear_has_roomtype();
  inline void set_has_timestype();
  inline void clear_has_timestype();
  inline void set_has_tablenum();
  inline void clear_has_tablenum();
  inline void set_has_roomeruniqueid();
  inline void clear_has_roomeruniqueid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* roomid_;
  ::std::string* paramstring_;
  double yazhu_;
  ::google::protobuf::int32 halfwayjoin_;
  ::google::protobuf::int32 maxplayernum_;
  double minneed_;
  ::std::string* pipeiparam_;
  ::google::protobuf::int32 fangkajinbi_;
  ::google::protobuf::int32 gameid_;
  ::ProtoNet::ServerInfoIpsSafeDetail* serverinfo_;
  ::google::protobuf::int32 currentplayernum_;
  ::google::protobuf::int32 roomstatus_;
  ::google::protobuf::int32 currentwatchplayernum_;
  ::google::protobuf::int32 roomtype_;
  ::std::string* tablenum_;
  ::google::protobuf::RepeatedPtrField< ::ProtoNet::RoomRoleInfo > roomroleinfo_;
  ::std::string* roomeruniqueid_;
  ::google::protobuf::int32 timestype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(18 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static ClubGameRoomList* default_instance_;
};
// -------------------------------------------------------------------

class RoomRoleInfo : public ::google::protobuf::Message {
 public:
  RoomRoleInfo();
  virtual ~RoomRoleInfo();

  RoomRoleInfo(const RoomRoleInfo& from);

  inline RoomRoleInfo& operator=(const RoomRoleInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomRoleInfo& default_instance();

  void Swap(RoomRoleInfo* other);

  // implements Message ----------------------------------------------

  RoomRoleInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomRoleInfo& from);
  void MergeFrom(const RoomRoleInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string uniqueId = 1;
  inline bool has_uniqueid() const;
  inline void clear_uniqueid();
  static const int kUniqueIdFieldNumber = 1;
  inline const ::std::string& uniqueid() const;
  inline void set_uniqueid(const ::std::string& value);
  inline void set_uniqueid(const char* value);
  inline void set_uniqueid(const char* value, size_t size);
  inline ::std::string* mutable_uniqueid();
  inline ::std::string* release_uniqueid();
  inline void set_allocated_uniqueid(::std::string* uniqueid);

  // required string nickName = 2;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNickNameFieldNumber = 2;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // required string headImg = 3;
  inline bool has_headimg() const;
  inline void clear_headimg();
  static const int kHeadImgFieldNumber = 3;
  inline const ::std::string& headimg() const;
  inline void set_headimg(const ::std::string& value);
  inline void set_headimg(const char* value);
  inline void set_headimg(const char* value, size_t size);
  inline ::std::string* mutable_headimg();
  inline ::std::string* release_headimg();
  inline void set_allocated_headimg(::std::string* headimg);

  // required int32 head = 4;
  inline bool has_head() const;
  inline void clear_head();
  static const int kHeadFieldNumber = 4;
  inline ::google::protobuf::int32 head() const;
  inline void set_head(::google::protobuf::int32 value);

  // required int32 pos = 5;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 5;
  inline ::google::protobuf::int32 pos() const;
  inline void set_pos(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ProtoNet.RoomRoleInfo)
 private:
  inline void set_has_uniqueid();
  inline void clear_has_uniqueid();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_headimg();
  inline void clear_has_headimg();
  inline void set_has_head();
  inline void clear_has_head();
  inline void set_has_pos();
  inline void clear_has_pos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uniqueid_;
  ::std::string* nickname_;
  ::std::string* headimg_;
  ::google::protobuf::int32 head_;
  ::google::protobuf::int32 pos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static RoomRoleInfo* default_instance_;
};
// -------------------------------------------------------------------

class ReqClubPipeiRoom : public ::google::protobuf::Message {
 public:
  ReqClubPipeiRoom();
  virtual ~ReqClubPipeiRoom();

  ReqClubPipeiRoom(const ReqClubPipeiRoom& from);

  inline ReqClubPipeiRoom& operator=(const ReqClubPipeiRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqClubPipeiRoom& default_instance();

  void Swap(ReqClubPipeiRoom* other);

  // implements Message ----------------------------------------------

  ReqClubPipeiRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqClubPipeiRoom& from);
  void MergeFrom(const ReqClubPipeiRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 roomType = 1;
  inline bool has_roomtype() const;
  inline void clear_roomtype();
  static const int kRoomTypeFieldNumber = 1;
  inline ::google::protobuf::int32 roomtype() const;
  inline void set_roomtype(::google::protobuf::int32 value);

  // optional int32 times = 2;
  inline bool has_times() const;
  inline void clear_times();
  static const int kTimesFieldNumber = 2;
  inline ::google::protobuf::int32 times() const;
  inline void set_times(::google::protobuf::int32 value);

  // optional string paramString = 3;
  inline bool has_paramstring() const;
  inline void clear_paramstring();
  static const int kParamStringFieldNumber = 3;
  inline const ::std::string& paramstring() const;
  inline void set_paramstring(const ::std::string& value);
  inline void set_paramstring(const char* value);
  inline void set_paramstring(const char* value, size_t size);
  inline ::std::string* mutable_paramstring();
  inline ::std::string* release_paramstring();
  inline void set_allocated_paramstring(::std::string* paramstring);

  // optional int32 timesType = 4;
  inline bool has_timestype() const;
  inline void clear_timestype();
  static const int kTimesTypeFieldNumber = 4;
  inline ::google::protobuf::int32 timestype() const;
  inline void set_timestype(::google::protobuf::int32 value);

  // optional int32 halfWayJoin = 5;
  inline bool has_halfwayjoin() const;
  inline void clear_halfwayjoin();
  static const int kHalfWayJoinFieldNumber = 5;
  inline ::google::protobuf::int32 halfwayjoin() const;
  inline void set_halfwayjoin(::google::protobuf::int32 value);

  // optional int32 maxPlayerNum = 6;
  inline bool has_maxplayernum() const;
  inline void clear_maxplayernum();
  static const int kMaxPlayerNumFieldNumber = 6;
  inline ::google::protobuf::int32 maxplayernum() const;
  inline void set_maxplayernum(::google::protobuf::int32 value);

  // optional double yazhu = 7;
  inline bool has_yazhu() const;
  inline void clear_yazhu();
  static const int kYazhuFieldNumber = 7;
  inline double yazhu() const;
  inline void set_yazhu(double value);

  // optional int32 gameId = 8;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 8;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);

  // optional int32 clubId = 9;
  inline bool has_clubid() const;
  inline void clear_clubid();
  static const int kClubIdFieldNumber = 9;
  inline ::google::protobuf::int32 clubid() const;
  inline void set_clubid(::google::protobuf::int32 value);

  // optional int32 playerId = 10;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 10;
  inline ::google::protobuf::int32 playerid() const;
  inline void set_playerid(::google::protobuf::int32 value);

  // optional int32 payType = 11;
  inline bool has_paytype() const;
  inline void clear_paytype();
  static const int kPayTypeFieldNumber = 11;
  inline ::google::protobuf::int32 paytype() const;
  inline void set_paytype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ProtoNet.ReqClubPipeiRoom)
 private:
  inline void set_has_roomtype();
  inline void clear_has_roomtype();
  inline void set_has_times();
  inline void clear_has_times();
  inline void set_has_paramstring();
  inline void clear_has_paramstring();
  inline void set_has_timestype();
  inline void clear_has_timestype();
  inline void set_has_halfwayjoin();
  inline void clear_has_halfwayjoin();
  inline void set_has_maxplayernum();
  inline void clear_has_maxplayernum();
  inline void set_has_yazhu();
  inline void clear_has_yazhu();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_clubid();
  inline void clear_has_clubid();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_paytype();
  inline void clear_has_paytype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 roomtype_;
  ::google::protobuf::int32 times_;
  ::std::string* paramstring_;
  ::google::protobuf::int32 timestype_;
  ::google::protobuf::int32 halfwayjoin_;
  double yazhu_;
  ::google::protobuf::int32 maxplayernum_;
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 clubid_;
  ::google::protobuf::int32 playerid_;
  ::google::protobuf::int32 paytype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static ReqClubPipeiRoom* default_instance_;
};
// -------------------------------------------------------------------

class ResClubPipeiRoom : public ::google::protobuf::Message {
 public:
  ResClubPipeiRoom();
  virtual ~ResClubPipeiRoom();

  ResClubPipeiRoom(const ResClubPipeiRoom& from);

  inline ResClubPipeiRoom& operator=(const ResClubPipeiRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResClubPipeiRoom& default_instance();

  void Swap(ResClubPipeiRoom* other);

  // implements Message ----------------------------------------------

  ResClubPipeiRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResClubPipeiRoom& from);
  void MergeFrom(const ResClubPipeiRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoNet.ResponseResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::ProtoNet::ResponseResult& result() const;
  inline ::ProtoNet::ResponseResult* mutable_result();
  inline ::ProtoNet::ResponseResult* release_result();
  inline void set_allocated_result(::ProtoNet::ResponseResult* result);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResClubPipeiRoom)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoNet::ResponseResult* result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static ResClubPipeiRoom* default_instance_;
};
// -------------------------------------------------------------------

class ReqExitClubPipeiRoom : public ::google::protobuf::Message {
 public:
  ReqExitClubPipeiRoom();
  virtual ~ReqExitClubPipeiRoom();

  ReqExitClubPipeiRoom(const ReqExitClubPipeiRoom& from);

  inline ReqExitClubPipeiRoom& operator=(const ReqExitClubPipeiRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqExitClubPipeiRoom& default_instance();

  void Swap(ReqExitClubPipeiRoom* other);

  // implements Message ----------------------------------------------

  ReqExitClubPipeiRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqExitClubPipeiRoom& from);
  void MergeFrom(const ReqExitClubPipeiRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ProtoNet.ReqExitClubPipeiRoom)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static ReqExitClubPipeiRoom* default_instance_;
};
// -------------------------------------------------------------------

class ResExitClubPipeiRoom : public ::google::protobuf::Message {
 public:
  ResExitClubPipeiRoom();
  virtual ~ResExitClubPipeiRoom();

  ResExitClubPipeiRoom(const ResExitClubPipeiRoom& from);

  inline ResExitClubPipeiRoom& operator=(const ResExitClubPipeiRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResExitClubPipeiRoom& default_instance();

  void Swap(ResExitClubPipeiRoom* other);

  // implements Message ----------------------------------------------

  ResExitClubPipeiRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResExitClubPipeiRoom& from);
  void MergeFrom(const ResExitClubPipeiRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoNet.ResponseResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::ProtoNet::ResponseResult& result() const;
  inline ::ProtoNet::ResponseResult* mutable_result();
  inline ::ProtoNet::ResponseResult* release_result();
  inline void set_allocated_result(::ProtoNet::ResponseResult* result);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResExitClubPipeiRoom)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoNet::ResponseResult* result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static ResExitClubPipeiRoom* default_instance_;
};
// -------------------------------------------------------------------

class ReqClubPipeiRoomStatus : public ::google::protobuf::Message {
 public:
  ReqClubPipeiRoomStatus();
  virtual ~ReqClubPipeiRoomStatus();

  ReqClubPipeiRoomStatus(const ReqClubPipeiRoomStatus& from);

  inline ReqClubPipeiRoomStatus& operator=(const ReqClubPipeiRoomStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqClubPipeiRoomStatus& default_instance();

  void Swap(ReqClubPipeiRoomStatus* other);

  // implements Message ----------------------------------------------

  ReqClubPipeiRoomStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqClubPipeiRoomStatus& from);
  void MergeFrom(const ReqClubPipeiRoomStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ProtoNet.ReqClubPipeiRoomStatus)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static ReqClubPipeiRoomStatus* default_instance_;
};
// -------------------------------------------------------------------

class ResClubPipeiRoomStatus : public ::google::protobuf::Message {
 public:
  ResClubPipeiRoomStatus();
  virtual ~ResClubPipeiRoomStatus();

  ResClubPipeiRoomStatus(const ResClubPipeiRoomStatus& from);

  inline ResClubPipeiRoomStatus& operator=(const ResClubPipeiRoomStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResClubPipeiRoomStatus& default_instance();

  void Swap(ResClubPipeiRoomStatus* other);

  // implements Message ----------------------------------------------

  ResClubPipeiRoomStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResClubPipeiRoomStatus& from);
  void MergeFrom(const ResClubPipeiRoomStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoNet.ResponseResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::ProtoNet::ResponseResult& result() const;
  inline ::ProtoNet::ResponseResult* mutable_result();
  inline ::ProtoNet::ResponseResult* release_result();
  inline void set_allocated_result(::ProtoNet::ResponseResult* result);

  // optional int32 gameId = 2;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 2;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);

  // optional int32 clubId = 3;
  inline bool has_clubid() const;
  inline void clear_clubid();
  static const int kClubIdFieldNumber = 3;
  inline ::google::protobuf::int32 clubid() const;
  inline void set_clubid(::google::protobuf::int32 value);

  // optional int32 times = 4;
  inline bool has_times() const;
  inline void clear_times();
  static const int kTimesFieldNumber = 4;
  inline ::google::protobuf::int32 times() const;
  inline void set_times(::google::protobuf::int32 value);

  // optional string paramString = 5;
  inline bool has_paramstring() const;
  inline void clear_paramstring();
  static const int kParamStringFieldNumber = 5;
  inline const ::std::string& paramstring() const;
  inline void set_paramstring(const ::std::string& value);
  inline void set_paramstring(const char* value);
  inline void set_paramstring(const char* value, size_t size);
  inline ::std::string* mutable_paramstring();
  inline ::std::string* release_paramstring();
  inline void set_allocated_paramstring(::std::string* paramstring);

  // optional int32 maxPlayerNum = 6;
  inline bool has_maxplayernum() const;
  inline void clear_maxplayernum();
  static const int kMaxPlayerNumFieldNumber = 6;
  inline ::google::protobuf::int32 maxplayernum() const;
  inline void set_maxplayernum(::google::protobuf::int32 value);

  // optional int32 matchPlayerNum = 7;
  inline bool has_matchplayernum() const;
  inline void clear_matchplayernum();
  static const int kMatchPlayerNumFieldNumber = 7;
  inline ::google::protobuf::int32 matchplayernum() const;
  inline void set_matchplayernum(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResClubPipeiRoomStatus)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_clubid();
  inline void clear_has_clubid();
  inline void set_has_times();
  inline void clear_has_times();
  inline void set_has_paramstring();
  inline void clear_has_paramstring();
  inline void set_has_maxplayernum();
  inline void clear_has_maxplayernum();
  inline void set_has_matchplayernum();
  inline void clear_has_matchplayernum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoNet::ResponseResult* result_;
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 clubid_;
  ::std::string* paramstring_;
  ::google::protobuf::int32 times_;
  ::google::protobuf::int32 maxplayernum_;
  ::google::protobuf::int32 matchplayernum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static ResClubPipeiRoomStatus* default_instance_;
};
// -------------------------------------------------------------------

class ResNotifyClubPipeiSuc : public ::google::protobuf::Message {
 public:
  ResNotifyClubPipeiSuc();
  virtual ~ResNotifyClubPipeiSuc();

  ResNotifyClubPipeiSuc(const ResNotifyClubPipeiSuc& from);

  inline ResNotifyClubPipeiSuc& operator=(const ResNotifyClubPipeiSuc& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResNotifyClubPipeiSuc& default_instance();

  void Swap(ResNotifyClubPipeiSuc* other);

  // implements Message ----------------------------------------------

  ResNotifyClubPipeiSuc* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResNotifyClubPipeiSuc& from);
  void MergeFrom(const ResNotifyClubPipeiSuc& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string clubId = 1;
  inline bool has_clubid() const;
  inline void clear_clubid();
  static const int kClubIdFieldNumber = 1;
  inline const ::std::string& clubid() const;
  inline void set_clubid(const ::std::string& value);
  inline void set_clubid(const char* value);
  inline void set_clubid(const char* value, size_t size);
  inline ::std::string* mutable_clubid();
  inline ::std::string* release_clubid();
  inline void set_allocated_clubid(::std::string* clubid);

  // optional string roomId = 2;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 2;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const char* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  inline void set_allocated_roomid(::std::string* roomid);

  // optional int32 roomType = 3;
  inline bool has_roomtype() const;
  inline void clear_roomtype();
  static const int kRoomTypeFieldNumber = 3;
  inline ::google::protobuf::int32 roomtype() const;
  inline void set_roomtype(::google::protobuf::int32 value);

  // optional int32 times = 4;
  inline bool has_times() const;
  inline void clear_times();
  static const int kTimesFieldNumber = 4;
  inline ::google::protobuf::int32 times() const;
  inline void set_times(::google::protobuf::int32 value);

  // optional string paramString = 5;
  inline bool has_paramstring() const;
  inline void clear_paramstring();
  static const int kParamStringFieldNumber = 5;
  inline const ::std::string& paramstring() const;
  inline void set_paramstring(const ::std::string& value);
  inline void set_paramstring(const char* value);
  inline void set_paramstring(const char* value, size_t size);
  inline ::std::string* mutable_paramstring();
  inline ::std::string* release_paramstring();
  inline void set_allocated_paramstring(::std::string* paramstring);

  // optional int32 timesType = 6;
  inline bool has_timestype() const;
  inline void clear_timestype();
  static const int kTimesTypeFieldNumber = 6;
  inline ::google::protobuf::int32 timestype() const;
  inline void set_timestype(::google::protobuf::int32 value);

  // optional int32 halfWayJoin = 7;
  inline bool has_halfwayjoin() const;
  inline void clear_halfwayjoin();
  static const int kHalfWayJoinFieldNumber = 7;
  inline ::google::protobuf::int32 halfwayjoin() const;
  inline void set_halfwayjoin(::google::protobuf::int32 value);

  // optional int32 maxPlayerNum = 8;
  inline bool has_maxplayernum() const;
  inline void clear_maxplayernum();
  static const int kMaxPlayerNumFieldNumber = 8;
  inline ::google::protobuf::int32 maxplayernum() const;
  inline void set_maxplayernum(::google::protobuf::int32 value);

  // optional double yazhu = 9;
  inline bool has_yazhu() const;
  inline void clear_yazhu();
  static const int kYazhuFieldNumber = 9;
  inline double yazhu() const;
  inline void set_yazhu(double value);

  // optional int32 gameId = 10;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 10;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);

  // optional .ProtoNet.ServerInfoIpsSafeDetail serverInfo = 11;
  inline bool has_serverinfo() const;
  inline void clear_serverinfo();
  static const int kServerInfoFieldNumber = 11;
  inline const ::ProtoNet::ServerInfoIpsSafeDetail& serverinfo() const;
  inline ::ProtoNet::ServerInfoIpsSafeDetail* mutable_serverinfo();
  inline ::ProtoNet::ServerInfoIpsSafeDetail* release_serverinfo();
  inline void set_allocated_serverinfo(::ProtoNet::ServerInfoIpsSafeDetail* serverinfo);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResNotifyClubPipeiSuc)
 private:
  inline void set_has_clubid();
  inline void clear_has_clubid();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_roomtype();
  inline void clear_has_roomtype();
  inline void set_has_times();
  inline void clear_has_times();
  inline void set_has_paramstring();
  inline void clear_has_paramstring();
  inline void set_has_timestype();
  inline void clear_has_timestype();
  inline void set_has_halfwayjoin();
  inline void clear_has_halfwayjoin();
  inline void set_has_maxplayernum();
  inline void clear_has_maxplayernum();
  inline void set_has_yazhu();
  inline void clear_has_yazhu();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_serverinfo();
  inline void clear_has_serverinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* clubid_;
  ::std::string* roomid_;
  ::google::protobuf::int32 roomtype_;
  ::google::protobuf::int32 times_;
  ::std::string* paramstring_;
  ::google::protobuf::int32 timestype_;
  ::google::protobuf::int32 halfwayjoin_;
  double yazhu_;
  ::google::protobuf::int32 maxplayernum_;
  ::google::protobuf::int32 gameid_;
  ::ProtoNet::ServerInfoIpsSafeDetail* serverinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static ResNotifyClubPipeiSuc* default_instance_;
};
// -------------------------------------------------------------------

class ResNotifyRefreshClubGameRoomList : public ::google::protobuf::Message {
 public:
  ResNotifyRefreshClubGameRoomList();
  virtual ~ResNotifyRefreshClubGameRoomList();

  ResNotifyRefreshClubGameRoomList(const ResNotifyRefreshClubGameRoomList& from);

  inline ResNotifyRefreshClubGameRoomList& operator=(const ResNotifyRefreshClubGameRoomList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResNotifyRefreshClubGameRoomList& default_instance();

  void Swap(ResNotifyRefreshClubGameRoomList* other);

  // implements Message ----------------------------------------------

  ResNotifyRefreshClubGameRoomList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResNotifyRefreshClubGameRoomList& from);
  void MergeFrom(const ResNotifyRefreshClubGameRoomList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ProtoNet.ResNotifyRefreshClubGameRoomList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static ResNotifyRefreshClubGameRoomList* default_instance_;
};
// -------------------------------------------------------------------

class ResNotifyRefreshClubRedBotNews : public ::google::protobuf::Message {
 public:
  ResNotifyRefreshClubRedBotNews();
  virtual ~ResNotifyRefreshClubRedBotNews();

  ResNotifyRefreshClubRedBotNews(const ResNotifyRefreshClubRedBotNews& from);

  inline ResNotifyRefreshClubRedBotNews& operator=(const ResNotifyRefreshClubRedBotNews& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResNotifyRefreshClubRedBotNews& default_instance();

  void Swap(ResNotifyRefreshClubRedBotNews* other);

  // implements Message ----------------------------------------------

  ResNotifyRefreshClubRedBotNews* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResNotifyRefreshClubRedBotNews& from);
  void MergeFrom(const ResNotifyRefreshClubRedBotNews& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ProtoNet.ResNotifyRefreshClubRedBotNews)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static ResNotifyRefreshClubRedBotNews* default_instance_;
};
// -------------------------------------------------------------------

class ResNotifyClubDismiss : public ::google::protobuf::Message {
 public:
  ResNotifyClubDismiss();
  virtual ~ResNotifyClubDismiss();

  ResNotifyClubDismiss(const ResNotifyClubDismiss& from);

  inline ResNotifyClubDismiss& operator=(const ResNotifyClubDismiss& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResNotifyClubDismiss& default_instance();

  void Swap(ResNotifyClubDismiss* other);

  // implements Message ----------------------------------------------

  ResNotifyClubDismiss* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResNotifyClubDismiss& from);
  void MergeFrom(const ResNotifyClubDismiss& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string clubId = 1;
  inline bool has_clubid() const;
  inline void clear_clubid();
  static const int kClubIdFieldNumber = 1;
  inline const ::std::string& clubid() const;
  inline void set_clubid(const ::std::string& value);
  inline void set_clubid(const char* value);
  inline void set_clubid(const char* value, size_t size);
  inline ::std::string* mutable_clubid();
  inline ::std::string* release_clubid();
  inline void set_allocated_clubid(::std::string* clubid);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResNotifyClubDismiss)
 private:
  inline void set_has_clubid();
  inline void clear_has_clubid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* clubid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static ResNotifyClubDismiss* default_instance_;
};
// -------------------------------------------------------------------

class ResNotifyClubKickedOut : public ::google::protobuf::Message {
 public:
  ResNotifyClubKickedOut();
  virtual ~ResNotifyClubKickedOut();

  ResNotifyClubKickedOut(const ResNotifyClubKickedOut& from);

  inline ResNotifyClubKickedOut& operator=(const ResNotifyClubKickedOut& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResNotifyClubKickedOut& default_instance();

  void Swap(ResNotifyClubKickedOut* other);

  // implements Message ----------------------------------------------

  ResNotifyClubKickedOut* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResNotifyClubKickedOut& from);
  void MergeFrom(const ResNotifyClubKickedOut& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string clubId = 1;
  inline bool has_clubid() const;
  inline void clear_clubid();
  static const int kClubIdFieldNumber = 1;
  inline const ::std::string& clubid() const;
  inline void set_clubid(const ::std::string& value);
  inline void set_clubid(const char* value);
  inline void set_clubid(const char* value, size_t size);
  inline ::std::string* mutable_clubid();
  inline ::std::string* release_clubid();
  inline void set_allocated_clubid(::std::string* clubid);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResNotifyClubKickedOut)
 private:
  inline void set_has_clubid();
  inline void clear_has_clubid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* clubid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static ResNotifyClubKickedOut* default_instance_;
};
// -------------------------------------------------------------------

class ResNotifyClubChangeGameType : public ::google::protobuf::Message {
 public:
  ResNotifyClubChangeGameType();
  virtual ~ResNotifyClubChangeGameType();

  ResNotifyClubChangeGameType(const ResNotifyClubChangeGameType& from);

  inline ResNotifyClubChangeGameType& operator=(const ResNotifyClubChangeGameType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResNotifyClubChangeGameType& default_instance();

  void Swap(ResNotifyClubChangeGameType* other);

  // implements Message ----------------------------------------------

  ResNotifyClubChangeGameType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResNotifyClubChangeGameType& from);
  void MergeFrom(const ResNotifyClubChangeGameType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string clubId = 1;
  inline bool has_clubid() const;
  inline void clear_clubid();
  static const int kClubIdFieldNumber = 1;
  inline const ::std::string& clubid() const;
  inline void set_clubid(const ::std::string& value);
  inline void set_clubid(const char* value);
  inline void set_clubid(const char* value, size_t size);
  inline ::std::string* mutable_clubid();
  inline ::std::string* release_clubid();
  inline void set_allocated_clubid(::std::string* clubid);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResNotifyClubChangeGameType)
 private:
  inline void set_has_clubid();
  inline void clear_has_clubid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* clubid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MsgGate_2eproto();
  friend void protobuf_AssignDesc_MsgGate_2eproto();
  friend void protobuf_ShutdownFile_MsgGate_2eproto();

  void InitAsDefaultInstance();
  static ResNotifyClubChangeGameType* default_instance_;
};
// ===================================================================


// ===================================================================

// AccountInfo

// optional string name = 1;
inline bool AccountInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& AccountInfo::name() const {
  return *name_;
}
inline void AccountInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AccountInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void AccountInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* AccountInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string nick = 2;
inline bool AccountInfo::has_nick() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountInfo::set_has_nick() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountInfo::clear_has_nick() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountInfo::clear_nick() {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    nick_->clear();
  }
  clear_has_nick();
}
inline const ::std::string& AccountInfo::nick() const {
  return *nick_;
}
inline void AccountInfo::set_nick(const ::std::string& value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void AccountInfo::set_nick(const char* value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void AccountInfo::set_nick(const char* value, size_t size) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountInfo::mutable_nick() {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  return nick_;
}
inline ::std::string* AccountInfo::release_nick() {
  clear_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nick_;
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountInfo::set_allocated_nick(::std::string* nick) {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    delete nick_;
  }
  if (nick) {
    set_has_nick();
    nick_ = nick;
  } else {
    clear_has_nick();
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 uid = 3;
inline bool AccountInfo::has_uid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AccountInfo::set_has_uid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AccountInfo::clear_has_uid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AccountInfo::clear_uid() {
  uid_ = 0;
  clear_has_uid();
}
inline ::google::protobuf::int32 AccountInfo::uid() const {
  return uid_;
}
inline void AccountInfo::set_uid(::google::protobuf::int32 value) {
  set_has_uid();
  uid_ = value;
}

// optional int32 sex = 4;
inline bool AccountInfo::has_sex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AccountInfo::set_has_sex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AccountInfo::clear_has_sex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AccountInfo::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::google::protobuf::int32 AccountInfo::sex() const {
  return sex_;
}
inline void AccountInfo::set_sex(::google::protobuf::int32 value) {
  set_has_sex();
  sex_ = value;
}

// optional string phone = 5;
inline bool AccountInfo::has_phone() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AccountInfo::set_has_phone() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AccountInfo::clear_has_phone() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AccountInfo::clear_phone() {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    phone_->clear();
  }
  clear_has_phone();
}
inline const ::std::string& AccountInfo::phone() const {
  return *phone_;
}
inline void AccountInfo::set_phone(const ::std::string& value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void AccountInfo::set_phone(const char* value) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(value);
}
inline void AccountInfo::set_phone(const char* value, size_t size) {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  phone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountInfo::mutable_phone() {
  set_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    phone_ = new ::std::string;
  }
  return phone_;
}
inline ::std::string* AccountInfo::release_phone() {
  clear_has_phone();
  if (phone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phone_;
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountInfo::set_allocated_phone(::std::string* phone) {
  if (phone_ != &::google::protobuf::internal::kEmptyString) {
    delete phone_;
  }
  if (phone) {
    set_has_phone();
    phone_ = phone;
  } else {
    clear_has_phone();
    phone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string email = 6;
inline bool AccountInfo::has_email() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AccountInfo::set_has_email() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AccountInfo::clear_has_email() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AccountInfo::clear_email() {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    email_->clear();
  }
  clear_has_email();
}
inline const ::std::string& AccountInfo::email() const {
  return *email_;
}
inline void AccountInfo::set_email(const ::std::string& value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void AccountInfo::set_email(const char* value) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(value);
}
inline void AccountInfo::set_email(const char* value, size_t size) {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  email_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountInfo::mutable_email() {
  set_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    email_ = new ::std::string;
  }
  return email_;
}
inline ::std::string* AccountInfo::release_email() {
  clear_has_email();
  if (email_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = email_;
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountInfo::set_allocated_email(::std::string* email) {
  if (email_ != &::google::protobuf::internal::kEmptyString) {
    delete email_;
  }
  if (email) {
    set_has_email();
    email_ = email;
  } else {
    clear_has_email();
    email_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 head = 7;
inline bool AccountInfo::has_head() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AccountInfo::set_has_head() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AccountInfo::clear_has_head() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AccountInfo::clear_head() {
  head_ = 0;
  clear_has_head();
}
inline ::google::protobuf::int32 AccountInfo::head() const {
  return head_;
}
inline void AccountInfo::set_head(::google::protobuf::int32 value) {
  set_has_head();
  head_ = value;
}

// optional string headUrl = 8;
inline bool AccountInfo::has_headurl() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void AccountInfo::set_has_headurl() {
  _has_bits_[0] |= 0x00000080u;
}
inline void AccountInfo::clear_has_headurl() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void AccountInfo::clear_headurl() {
  if (headurl_ != &::google::protobuf::internal::kEmptyString) {
    headurl_->clear();
  }
  clear_has_headurl();
}
inline const ::std::string& AccountInfo::headurl() const {
  return *headurl_;
}
inline void AccountInfo::set_headurl(const ::std::string& value) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(value);
}
inline void AccountInfo::set_headurl(const char* value) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(value);
}
inline void AccountInfo::set_headurl(const char* value, size_t size) {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  headurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountInfo::mutable_headurl() {
  set_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    headurl_ = new ::std::string;
  }
  return headurl_;
}
inline ::std::string* AccountInfo::release_headurl() {
  clear_has_headurl();
  if (headurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = headurl_;
    headurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountInfo::set_allocated_headurl(::std::string* headurl) {
  if (headurl_ != &::google::protobuf::internal::kEmptyString) {
    delete headurl_;
  }
  if (headurl) {
    set_has_headurl();
    headurl_ = headurl;
  } else {
    clear_has_headurl();
    headurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 lv = 9;
inline bool AccountInfo::has_lv() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void AccountInfo::set_has_lv() {
  _has_bits_[0] |= 0x00000100u;
}
inline void AccountInfo::clear_has_lv() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void AccountInfo::clear_lv() {
  lv_ = 0;
  clear_has_lv();
}
inline ::google::protobuf::int32 AccountInfo::lv() const {
  return lv_;
}
inline void AccountInfo::set_lv(::google::protobuf::int32 value) {
  set_has_lv();
  lv_ = value;
}

// optional int32 vip = 10;
inline bool AccountInfo::has_vip() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AccountInfo::set_has_vip() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AccountInfo::clear_has_vip() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AccountInfo::clear_vip() {
  vip_ = 0;
  clear_has_vip();
}
inline ::google::protobuf::int32 AccountInfo::vip() const {
  return vip_;
}
inline void AccountInfo::set_vip(::google::protobuf::int32 value) {
  set_has_vip();
  vip_ = value;
}

// optional string ipaddress = 11;
inline bool AccountInfo::has_ipaddress() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void AccountInfo::set_has_ipaddress() {
  _has_bits_[0] |= 0x00000400u;
}
inline void AccountInfo::clear_has_ipaddress() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void AccountInfo::clear_ipaddress() {
  if (ipaddress_ != &::google::protobuf::internal::kEmptyString) {
    ipaddress_->clear();
  }
  clear_has_ipaddress();
}
inline const ::std::string& AccountInfo::ipaddress() const {
  return *ipaddress_;
}
inline void AccountInfo::set_ipaddress(const ::std::string& value) {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    ipaddress_ = new ::std::string;
  }
  ipaddress_->assign(value);
}
inline void AccountInfo::set_ipaddress(const char* value) {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    ipaddress_ = new ::std::string;
  }
  ipaddress_->assign(value);
}
inline void AccountInfo::set_ipaddress(const char* value, size_t size) {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    ipaddress_ = new ::std::string;
  }
  ipaddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountInfo::mutable_ipaddress() {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    ipaddress_ = new ::std::string;
  }
  return ipaddress_;
}
inline ::std::string* AccountInfo::release_ipaddress() {
  clear_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ipaddress_;
    ipaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountInfo::set_allocated_ipaddress(::std::string* ipaddress) {
  if (ipaddress_ != &::google::protobuf::internal::kEmptyString) {
    delete ipaddress_;
  }
  if (ipaddress) {
    set_has_ipaddress();
    ipaddress_ = ipaddress;
  } else {
    clear_has_ipaddress();
    ipaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string address = 12;
inline bool AccountInfo::has_address() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void AccountInfo::set_has_address() {
  _has_bits_[0] |= 0x00000800u;
}
inline void AccountInfo::clear_has_address() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void AccountInfo::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& AccountInfo::address() const {
  return *address_;
}
inline void AccountInfo::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void AccountInfo::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void AccountInfo::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountInfo::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* AccountInfo::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountInfo::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 inviter = 13;
inline bool AccountInfo::has_inviter() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void AccountInfo::set_has_inviter() {
  _has_bits_[0] |= 0x00001000u;
}
inline void AccountInfo::clear_has_inviter() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void AccountInfo::clear_inviter() {
  inviter_ = 0;
  clear_has_inviter();
}
inline ::google::protobuf::int32 AccountInfo::inviter() const {
  return inviter_;
}
inline void AccountInfo::set_inviter(::google::protobuf::int32 value) {
  set_has_inviter();
  inviter_ = value;
}

// repeated .ProtoNet.PlayerAccount counts = 14;
inline int AccountInfo::counts_size() const {
  return counts_.size();
}
inline void AccountInfo::clear_counts() {
  counts_.Clear();
}
inline const ::ProtoNet::PlayerAccount& AccountInfo::counts(int index) const {
  return counts_.Get(index);
}
inline ::ProtoNet::PlayerAccount* AccountInfo::mutable_counts(int index) {
  return counts_.Mutable(index);
}
inline ::ProtoNet::PlayerAccount* AccountInfo::add_counts() {
  return counts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::PlayerAccount >&
AccountInfo::counts() const {
  return counts_;
}
inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::PlayerAccount >*
AccountInfo::mutable_counts() {
  return &counts_;
}

// optional .ProtoNet.LastGameInfo lastGameInfo = 15;
inline bool AccountInfo::has_lastgameinfo() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void AccountInfo::set_has_lastgameinfo() {
  _has_bits_[0] |= 0x00004000u;
}
inline void AccountInfo::clear_has_lastgameinfo() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void AccountInfo::clear_lastgameinfo() {
  if (lastgameinfo_ != NULL) lastgameinfo_->::ProtoNet::LastGameInfo::Clear();
  clear_has_lastgameinfo();
}
inline const ::ProtoNet::LastGameInfo& AccountInfo::lastgameinfo() const {
  return lastgameinfo_ != NULL ? *lastgameinfo_ : *default_instance_->lastgameinfo_;
}
inline ::ProtoNet::LastGameInfo* AccountInfo::mutable_lastgameinfo() {
  set_has_lastgameinfo();
  if (lastgameinfo_ == NULL) lastgameinfo_ = new ::ProtoNet::LastGameInfo;
  return lastgameinfo_;
}
inline ::ProtoNet::LastGameInfo* AccountInfo::release_lastgameinfo() {
  clear_has_lastgameinfo();
  ::ProtoNet::LastGameInfo* temp = lastgameinfo_;
  lastgameinfo_ = NULL;
  return temp;
}
inline void AccountInfo::set_allocated_lastgameinfo(::ProtoNet::LastGameInfo* lastgameinfo) {
  delete lastgameinfo_;
  lastgameinfo_ = lastgameinfo;
  if (lastgameinfo) {
    set_has_lastgameinfo();
  } else {
    clear_has_lastgameinfo();
  }
}

// -------------------------------------------------------------------

// LastGameInfo

// optional int32 gameId = 1;
inline bool LastGameInfo::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LastGameInfo::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LastGameInfo::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LastGameInfo::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 LastGameInfo::gameid() const {
  return gameid_;
}
inline void LastGameInfo::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional .ProtoNet.LastGameInfoDetail detail = 2;
inline bool LastGameInfo::has_detail() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LastGameInfo::set_has_detail() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LastGameInfo::clear_has_detail() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LastGameInfo::clear_detail() {
  if (detail_ != NULL) detail_->::ProtoNet::LastGameInfoDetail::Clear();
  clear_has_detail();
}
inline const ::ProtoNet::LastGameInfoDetail& LastGameInfo::detail() const {
  return detail_ != NULL ? *detail_ : *default_instance_->detail_;
}
inline ::ProtoNet::LastGameInfoDetail* LastGameInfo::mutable_detail() {
  set_has_detail();
  if (detail_ == NULL) detail_ = new ::ProtoNet::LastGameInfoDetail;
  return detail_;
}
inline ::ProtoNet::LastGameInfoDetail* LastGameInfo::release_detail() {
  clear_has_detail();
  ::ProtoNet::LastGameInfoDetail* temp = detail_;
  detail_ = NULL;
  return temp;
}
inline void LastGameInfo::set_allocated_detail(::ProtoNet::LastGameInfoDetail* detail) {
  delete detail_;
  detail_ = detail;
  if (detail) {
    set_has_detail();
  } else {
    clear_has_detail();
  }
}

// optional .ProtoNet.ServerInfoIpsSafeDetail gate = 3;
inline bool LastGameInfo::has_gate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LastGameInfo::set_has_gate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LastGameInfo::clear_has_gate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LastGameInfo::clear_gate() {
  if (gate_ != NULL) gate_->::ProtoNet::ServerInfoIpsSafeDetail::Clear();
  clear_has_gate();
}
inline const ::ProtoNet::ServerInfoIpsSafeDetail& LastGameInfo::gate() const {
  return gate_ != NULL ? *gate_ : *default_instance_->gate_;
}
inline ::ProtoNet::ServerInfoIpsSafeDetail* LastGameInfo::mutable_gate() {
  set_has_gate();
  if (gate_ == NULL) gate_ = new ::ProtoNet::ServerInfoIpsSafeDetail;
  return gate_;
}
inline ::ProtoNet::ServerInfoIpsSafeDetail* LastGameInfo::release_gate() {
  clear_has_gate();
  ::ProtoNet::ServerInfoIpsSafeDetail* temp = gate_;
  gate_ = NULL;
  return temp;
}
inline void LastGameInfo::set_allocated_gate(::ProtoNet::ServerInfoIpsSafeDetail* gate) {
  delete gate_;
  gate_ = gate;
  if (gate) {
    set_has_gate();
  } else {
    clear_has_gate();
  }
}

// optional .ProtoNet.ServerInfoIpsSafeDetail logic = 4;
inline bool LastGameInfo::has_logic() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LastGameInfo::set_has_logic() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LastGameInfo::clear_has_logic() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LastGameInfo::clear_logic() {
  if (logic_ != NULL) logic_->::ProtoNet::ServerInfoIpsSafeDetail::Clear();
  clear_has_logic();
}
inline const ::ProtoNet::ServerInfoIpsSafeDetail& LastGameInfo::logic() const {
  return logic_ != NULL ? *logic_ : *default_instance_->logic_;
}
inline ::ProtoNet::ServerInfoIpsSafeDetail* LastGameInfo::mutable_logic() {
  set_has_logic();
  if (logic_ == NULL) logic_ = new ::ProtoNet::ServerInfoIpsSafeDetail;
  return logic_;
}
inline ::ProtoNet::ServerInfoIpsSafeDetail* LastGameInfo::release_logic() {
  clear_has_logic();
  ::ProtoNet::ServerInfoIpsSafeDetail* temp = logic_;
  logic_ = NULL;
  return temp;
}
inline void LastGameInfo::set_allocated_logic(::ProtoNet::ServerInfoIpsSafeDetail* logic) {
  delete logic_;
  logic_ = logic;
  if (logic) {
    set_has_logic();
  } else {
    clear_has_logic();
  }
}

// -------------------------------------------------------------------

// LastGameInfoDetail

// optional int32 type = 1;
inline bool LastGameInfoDetail::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LastGameInfoDetail::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LastGameInfoDetail::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LastGameInfoDetail::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 LastGameInfoDetail::type() const {
  return type_;
}
inline void LastGameInfoDetail::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional string roomId = 2;
inline bool LastGameInfoDetail::has_roomid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LastGameInfoDetail::set_has_roomid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LastGameInfoDetail::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LastGameInfoDetail::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& LastGameInfoDetail::roomid() const {
  return *roomid_;
}
inline void LastGameInfoDetail::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void LastGameInfoDetail::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void LastGameInfoDetail::set_roomid(const char* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LastGameInfoDetail::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  return roomid_;
}
inline ::std::string* LastGameInfoDetail::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LastGameInfoDetail::set_allocated_roomid(::std::string* roomid) {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomid_;
  }
  if (roomid) {
    set_has_roomid();
    roomid_ = roomid;
  } else {
    clear_has_roomid();
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 status = 3;
inline bool LastGameInfoDetail::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LastGameInfoDetail::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LastGameInfoDetail::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LastGameInfoDetail::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 LastGameInfoDetail::status() const {
  return status_;
}
inline void LastGameInfoDetail::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// GameZoneInfo

// optional int32 gameId = 1;
inline bool GameZoneInfo::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameZoneInfo::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameZoneInfo::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameZoneInfo::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GameZoneInfo::gameid() const {
  return gameid_;
}
inline void GameZoneInfo::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional bool isOpen = 3;
inline bool GameZoneInfo::has_isopen() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameZoneInfo::set_has_isopen() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameZoneInfo::clear_has_isopen() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameZoneInfo::clear_isopen() {
  isopen_ = false;
  clear_has_isopen();
}
inline bool GameZoneInfo::isopen() const {
  return isopen_;
}
inline void GameZoneInfo::set_isopen(bool value) {
  set_has_isopen();
  isopen_ = value;
}

// -------------------------------------------------------------------

// ServerInfoIpsSafeDetail

// optional int32 serverId = 1;
inline bool ServerInfoIpsSafeDetail::has_serverid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerInfoIpsSafeDetail::set_has_serverid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerInfoIpsSafeDetail::clear_has_serverid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerInfoIpsSafeDetail::clear_serverid() {
  serverid_ = 0;
  clear_has_serverid();
}
inline ::google::protobuf::int32 ServerInfoIpsSafeDetail::serverid() const {
  return serverid_;
}
inline void ServerInfoIpsSafeDetail::set_serverid(::google::protobuf::int32 value) {
  set_has_serverid();
  serverid_ = value;
}

// optional string serverName = 2;
inline bool ServerInfoIpsSafeDetail::has_servername() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerInfoIpsSafeDetail::set_has_servername() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerInfoIpsSafeDetail::clear_has_servername() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerInfoIpsSafeDetail::clear_servername() {
  if (servername_ != &::google::protobuf::internal::kEmptyString) {
    servername_->clear();
  }
  clear_has_servername();
}
inline const ::std::string& ServerInfoIpsSafeDetail::servername() const {
  return *servername_;
}
inline void ServerInfoIpsSafeDetail::set_servername(const ::std::string& value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
}
inline void ServerInfoIpsSafeDetail::set_servername(const char* value) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(value);
}
inline void ServerInfoIpsSafeDetail::set_servername(const char* value, size_t size) {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  servername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServerInfoIpsSafeDetail::mutable_servername() {
  set_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    servername_ = new ::std::string;
  }
  return servername_;
}
inline ::std::string* ServerInfoIpsSafeDetail::release_servername() {
  clear_has_servername();
  if (servername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = servername_;
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ServerInfoIpsSafeDetail::set_allocated_servername(::std::string* servername) {
  if (servername_ != &::google::protobuf::internal::kEmptyString) {
    delete servername_;
  }
  if (servername) {
    set_has_servername();
    servername_ = servername;
  } else {
    clear_has_servername();
    servername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 playerNum = 3;
inline bool ServerInfoIpsSafeDetail::has_playernum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerInfoIpsSafeDetail::set_has_playernum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerInfoIpsSafeDetail::clear_has_playernum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerInfoIpsSafeDetail::clear_playernum() {
  playernum_ = 0;
  clear_has_playernum();
}
inline ::google::protobuf::int32 ServerInfoIpsSafeDetail::playernum() const {
  return playernum_;
}
inline void ServerInfoIpsSafeDetail::set_playernum(::google::protobuf::int32 value) {
  set_has_playernum();
  playernum_ = value;
}

// optional bool isOpen = 4;
inline bool ServerInfoIpsSafeDetail::has_isopen() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerInfoIpsSafeDetail::set_has_isopen() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServerInfoIpsSafeDetail::clear_has_isopen() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServerInfoIpsSafeDetail::clear_isopen() {
  isopen_ = false;
  clear_has_isopen();
}
inline bool ServerInfoIpsSafeDetail::isopen() const {
  return isopen_;
}
inline void ServerInfoIpsSafeDetail::set_isopen(bool value) {
  set_has_isopen();
  isopen_ = value;
}

// repeated .ProtoNet.SafeIpAndPortDetail safeIpAndPortDetails = 5;
inline int ServerInfoIpsSafeDetail::safeipandportdetails_size() const {
  return safeipandportdetails_.size();
}
inline void ServerInfoIpsSafeDetail::clear_safeipandportdetails() {
  safeipandportdetails_.Clear();
}
inline const ::ProtoNet::SafeIpAndPortDetail& ServerInfoIpsSafeDetail::safeipandportdetails(int index) const {
  return safeipandportdetails_.Get(index);
}
inline ::ProtoNet::SafeIpAndPortDetail* ServerInfoIpsSafeDetail::mutable_safeipandportdetails(int index) {
  return safeipandportdetails_.Mutable(index);
}
inline ::ProtoNet::SafeIpAndPortDetail* ServerInfoIpsSafeDetail::add_safeipandportdetails() {
  return safeipandportdetails_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::SafeIpAndPortDetail >&
ServerInfoIpsSafeDetail::safeipandportdetails() const {
  return safeipandportdetails_;
}
inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::SafeIpAndPortDetail >*
ServerInfoIpsSafeDetail::mutable_safeipandportdetails() {
  return &safeipandportdetails_;
}

// -------------------------------------------------------------------

// SafeIpAndPortDetail

// optional string safeIp = 1;
inline bool SafeIpAndPortDetail::has_safeip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SafeIpAndPortDetail::set_has_safeip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SafeIpAndPortDetail::clear_has_safeip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SafeIpAndPortDetail::clear_safeip() {
  if (safeip_ != &::google::protobuf::internal::kEmptyString) {
    safeip_->clear();
  }
  clear_has_safeip();
}
inline const ::std::string& SafeIpAndPortDetail::safeip() const {
  return *safeip_;
}
inline void SafeIpAndPortDetail::set_safeip(const ::std::string& value) {
  set_has_safeip();
  if (safeip_ == &::google::protobuf::internal::kEmptyString) {
    safeip_ = new ::std::string;
  }
  safeip_->assign(value);
}
inline void SafeIpAndPortDetail::set_safeip(const char* value) {
  set_has_safeip();
  if (safeip_ == &::google::protobuf::internal::kEmptyString) {
    safeip_ = new ::std::string;
  }
  safeip_->assign(value);
}
inline void SafeIpAndPortDetail::set_safeip(const char* value, size_t size) {
  set_has_safeip();
  if (safeip_ == &::google::protobuf::internal::kEmptyString) {
    safeip_ = new ::std::string;
  }
  safeip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SafeIpAndPortDetail::mutable_safeip() {
  set_has_safeip();
  if (safeip_ == &::google::protobuf::internal::kEmptyString) {
    safeip_ = new ::std::string;
  }
  return safeip_;
}
inline ::std::string* SafeIpAndPortDetail::release_safeip() {
  clear_has_safeip();
  if (safeip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = safeip_;
    safeip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SafeIpAndPortDetail::set_allocated_safeip(::std::string* safeip) {
  if (safeip_ != &::google::protobuf::internal::kEmptyString) {
    delete safeip_;
  }
  if (safeip) {
    set_has_safeip();
    safeip_ = safeip;
  } else {
    clear_has_safeip();
    safeip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string safePort = 2;
inline bool SafeIpAndPortDetail::has_safeport() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SafeIpAndPortDetail::set_has_safeport() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SafeIpAndPortDetail::clear_has_safeport() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SafeIpAndPortDetail::clear_safeport() {
  if (safeport_ != &::google::protobuf::internal::kEmptyString) {
    safeport_->clear();
  }
  clear_has_safeport();
}
inline const ::std::string& SafeIpAndPortDetail::safeport() const {
  return *safeport_;
}
inline void SafeIpAndPortDetail::set_safeport(const ::std::string& value) {
  set_has_safeport();
  if (safeport_ == &::google::protobuf::internal::kEmptyString) {
    safeport_ = new ::std::string;
  }
  safeport_->assign(value);
}
inline void SafeIpAndPortDetail::set_safeport(const char* value) {
  set_has_safeport();
  if (safeport_ == &::google::protobuf::internal::kEmptyString) {
    safeport_ = new ::std::string;
  }
  safeport_->assign(value);
}
inline void SafeIpAndPortDetail::set_safeport(const char* value, size_t size) {
  set_has_safeport();
  if (safeport_ == &::google::protobuf::internal::kEmptyString) {
    safeport_ = new ::std::string;
  }
  safeport_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SafeIpAndPortDetail::mutable_safeport() {
  set_has_safeport();
  if (safeport_ == &::google::protobuf::internal::kEmptyString) {
    safeport_ = new ::std::string;
  }
  return safeport_;
}
inline ::std::string* SafeIpAndPortDetail::release_safeport() {
  clear_has_safeport();
  if (safeport_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = safeport_;
    safeport_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SafeIpAndPortDetail::set_allocated_safeport(::std::string* safeport) {
  if (safeport_ != &::google::protobuf::internal::kEmptyString) {
    delete safeport_;
  }
  if (safeport) {
    set_has_safeport();
    safeport_ = safeport;
  } else {
    clear_has_safeport();
    safeport_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string evironment = 3;
inline bool SafeIpAndPortDetail::has_evironment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SafeIpAndPortDetail::set_has_evironment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SafeIpAndPortDetail::clear_has_evironment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SafeIpAndPortDetail::clear_evironment() {
  if (evironment_ != &::google::protobuf::internal::kEmptyString) {
    evironment_->clear();
  }
  clear_has_evironment();
}
inline const ::std::string& SafeIpAndPortDetail::evironment() const {
  return *evironment_;
}
inline void SafeIpAndPortDetail::set_evironment(const ::std::string& value) {
  set_has_evironment();
  if (evironment_ == &::google::protobuf::internal::kEmptyString) {
    evironment_ = new ::std::string;
  }
  evironment_->assign(value);
}
inline void SafeIpAndPortDetail::set_evironment(const char* value) {
  set_has_evironment();
  if (evironment_ == &::google::protobuf::internal::kEmptyString) {
    evironment_ = new ::std::string;
  }
  evironment_->assign(value);
}
inline void SafeIpAndPortDetail::set_evironment(const char* value, size_t size) {
  set_has_evironment();
  if (evironment_ == &::google::protobuf::internal::kEmptyString) {
    evironment_ = new ::std::string;
  }
  evironment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SafeIpAndPortDetail::mutable_evironment() {
  set_has_evironment();
  if (evironment_ == &::google::protobuf::internal::kEmptyString) {
    evironment_ = new ::std::string;
  }
  return evironment_;
}
inline ::std::string* SafeIpAndPortDetail::release_evironment() {
  clear_has_evironment();
  if (evironment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = evironment_;
    evironment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SafeIpAndPortDetail::set_allocated_evironment(::std::string* evironment) {
  if (evironment_ != &::google::protobuf::internal::kEmptyString) {
    delete evironment_;
  }
  if (evironment) {
    set_has_evironment();
    evironment_ = evironment;
  } else {
    clear_has_evironment();
    evironment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string safeHttpPort = 4;
inline bool SafeIpAndPortDetail::has_safehttpport() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SafeIpAndPortDetail::set_has_safehttpport() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SafeIpAndPortDetail::clear_has_safehttpport() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SafeIpAndPortDetail::clear_safehttpport() {
  if (safehttpport_ != &::google::protobuf::internal::kEmptyString) {
    safehttpport_->clear();
  }
  clear_has_safehttpport();
}
inline const ::std::string& SafeIpAndPortDetail::safehttpport() const {
  return *safehttpport_;
}
inline void SafeIpAndPortDetail::set_safehttpport(const ::std::string& value) {
  set_has_safehttpport();
  if (safehttpport_ == &::google::protobuf::internal::kEmptyString) {
    safehttpport_ = new ::std::string;
  }
  safehttpport_->assign(value);
}
inline void SafeIpAndPortDetail::set_safehttpport(const char* value) {
  set_has_safehttpport();
  if (safehttpport_ == &::google::protobuf::internal::kEmptyString) {
    safehttpport_ = new ::std::string;
  }
  safehttpport_->assign(value);
}
inline void SafeIpAndPortDetail::set_safehttpport(const char* value, size_t size) {
  set_has_safehttpport();
  if (safehttpport_ == &::google::protobuf::internal::kEmptyString) {
    safehttpport_ = new ::std::string;
  }
  safehttpport_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SafeIpAndPortDetail::mutable_safehttpport() {
  set_has_safehttpport();
  if (safehttpport_ == &::google::protobuf::internal::kEmptyString) {
    safehttpport_ = new ::std::string;
  }
  return safehttpport_;
}
inline ::std::string* SafeIpAndPortDetail::release_safehttpport() {
  clear_has_safehttpport();
  if (safehttpport_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = safehttpport_;
    safehttpport_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SafeIpAndPortDetail::set_allocated_safehttpport(::std::string* safehttpport) {
  if (safehttpport_ != &::google::protobuf::internal::kEmptyString) {
    delete safehttpport_;
  }
  if (safehttpport) {
    set_has_safehttpport();
    safehttpport_ = safehttpport;
  } else {
    clear_has_safehttpport();
    safehttpport_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GoldRoomServerInfos

// required string roomId = 1;
inline bool GoldRoomServerInfos::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GoldRoomServerInfos::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GoldRoomServerInfos::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GoldRoomServerInfos::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& GoldRoomServerInfos::roomid() const {
  return *roomid_;
}
inline void GoldRoomServerInfos::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void GoldRoomServerInfos::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void GoldRoomServerInfos::set_roomid(const char* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GoldRoomServerInfos::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  return roomid_;
}
inline ::std::string* GoldRoomServerInfos::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GoldRoomServerInfos::set_allocated_roomid(::std::string* roomid) {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomid_;
  }
  if (roomid) {
    set_has_roomid();
    roomid_ = roomid;
  } else {
    clear_has_roomid();
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string roomName = 2;
inline bool GoldRoomServerInfos::has_roomname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GoldRoomServerInfos::set_has_roomname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GoldRoomServerInfos::clear_has_roomname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GoldRoomServerInfos::clear_roomname() {
  if (roomname_ != &::google::protobuf::internal::kEmptyString) {
    roomname_->clear();
  }
  clear_has_roomname();
}
inline const ::std::string& GoldRoomServerInfos::roomname() const {
  return *roomname_;
}
inline void GoldRoomServerInfos::set_roomname(const ::std::string& value) {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    roomname_ = new ::std::string;
  }
  roomname_->assign(value);
}
inline void GoldRoomServerInfos::set_roomname(const char* value) {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    roomname_ = new ::std::string;
  }
  roomname_->assign(value);
}
inline void GoldRoomServerInfos::set_roomname(const char* value, size_t size) {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    roomname_ = new ::std::string;
  }
  roomname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GoldRoomServerInfos::mutable_roomname() {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    roomname_ = new ::std::string;
  }
  return roomname_;
}
inline ::std::string* GoldRoomServerInfos::release_roomname() {
  clear_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomname_;
    roomname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GoldRoomServerInfos::set_allocated_roomname(::std::string* roomname) {
  if (roomname_ != &::google::protobuf::internal::kEmptyString) {
    delete roomname_;
  }
  if (roomname) {
    set_has_roomname();
    roomname_ = roomname;
  } else {
    clear_has_roomname();
    roomname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string roomerUniqueId = 3;
inline bool GoldRoomServerInfos::has_roomeruniqueid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GoldRoomServerInfos::set_has_roomeruniqueid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GoldRoomServerInfos::clear_has_roomeruniqueid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GoldRoomServerInfos::clear_roomeruniqueid() {
  if (roomeruniqueid_ != &::google::protobuf::internal::kEmptyString) {
    roomeruniqueid_->clear();
  }
  clear_has_roomeruniqueid();
}
inline const ::std::string& GoldRoomServerInfos::roomeruniqueid() const {
  return *roomeruniqueid_;
}
inline void GoldRoomServerInfos::set_roomeruniqueid(const ::std::string& value) {
  set_has_roomeruniqueid();
  if (roomeruniqueid_ == &::google::protobuf::internal::kEmptyString) {
    roomeruniqueid_ = new ::std::string;
  }
  roomeruniqueid_->assign(value);
}
inline void GoldRoomServerInfos::set_roomeruniqueid(const char* value) {
  set_has_roomeruniqueid();
  if (roomeruniqueid_ == &::google::protobuf::internal::kEmptyString) {
    roomeruniqueid_ = new ::std::string;
  }
  roomeruniqueid_->assign(value);
}
inline void GoldRoomServerInfos::set_roomeruniqueid(const char* value, size_t size) {
  set_has_roomeruniqueid();
  if (roomeruniqueid_ == &::google::protobuf::internal::kEmptyString) {
    roomeruniqueid_ = new ::std::string;
  }
  roomeruniqueid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GoldRoomServerInfos::mutable_roomeruniqueid() {
  set_has_roomeruniqueid();
  if (roomeruniqueid_ == &::google::protobuf::internal::kEmptyString) {
    roomeruniqueid_ = new ::std::string;
  }
  return roomeruniqueid_;
}
inline ::std::string* GoldRoomServerInfos::release_roomeruniqueid() {
  clear_has_roomeruniqueid();
  if (roomeruniqueid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomeruniqueid_;
    roomeruniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GoldRoomServerInfos::set_allocated_roomeruniqueid(::std::string* roomeruniqueid) {
  if (roomeruniqueid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomeruniqueid_;
  }
  if (roomeruniqueid) {
    set_has_roomeruniqueid();
    roomeruniqueid_ = roomeruniqueid;
  } else {
    clear_has_roomeruniqueid();
    roomeruniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string roomerNickName = 4;
inline bool GoldRoomServerInfos::has_roomernickname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GoldRoomServerInfos::set_has_roomernickname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GoldRoomServerInfos::clear_has_roomernickname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GoldRoomServerInfos::clear_roomernickname() {
  if (roomernickname_ != &::google::protobuf::internal::kEmptyString) {
    roomernickname_->clear();
  }
  clear_has_roomernickname();
}
inline const ::std::string& GoldRoomServerInfos::roomernickname() const {
  return *roomernickname_;
}
inline void GoldRoomServerInfos::set_roomernickname(const ::std::string& value) {
  set_has_roomernickname();
  if (roomernickname_ == &::google::protobuf::internal::kEmptyString) {
    roomernickname_ = new ::std::string;
  }
  roomernickname_->assign(value);
}
inline void GoldRoomServerInfos::set_roomernickname(const char* value) {
  set_has_roomernickname();
  if (roomernickname_ == &::google::protobuf::internal::kEmptyString) {
    roomernickname_ = new ::std::string;
  }
  roomernickname_->assign(value);
}
inline void GoldRoomServerInfos::set_roomernickname(const char* value, size_t size) {
  set_has_roomernickname();
  if (roomernickname_ == &::google::protobuf::internal::kEmptyString) {
    roomernickname_ = new ::std::string;
  }
  roomernickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GoldRoomServerInfos::mutable_roomernickname() {
  set_has_roomernickname();
  if (roomernickname_ == &::google::protobuf::internal::kEmptyString) {
    roomernickname_ = new ::std::string;
  }
  return roomernickname_;
}
inline ::std::string* GoldRoomServerInfos::release_roomernickname() {
  clear_has_roomernickname();
  if (roomernickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomernickname_;
    roomernickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GoldRoomServerInfos::set_allocated_roomernickname(::std::string* roomernickname) {
  if (roomernickname_ != &::google::protobuf::internal::kEmptyString) {
    delete roomernickname_;
  }
  if (roomernickname) {
    set_has_roomernickname();
    roomernickname_ = roomernickname;
  } else {
    clear_has_roomernickname();
    roomernickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string roomerHeadImg = 5;
inline bool GoldRoomServerInfos::has_roomerheadimg() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GoldRoomServerInfos::set_has_roomerheadimg() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GoldRoomServerInfos::clear_has_roomerheadimg() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GoldRoomServerInfos::clear_roomerheadimg() {
  if (roomerheadimg_ != &::google::protobuf::internal::kEmptyString) {
    roomerheadimg_->clear();
  }
  clear_has_roomerheadimg();
}
inline const ::std::string& GoldRoomServerInfos::roomerheadimg() const {
  return *roomerheadimg_;
}
inline void GoldRoomServerInfos::set_roomerheadimg(const ::std::string& value) {
  set_has_roomerheadimg();
  if (roomerheadimg_ == &::google::protobuf::internal::kEmptyString) {
    roomerheadimg_ = new ::std::string;
  }
  roomerheadimg_->assign(value);
}
inline void GoldRoomServerInfos::set_roomerheadimg(const char* value) {
  set_has_roomerheadimg();
  if (roomerheadimg_ == &::google::protobuf::internal::kEmptyString) {
    roomerheadimg_ = new ::std::string;
  }
  roomerheadimg_->assign(value);
}
inline void GoldRoomServerInfos::set_roomerheadimg(const char* value, size_t size) {
  set_has_roomerheadimg();
  if (roomerheadimg_ == &::google::protobuf::internal::kEmptyString) {
    roomerheadimg_ = new ::std::string;
  }
  roomerheadimg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GoldRoomServerInfos::mutable_roomerheadimg() {
  set_has_roomerheadimg();
  if (roomerheadimg_ == &::google::protobuf::internal::kEmptyString) {
    roomerheadimg_ = new ::std::string;
  }
  return roomerheadimg_;
}
inline ::std::string* GoldRoomServerInfos::release_roomerheadimg() {
  clear_has_roomerheadimg();
  if (roomerheadimg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomerheadimg_;
    roomerheadimg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GoldRoomServerInfos::set_allocated_roomerheadimg(::std::string* roomerheadimg) {
  if (roomerheadimg_ != &::google::protobuf::internal::kEmptyString) {
    delete roomerheadimg_;
  }
  if (roomerheadimg) {
    set_has_roomerheadimg();
    roomerheadimg_ = roomerheadimg;
  } else {
    clear_has_roomerheadimg();
    roomerheadimg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 roomerHeadType = 6;
inline bool GoldRoomServerInfos::has_roomerheadtype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GoldRoomServerInfos::set_has_roomerheadtype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GoldRoomServerInfos::clear_has_roomerheadtype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GoldRoomServerInfos::clear_roomerheadtype() {
  roomerheadtype_ = 0;
  clear_has_roomerheadtype();
}
inline ::google::protobuf::int32 GoldRoomServerInfos::roomerheadtype() const {
  return roomerheadtype_;
}
inline void GoldRoomServerInfos::set_roomerheadtype(::google::protobuf::int32 value) {
  set_has_roomerheadtype();
  roomerheadtype_ = value;
}

// required int32 roomType = 7;
inline bool GoldRoomServerInfos::has_roomtype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GoldRoomServerInfos::set_has_roomtype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GoldRoomServerInfos::clear_has_roomtype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GoldRoomServerInfos::clear_roomtype() {
  roomtype_ = 0;
  clear_has_roomtype();
}
inline ::google::protobuf::int32 GoldRoomServerInfos::roomtype() const {
  return roomtype_;
}
inline void GoldRoomServerInfos::set_roomtype(::google::protobuf::int32 value) {
  set_has_roomtype();
  roomtype_ = value;
}

// required int32 gameId = 8;
inline bool GoldRoomServerInfos::has_gameid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GoldRoomServerInfos::set_has_gameid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GoldRoomServerInfos::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GoldRoomServerInfos::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GoldRoomServerInfos::gameid() const {
  return gameid_;
}
inline void GoldRoomServerInfos::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 timesType = 9;
inline bool GoldRoomServerInfos::has_timestype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GoldRoomServerInfos::set_has_timestype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GoldRoomServerInfos::clear_has_timestype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GoldRoomServerInfos::clear_timestype() {
  timestype_ = 0;
  clear_has_timestype();
}
inline ::google::protobuf::int32 GoldRoomServerInfos::timestype() const {
  return timestype_;
}
inline void GoldRoomServerInfos::set_timestype(::google::protobuf::int32 value) {
  set_has_timestype();
  timestype_ = value;
}

// required .ProtoNet.ServerInfoIpsSafeDetail serverInfo = 10;
inline bool GoldRoomServerInfos::has_serverinfo() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GoldRoomServerInfos::set_has_serverinfo() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GoldRoomServerInfos::clear_has_serverinfo() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GoldRoomServerInfos::clear_serverinfo() {
  if (serverinfo_ != NULL) serverinfo_->::ProtoNet::ServerInfoIpsSafeDetail::Clear();
  clear_has_serverinfo();
}
inline const ::ProtoNet::ServerInfoIpsSafeDetail& GoldRoomServerInfos::serverinfo() const {
  return serverinfo_ != NULL ? *serverinfo_ : *default_instance_->serverinfo_;
}
inline ::ProtoNet::ServerInfoIpsSafeDetail* GoldRoomServerInfos::mutable_serverinfo() {
  set_has_serverinfo();
  if (serverinfo_ == NULL) serverinfo_ = new ::ProtoNet::ServerInfoIpsSafeDetail;
  return serverinfo_;
}
inline ::ProtoNet::ServerInfoIpsSafeDetail* GoldRoomServerInfos::release_serverinfo() {
  clear_has_serverinfo();
  ::ProtoNet::ServerInfoIpsSafeDetail* temp = serverinfo_;
  serverinfo_ = NULL;
  return temp;
}
inline void GoldRoomServerInfos::set_allocated_serverinfo(::ProtoNet::ServerInfoIpsSafeDetail* serverinfo) {
  delete serverinfo_;
  serverinfo_ = serverinfo;
  if (serverinfo) {
    set_has_serverinfo();
  } else {
    clear_has_serverinfo();
  }
}

// -------------------------------------------------------------------

// OpenRoomReplaceRecordInfo

// required string roomId = 1;
inline bool OpenRoomReplaceRecordInfo::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OpenRoomReplaceRecordInfo::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OpenRoomReplaceRecordInfo::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OpenRoomReplaceRecordInfo::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& OpenRoomReplaceRecordInfo::roomid() const {
  return *roomid_;
}
inline void OpenRoomReplaceRecordInfo::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void OpenRoomReplaceRecordInfo::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void OpenRoomReplaceRecordInfo::set_roomid(const char* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OpenRoomReplaceRecordInfo::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  return roomid_;
}
inline ::std::string* OpenRoomReplaceRecordInfo::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OpenRoomReplaceRecordInfo::set_allocated_roomid(::std::string* roomid) {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomid_;
  }
  if (roomid) {
    set_has_roomid();
    roomid_ = roomid;
  } else {
    clear_has_roomid();
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string roomerUniqueId = 2;
inline bool OpenRoomReplaceRecordInfo::has_roomeruniqueid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OpenRoomReplaceRecordInfo::set_has_roomeruniqueid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OpenRoomReplaceRecordInfo::clear_has_roomeruniqueid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OpenRoomReplaceRecordInfo::clear_roomeruniqueid() {
  if (roomeruniqueid_ != &::google::protobuf::internal::kEmptyString) {
    roomeruniqueid_->clear();
  }
  clear_has_roomeruniqueid();
}
inline const ::std::string& OpenRoomReplaceRecordInfo::roomeruniqueid() const {
  return *roomeruniqueid_;
}
inline void OpenRoomReplaceRecordInfo::set_roomeruniqueid(const ::std::string& value) {
  set_has_roomeruniqueid();
  if (roomeruniqueid_ == &::google::protobuf::internal::kEmptyString) {
    roomeruniqueid_ = new ::std::string;
  }
  roomeruniqueid_->assign(value);
}
inline void OpenRoomReplaceRecordInfo::set_roomeruniqueid(const char* value) {
  set_has_roomeruniqueid();
  if (roomeruniqueid_ == &::google::protobuf::internal::kEmptyString) {
    roomeruniqueid_ = new ::std::string;
  }
  roomeruniqueid_->assign(value);
}
inline void OpenRoomReplaceRecordInfo::set_roomeruniqueid(const char* value, size_t size) {
  set_has_roomeruniqueid();
  if (roomeruniqueid_ == &::google::protobuf::internal::kEmptyString) {
    roomeruniqueid_ = new ::std::string;
  }
  roomeruniqueid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OpenRoomReplaceRecordInfo::mutable_roomeruniqueid() {
  set_has_roomeruniqueid();
  if (roomeruniqueid_ == &::google::protobuf::internal::kEmptyString) {
    roomeruniqueid_ = new ::std::string;
  }
  return roomeruniqueid_;
}
inline ::std::string* OpenRoomReplaceRecordInfo::release_roomeruniqueid() {
  clear_has_roomeruniqueid();
  if (roomeruniqueid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomeruniqueid_;
    roomeruniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OpenRoomReplaceRecordInfo::set_allocated_roomeruniqueid(::std::string* roomeruniqueid) {
  if (roomeruniqueid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomeruniqueid_;
  }
  if (roomeruniqueid) {
    set_has_roomeruniqueid();
    roomeruniqueid_ = roomeruniqueid;
  } else {
    clear_has_roomeruniqueid();
    roomeruniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string roomerNickName = 3;
inline bool OpenRoomReplaceRecordInfo::has_roomernickname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OpenRoomReplaceRecordInfo::set_has_roomernickname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OpenRoomReplaceRecordInfo::clear_has_roomernickname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OpenRoomReplaceRecordInfo::clear_roomernickname() {
  if (roomernickname_ != &::google::protobuf::internal::kEmptyString) {
    roomernickname_->clear();
  }
  clear_has_roomernickname();
}
inline const ::std::string& OpenRoomReplaceRecordInfo::roomernickname() const {
  return *roomernickname_;
}
inline void OpenRoomReplaceRecordInfo::set_roomernickname(const ::std::string& value) {
  set_has_roomernickname();
  if (roomernickname_ == &::google::protobuf::internal::kEmptyString) {
    roomernickname_ = new ::std::string;
  }
  roomernickname_->assign(value);
}
inline void OpenRoomReplaceRecordInfo::set_roomernickname(const char* value) {
  set_has_roomernickname();
  if (roomernickname_ == &::google::protobuf::internal::kEmptyString) {
    roomernickname_ = new ::std::string;
  }
  roomernickname_->assign(value);
}
inline void OpenRoomReplaceRecordInfo::set_roomernickname(const char* value, size_t size) {
  set_has_roomernickname();
  if (roomernickname_ == &::google::protobuf::internal::kEmptyString) {
    roomernickname_ = new ::std::string;
  }
  roomernickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OpenRoomReplaceRecordInfo::mutable_roomernickname() {
  set_has_roomernickname();
  if (roomernickname_ == &::google::protobuf::internal::kEmptyString) {
    roomernickname_ = new ::std::string;
  }
  return roomernickname_;
}
inline ::std::string* OpenRoomReplaceRecordInfo::release_roomernickname() {
  clear_has_roomernickname();
  if (roomernickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomernickname_;
    roomernickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OpenRoomReplaceRecordInfo::set_allocated_roomernickname(::std::string* roomernickname) {
  if (roomernickname_ != &::google::protobuf::internal::kEmptyString) {
    delete roomernickname_;
  }
  if (roomernickname) {
    set_has_roomernickname();
    roomernickname_ = roomernickname;
  } else {
    clear_has_roomernickname();
    roomernickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int64 createTime = 4;
inline bool OpenRoomReplaceRecordInfo::has_createtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OpenRoomReplaceRecordInfo::set_has_createtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OpenRoomReplaceRecordInfo::clear_has_createtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OpenRoomReplaceRecordInfo::clear_createtime() {
  createtime_ = GOOGLE_LONGLONG(0);
  clear_has_createtime();
}
inline ::google::protobuf::int64 OpenRoomReplaceRecordInfo::createtime() const {
  return createtime_;
}
inline void OpenRoomReplaceRecordInfo::set_createtime(::google::protobuf::int64 value) {
  set_has_createtime();
  createtime_ = value;
}

// required int32 gameId = 5;
inline bool OpenRoomReplaceRecordInfo::has_gameid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OpenRoomReplaceRecordInfo::set_has_gameid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OpenRoomReplaceRecordInfo::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OpenRoomReplaceRecordInfo::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 OpenRoomReplaceRecordInfo::gameid() const {
  return gameid_;
}
inline void OpenRoomReplaceRecordInfo::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 roomType = 6;
inline bool OpenRoomReplaceRecordInfo::has_roomtype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OpenRoomReplaceRecordInfo::set_has_roomtype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OpenRoomReplaceRecordInfo::clear_has_roomtype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OpenRoomReplaceRecordInfo::clear_roomtype() {
  roomtype_ = 0;
  clear_has_roomtype();
}
inline ::google::protobuf::int32 OpenRoomReplaceRecordInfo::roomtype() const {
  return roomtype_;
}
inline void OpenRoomReplaceRecordInfo::set_roomtype(::google::protobuf::int32 value) {
  set_has_roomtype();
  roomtype_ = value;
}

// required int32 timesType = 7;
inline bool OpenRoomReplaceRecordInfo::has_timestype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OpenRoomReplaceRecordInfo::set_has_timestype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OpenRoomReplaceRecordInfo::clear_has_timestype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OpenRoomReplaceRecordInfo::clear_timestype() {
  timestype_ = 0;
  clear_has_timestype();
}
inline ::google::protobuf::int32 OpenRoomReplaceRecordInfo::timestype() const {
  return timestype_;
}
inline void OpenRoomReplaceRecordInfo::set_timestype(::google::protobuf::int32 value) {
  set_has_timestype();
  timestype_ = value;
}

// required int32 totalTime = 8;
inline bool OpenRoomReplaceRecordInfo::has_totaltime() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void OpenRoomReplaceRecordInfo::set_has_totaltime() {
  _has_bits_[0] |= 0x00000080u;
}
inline void OpenRoomReplaceRecordInfo::clear_has_totaltime() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void OpenRoomReplaceRecordInfo::clear_totaltime() {
  totaltime_ = 0;
  clear_has_totaltime();
}
inline ::google::protobuf::int32 OpenRoomReplaceRecordInfo::totaltime() const {
  return totaltime_;
}
inline void OpenRoomReplaceRecordInfo::set_totaltime(::google::protobuf::int32 value) {
  set_has_totaltime();
  totaltime_ = value;
}

// required .ProtoNet.ServerInfoIpsSafeDetail serverInfo = 9;
inline bool OpenRoomReplaceRecordInfo::has_serverinfo() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void OpenRoomReplaceRecordInfo::set_has_serverinfo() {
  _has_bits_[0] |= 0x00000100u;
}
inline void OpenRoomReplaceRecordInfo::clear_has_serverinfo() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void OpenRoomReplaceRecordInfo::clear_serverinfo() {
  if (serverinfo_ != NULL) serverinfo_->::ProtoNet::ServerInfoIpsSafeDetail::Clear();
  clear_has_serverinfo();
}
inline const ::ProtoNet::ServerInfoIpsSafeDetail& OpenRoomReplaceRecordInfo::serverinfo() const {
  return serverinfo_ != NULL ? *serverinfo_ : *default_instance_->serverinfo_;
}
inline ::ProtoNet::ServerInfoIpsSafeDetail* OpenRoomReplaceRecordInfo::mutable_serverinfo() {
  set_has_serverinfo();
  if (serverinfo_ == NULL) serverinfo_ = new ::ProtoNet::ServerInfoIpsSafeDetail;
  return serverinfo_;
}
inline ::ProtoNet::ServerInfoIpsSafeDetail* OpenRoomReplaceRecordInfo::release_serverinfo() {
  clear_has_serverinfo();
  ::ProtoNet::ServerInfoIpsSafeDetail* temp = serverinfo_;
  serverinfo_ = NULL;
  return temp;
}
inline void OpenRoomReplaceRecordInfo::set_allocated_serverinfo(::ProtoNet::ServerInfoIpsSafeDetail* serverinfo) {
  delete serverinfo_;
  serverinfo_ = serverinfo;
  if (serverinfo) {
    set_has_serverinfo();
  } else {
    clear_has_serverinfo();
  }
}

// required int32 totalNum = 10;
inline bool OpenRoomReplaceRecordInfo::has_totalnum() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void OpenRoomReplaceRecordInfo::set_has_totalnum() {
  _has_bits_[0] |= 0x00000200u;
}
inline void OpenRoomReplaceRecordInfo::clear_has_totalnum() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void OpenRoomReplaceRecordInfo::clear_totalnum() {
  totalnum_ = 0;
  clear_has_totalnum();
}
inline ::google::protobuf::int32 OpenRoomReplaceRecordInfo::totalnum() const {
  return totalnum_;
}
inline void OpenRoomReplaceRecordInfo::set_totalnum(::google::protobuf::int32 value) {
  set_has_totalnum();
  totalnum_ = value;
}

// repeated .ProtoNet.ReplaceRecordOver replaceRecordOver = 11;
inline int OpenRoomReplaceRecordInfo::replacerecordover_size() const {
  return replacerecordover_.size();
}
inline void OpenRoomReplaceRecordInfo::clear_replacerecordover() {
  replacerecordover_.Clear();
}
inline const ::ProtoNet::ReplaceRecordOver& OpenRoomReplaceRecordInfo::replacerecordover(int index) const {
  return replacerecordover_.Get(index);
}
inline ::ProtoNet::ReplaceRecordOver* OpenRoomReplaceRecordInfo::mutable_replacerecordover(int index) {
  return replacerecordover_.Mutable(index);
}
inline ::ProtoNet::ReplaceRecordOver* OpenRoomReplaceRecordInfo::add_replacerecordover() {
  return replacerecordover_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::ReplaceRecordOver >&
OpenRoomReplaceRecordInfo::replacerecordover() const {
  return replacerecordover_;
}
inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::ReplaceRecordOver >*
OpenRoomReplaceRecordInfo::mutable_replacerecordover() {
  return &replacerecordover_;
}

// required string jsonParam = 12;
inline bool OpenRoomReplaceRecordInfo::has_jsonparam() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void OpenRoomReplaceRecordInfo::set_has_jsonparam() {
  _has_bits_[0] |= 0x00000800u;
}
inline void OpenRoomReplaceRecordInfo::clear_has_jsonparam() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void OpenRoomReplaceRecordInfo::clear_jsonparam() {
  if (jsonparam_ != &::google::protobuf::internal::kEmptyString) {
    jsonparam_->clear();
  }
  clear_has_jsonparam();
}
inline const ::std::string& OpenRoomReplaceRecordInfo::jsonparam() const {
  return *jsonparam_;
}
inline void OpenRoomReplaceRecordInfo::set_jsonparam(const ::std::string& value) {
  set_has_jsonparam();
  if (jsonparam_ == &::google::protobuf::internal::kEmptyString) {
    jsonparam_ = new ::std::string;
  }
  jsonparam_->assign(value);
}
inline void OpenRoomReplaceRecordInfo::set_jsonparam(const char* value) {
  set_has_jsonparam();
  if (jsonparam_ == &::google::protobuf::internal::kEmptyString) {
    jsonparam_ = new ::std::string;
  }
  jsonparam_->assign(value);
}
inline void OpenRoomReplaceRecordInfo::set_jsonparam(const char* value, size_t size) {
  set_has_jsonparam();
  if (jsonparam_ == &::google::protobuf::internal::kEmptyString) {
    jsonparam_ = new ::std::string;
  }
  jsonparam_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OpenRoomReplaceRecordInfo::mutable_jsonparam() {
  set_has_jsonparam();
  if (jsonparam_ == &::google::protobuf::internal::kEmptyString) {
    jsonparam_ = new ::std::string;
  }
  return jsonparam_;
}
inline ::std::string* OpenRoomReplaceRecordInfo::release_jsonparam() {
  clear_has_jsonparam();
  if (jsonparam_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = jsonparam_;
    jsonparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OpenRoomReplaceRecordInfo::set_allocated_jsonparam(::std::string* jsonparam) {
  if (jsonparam_ != &::google::protobuf::internal::kEmptyString) {
    delete jsonparam_;
  }
  if (jsonparam) {
    set_has_jsonparam();
    jsonparam_ = jsonparam;
  } else {
    clear_has_jsonparam();
    jsonparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 status = 13;
inline bool OpenRoomReplaceRecordInfo::has_status() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void OpenRoomReplaceRecordInfo::set_has_status() {
  _has_bits_[0] |= 0x00001000u;
}
inline void OpenRoomReplaceRecordInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void OpenRoomReplaceRecordInfo::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 OpenRoomReplaceRecordInfo::status() const {
  return status_;
}
inline void OpenRoomReplaceRecordInfo::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// ReplaceRecordOver

// required string uniqueId = 1;
inline bool ReplaceRecordOver::has_uniqueid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReplaceRecordOver::set_has_uniqueid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReplaceRecordOver::clear_has_uniqueid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReplaceRecordOver::clear_uniqueid() {
  if (uniqueid_ != &::google::protobuf::internal::kEmptyString) {
    uniqueid_->clear();
  }
  clear_has_uniqueid();
}
inline const ::std::string& ReplaceRecordOver::uniqueid() const {
  return *uniqueid_;
}
inline void ReplaceRecordOver::set_uniqueid(const ::std::string& value) {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  uniqueid_->assign(value);
}
inline void ReplaceRecordOver::set_uniqueid(const char* value) {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  uniqueid_->assign(value);
}
inline void ReplaceRecordOver::set_uniqueid(const char* value, size_t size) {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  uniqueid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReplaceRecordOver::mutable_uniqueid() {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  return uniqueid_;
}
inline ::std::string* ReplaceRecordOver::release_uniqueid() {
  clear_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uniqueid_;
    uniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReplaceRecordOver::set_allocated_uniqueid(::std::string* uniqueid) {
  if (uniqueid_ != &::google::protobuf::internal::kEmptyString) {
    delete uniqueid_;
  }
  if (uniqueid) {
    set_has_uniqueid();
    uniqueid_ = uniqueid;
  } else {
    clear_has_uniqueid();
    uniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string nick = 2;
inline bool ReplaceRecordOver::has_nick() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReplaceRecordOver::set_has_nick() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReplaceRecordOver::clear_has_nick() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReplaceRecordOver::clear_nick() {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    nick_->clear();
  }
  clear_has_nick();
}
inline const ::std::string& ReplaceRecordOver::nick() const {
  return *nick_;
}
inline void ReplaceRecordOver::set_nick(const ::std::string& value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void ReplaceRecordOver::set_nick(const char* value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void ReplaceRecordOver::set_nick(const char* value, size_t size) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReplaceRecordOver::mutable_nick() {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  return nick_;
}
inline ::std::string* ReplaceRecordOver::release_nick() {
  clear_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nick_;
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReplaceRecordOver::set_allocated_nick(::std::string* nick) {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    delete nick_;
  }
  if (nick) {
    set_has_nick();
    nick_ = nick;
  } else {
    clear_has_nick();
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string headImg = 3;
inline bool ReplaceRecordOver::has_headimg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReplaceRecordOver::set_has_headimg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReplaceRecordOver::clear_has_headimg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReplaceRecordOver::clear_headimg() {
  if (headimg_ != &::google::protobuf::internal::kEmptyString) {
    headimg_->clear();
  }
  clear_has_headimg();
}
inline const ::std::string& ReplaceRecordOver::headimg() const {
  return *headimg_;
}
inline void ReplaceRecordOver::set_headimg(const ::std::string& value) {
  set_has_headimg();
  if (headimg_ == &::google::protobuf::internal::kEmptyString) {
    headimg_ = new ::std::string;
  }
  headimg_->assign(value);
}
inline void ReplaceRecordOver::set_headimg(const char* value) {
  set_has_headimg();
  if (headimg_ == &::google::protobuf::internal::kEmptyString) {
    headimg_ = new ::std::string;
  }
  headimg_->assign(value);
}
inline void ReplaceRecordOver::set_headimg(const char* value, size_t size) {
  set_has_headimg();
  if (headimg_ == &::google::protobuf::internal::kEmptyString) {
    headimg_ = new ::std::string;
  }
  headimg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReplaceRecordOver::mutable_headimg() {
  set_has_headimg();
  if (headimg_ == &::google::protobuf::internal::kEmptyString) {
    headimg_ = new ::std::string;
  }
  return headimg_;
}
inline ::std::string* ReplaceRecordOver::release_headimg() {
  clear_has_headimg();
  if (headimg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = headimg_;
    headimg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReplaceRecordOver::set_allocated_headimg(::std::string* headimg) {
  if (headimg_ != &::google::protobuf::internal::kEmptyString) {
    delete headimg_;
  }
  if (headimg) {
    set_has_headimg();
    headimg_ = headimg;
  } else {
    clear_has_headimg();
    headimg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 head = 4;
inline bool ReplaceRecordOver::has_head() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReplaceRecordOver::set_has_head() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReplaceRecordOver::clear_has_head() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReplaceRecordOver::clear_head() {
  head_ = 0;
  clear_has_head();
}
inline ::google::protobuf::int32 ReplaceRecordOver::head() const {
  return head_;
}
inline void ReplaceRecordOver::set_head(::google::protobuf::int32 value) {
  set_has_head();
  head_ = value;
}

// optional double score = 5;
inline bool ReplaceRecordOver::has_score() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReplaceRecordOver::set_has_score() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReplaceRecordOver::clear_has_score() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReplaceRecordOver::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline double ReplaceRecordOver::score() const {
  return score_;
}
inline void ReplaceRecordOver::set_score(double value) {
  set_has_score();
  score_ = value;
}

// -------------------------------------------------------------------

// TimesInfo

// required int32 timesType = 1;
inline bool TimesInfo::has_timestype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimesInfo::set_has_timestype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimesInfo::clear_has_timestype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimesInfo::clear_timestype() {
  timestype_ = 0;
  clear_has_timestype();
}
inline ::google::protobuf::int32 TimesInfo::timestype() const {
  return timestype_;
}
inline void TimesInfo::set_timestype(::google::protobuf::int32 value) {
  set_has_timestype();
  timestype_ = value;
}

// required string timesName = 2;
inline bool TimesInfo::has_timesname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimesInfo::set_has_timesname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TimesInfo::clear_has_timesname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TimesInfo::clear_timesname() {
  if (timesname_ != &::google::protobuf::internal::kEmptyString) {
    timesname_->clear();
  }
  clear_has_timesname();
}
inline const ::std::string& TimesInfo::timesname() const {
  return *timesname_;
}
inline void TimesInfo::set_timesname(const ::std::string& value) {
  set_has_timesname();
  if (timesname_ == &::google::protobuf::internal::kEmptyString) {
    timesname_ = new ::std::string;
  }
  timesname_->assign(value);
}
inline void TimesInfo::set_timesname(const char* value) {
  set_has_timesname();
  if (timesname_ == &::google::protobuf::internal::kEmptyString) {
    timesname_ = new ::std::string;
  }
  timesname_->assign(value);
}
inline void TimesInfo::set_timesname(const char* value, size_t size) {
  set_has_timesname();
  if (timesname_ == &::google::protobuf::internal::kEmptyString) {
    timesname_ = new ::std::string;
  }
  timesname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TimesInfo::mutable_timesname() {
  set_has_timesname();
  if (timesname_ == &::google::protobuf::internal::kEmptyString) {
    timesname_ = new ::std::string;
  }
  return timesname_;
}
inline ::std::string* TimesInfo::release_timesname() {
  clear_has_timesname();
  if (timesname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = timesname_;
    timesname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TimesInfo::set_allocated_timesname(::std::string* timesname) {
  if (timesname_ != &::google::protobuf::internal::kEmptyString) {
    delete timesname_;
  }
  if (timesname) {
    set_has_timesname();
    timesname_ = timesname;
  } else {
    clear_has_timesname();
    timesname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required double minNeed = 3;
inline bool TimesInfo::has_minneed() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TimesInfo::set_has_minneed() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TimesInfo::clear_has_minneed() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TimesInfo::clear_minneed() {
  minneed_ = 0;
  clear_has_minneed();
}
inline double TimesInfo::minneed() const {
  return minneed_;
}
inline void TimesInfo::set_minneed(double value) {
  set_has_minneed();
  minneed_ = value;
}

// required double yazhu = 4;
inline bool TimesInfo::has_yazhu() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TimesInfo::set_has_yazhu() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TimesInfo::clear_has_yazhu() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TimesInfo::clear_yazhu() {
  yazhu_ = 0;
  clear_has_yazhu();
}
inline double TimesInfo::yazhu() const {
  return yazhu_;
}
inline void TimesInfo::set_yazhu(double value) {
  set_has_yazhu();
  yazhu_ = value;
}

// required int32 atype = 5;
inline bool TimesInfo::has_atype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TimesInfo::set_has_atype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TimesInfo::clear_has_atype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TimesInfo::clear_atype() {
  atype_ = 0;
  clear_has_atype();
}
inline ::google::protobuf::int32 TimesInfo::atype() const {
  return atype_;
}
inline void TimesInfo::set_atype(::google::protobuf::int32 value) {
  set_has_atype();
  atype_ = value;
}

// required int32 roomType = 6;
inline bool TimesInfo::has_roomtype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TimesInfo::set_has_roomtype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TimesInfo::clear_has_roomtype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TimesInfo::clear_roomtype() {
  roomtype_ = 0;
  clear_has_roomtype();
}
inline ::google::protobuf::int32 TimesInfo::roomtype() const {
  return roomtype_;
}
inline void TimesInfo::set_roomtype(::google::protobuf::int32 value) {
  set_has_roomtype();
  roomtype_ = value;
}

// optional string extendStr = 7;
inline bool TimesInfo::has_extendstr() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TimesInfo::set_has_extendstr() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TimesInfo::clear_has_extendstr() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TimesInfo::clear_extendstr() {
  if (extendstr_ != &::google::protobuf::internal::kEmptyString) {
    extendstr_->clear();
  }
  clear_has_extendstr();
}
inline const ::std::string& TimesInfo::extendstr() const {
  return *extendstr_;
}
inline void TimesInfo::set_extendstr(const ::std::string& value) {
  set_has_extendstr();
  if (extendstr_ == &::google::protobuf::internal::kEmptyString) {
    extendstr_ = new ::std::string;
  }
  extendstr_->assign(value);
}
inline void TimesInfo::set_extendstr(const char* value) {
  set_has_extendstr();
  if (extendstr_ == &::google::protobuf::internal::kEmptyString) {
    extendstr_ = new ::std::string;
  }
  extendstr_->assign(value);
}
inline void TimesInfo::set_extendstr(const char* value, size_t size) {
  set_has_extendstr();
  if (extendstr_ == &::google::protobuf::internal::kEmptyString) {
    extendstr_ = new ::std::string;
  }
  extendstr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TimesInfo::mutable_extendstr() {
  set_has_extendstr();
  if (extendstr_ == &::google::protobuf::internal::kEmptyString) {
    extendstr_ = new ::std::string;
  }
  return extendstr_;
}
inline ::std::string* TimesInfo::release_extendstr() {
  clear_has_extendstr();
  if (extendstr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extendstr_;
    extendstr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TimesInfo::set_allocated_extendstr(::std::string* extendstr) {
  if (extendstr_ != &::google::protobuf::internal::kEmptyString) {
    delete extendstr_;
  }
  if (extendstr) {
    set_has_extendstr();
    extendstr_ = extendstr;
  } else {
    clear_has_extendstr();
    extendstr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ReqGateLogin

// required int32 playerId = 1;
inline bool ReqGateLogin::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqGateLogin::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqGateLogin::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqGateLogin::clear_playerid() {
  playerid_ = 0;
  clear_has_playerid();
}
inline ::google::protobuf::int32 ReqGateLogin::playerid() const {
  return playerid_;
}
inline void ReqGateLogin::set_playerid(::google::protobuf::int32 value) {
  set_has_playerid();
  playerid_ = value;
}

// required string ticket = 2;
inline bool ReqGateLogin::has_ticket() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqGateLogin::set_has_ticket() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqGateLogin::clear_has_ticket() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqGateLogin::clear_ticket() {
  if (ticket_ != &::google::protobuf::internal::kEmptyString) {
    ticket_->clear();
  }
  clear_has_ticket();
}
inline const ::std::string& ReqGateLogin::ticket() const {
  return *ticket_;
}
inline void ReqGateLogin::set_ticket(const ::std::string& value) {
  set_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    ticket_ = new ::std::string;
  }
  ticket_->assign(value);
}
inline void ReqGateLogin::set_ticket(const char* value) {
  set_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    ticket_ = new ::std::string;
  }
  ticket_->assign(value);
}
inline void ReqGateLogin::set_ticket(const char* value, size_t size) {
  set_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    ticket_ = new ::std::string;
  }
  ticket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqGateLogin::mutable_ticket() {
  set_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    ticket_ = new ::std::string;
  }
  return ticket_;
}
inline ::std::string* ReqGateLogin::release_ticket() {
  clear_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ticket_;
    ticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqGateLogin::set_allocated_ticket(::std::string* ticket) {
  if (ticket_ != &::google::protobuf::internal::kEmptyString) {
    delete ticket_;
  }
  if (ticket) {
    set_has_ticket();
    ticket_ = ticket;
  } else {
    clear_has_ticket();
    ticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string evironment = 3;
inline bool ReqGateLogin::has_evironment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqGateLogin::set_has_evironment() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqGateLogin::clear_has_evironment() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqGateLogin::clear_evironment() {
  if (evironment_ != &::google::protobuf::internal::kEmptyString) {
    evironment_->clear();
  }
  clear_has_evironment();
}
inline const ::std::string& ReqGateLogin::evironment() const {
  return *evironment_;
}
inline void ReqGateLogin::set_evironment(const ::std::string& value) {
  set_has_evironment();
  if (evironment_ == &::google::protobuf::internal::kEmptyString) {
    evironment_ = new ::std::string;
  }
  evironment_->assign(value);
}
inline void ReqGateLogin::set_evironment(const char* value) {
  set_has_evironment();
  if (evironment_ == &::google::protobuf::internal::kEmptyString) {
    evironment_ = new ::std::string;
  }
  evironment_->assign(value);
}
inline void ReqGateLogin::set_evironment(const char* value, size_t size) {
  set_has_evironment();
  if (evironment_ == &::google::protobuf::internal::kEmptyString) {
    evironment_ = new ::std::string;
  }
  evironment_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqGateLogin::mutable_evironment() {
  set_has_evironment();
  if (evironment_ == &::google::protobuf::internal::kEmptyString) {
    evironment_ = new ::std::string;
  }
  return evironment_;
}
inline ::std::string* ReqGateLogin::release_evironment() {
  clear_has_evironment();
  if (evironment_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = evironment_;
    evironment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqGateLogin::set_allocated_evironment(::std::string* evironment) {
  if (evironment_ != &::google::protobuf::internal::kEmptyString) {
    delete evironment_;
  }
  if (evironment) {
    set_has_evironment();
    evironment_ = evironment;
  } else {
    clear_has_evironment();
    evironment_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ResGateLogin

// required .ProtoNet.ResponseResult result = 1;
inline bool ResGateLogin::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResGateLogin::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResGateLogin::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResGateLogin::clear_result() {
  if (result_ != NULL) result_->::ProtoNet::ResponseResult::Clear();
  clear_has_result();
}
inline const ::ProtoNet::ResponseResult& ResGateLogin::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::ProtoNet::ResponseResult* ResGateLogin::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::ProtoNet::ResponseResult;
  return result_;
}
inline ::ProtoNet::ResponseResult* ResGateLogin::release_result() {
  clear_has_result();
  ::ProtoNet::ResponseResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline void ResGateLogin::set_allocated_result(::ProtoNet::ResponseResult* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// -------------------------------------------------------------------

// ReqGetAccountInfo

// required int32 playerId = 1;
inline bool ReqGetAccountInfo::has_playerid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqGetAccountInfo::set_has_playerid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqGetAccountInfo::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqGetAccountInfo::clear_playerid() {
  playerid_ = 0;
  clear_has_playerid();
}
inline ::google::protobuf::int32 ReqGetAccountInfo::playerid() const {
  return playerid_;
}
inline void ReqGetAccountInfo::set_playerid(::google::protobuf::int32 value) {
  set_has_playerid();
  playerid_ = value;
}

// -------------------------------------------------------------------

// ResGetAccountInfo

// required .ProtoNet.ResponseResult result = 1;
inline bool ResGetAccountInfo::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResGetAccountInfo::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResGetAccountInfo::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResGetAccountInfo::clear_result() {
  if (result_ != NULL) result_->::ProtoNet::ResponseResult::Clear();
  clear_has_result();
}
inline const ::ProtoNet::ResponseResult& ResGetAccountInfo::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::ProtoNet::ResponseResult* ResGetAccountInfo::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::ProtoNet::ResponseResult;
  return result_;
}
inline ::ProtoNet::ResponseResult* ResGetAccountInfo::release_result() {
  clear_has_result();
  ::ProtoNet::ResponseResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline void ResGetAccountInfo::set_allocated_result(::ProtoNet::ResponseResult* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// optional .ProtoNet.AccountInfo accountInfo = 2;
inline bool ResGetAccountInfo::has_accountinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResGetAccountInfo::set_has_accountinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResGetAccountInfo::clear_has_accountinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResGetAccountInfo::clear_accountinfo() {
  if (accountinfo_ != NULL) accountinfo_->::ProtoNet::AccountInfo::Clear();
  clear_has_accountinfo();
}
inline const ::ProtoNet::AccountInfo& ResGetAccountInfo::accountinfo() const {
  return accountinfo_ != NULL ? *accountinfo_ : *default_instance_->accountinfo_;
}
inline ::ProtoNet::AccountInfo* ResGetAccountInfo::mutable_accountinfo() {
  set_has_accountinfo();
  if (accountinfo_ == NULL) accountinfo_ = new ::ProtoNet::AccountInfo;
  return accountinfo_;
}
inline ::ProtoNet::AccountInfo* ResGetAccountInfo::release_accountinfo() {
  clear_has_accountinfo();
  ::ProtoNet::AccountInfo* temp = accountinfo_;
  accountinfo_ = NULL;
  return temp;
}
inline void ResGetAccountInfo::set_allocated_accountinfo(::ProtoNet::AccountInfo* accountinfo) {
  delete accountinfo_;
  accountinfo_ = accountinfo;
  if (accountinfo) {
    set_has_accountinfo();
  } else {
    clear_has_accountinfo();
  }
}

// -------------------------------------------------------------------

// ReqGetGameZoneInfoList

// -------------------------------------------------------------------

// ResGetGameZoneInfoList

// required .ProtoNet.ResponseResult result = 1;
inline bool ResGetGameZoneInfoList::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResGetGameZoneInfoList::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResGetGameZoneInfoList::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResGetGameZoneInfoList::clear_result() {
  if (result_ != NULL) result_->::ProtoNet::ResponseResult::Clear();
  clear_has_result();
}
inline const ::ProtoNet::ResponseResult& ResGetGameZoneInfoList::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::ProtoNet::ResponseResult* ResGetGameZoneInfoList::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::ProtoNet::ResponseResult;
  return result_;
}
inline ::ProtoNet::ResponseResult* ResGetGameZoneInfoList::release_result() {
  clear_has_result();
  ::ProtoNet::ResponseResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline void ResGetGameZoneInfoList::set_allocated_result(::ProtoNet::ResponseResult* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// repeated .ProtoNet.GameZoneInfo gameZoneInfos = 2;
inline int ResGetGameZoneInfoList::gamezoneinfos_size() const {
  return gamezoneinfos_.size();
}
inline void ResGetGameZoneInfoList::clear_gamezoneinfos() {
  gamezoneinfos_.Clear();
}
inline const ::ProtoNet::GameZoneInfo& ResGetGameZoneInfoList::gamezoneinfos(int index) const {
  return gamezoneinfos_.Get(index);
}
inline ::ProtoNet::GameZoneInfo* ResGetGameZoneInfoList::mutable_gamezoneinfos(int index) {
  return gamezoneinfos_.Mutable(index);
}
inline ::ProtoNet::GameZoneInfo* ResGetGameZoneInfoList::add_gamezoneinfos() {
  return gamezoneinfos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::GameZoneInfo >&
ResGetGameZoneInfoList::gamezoneinfos() const {
  return gamezoneinfos_;
}
inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::GameZoneInfo >*
ResGetGameZoneInfoList::mutable_gamezoneinfos() {
  return &gamezoneinfos_;
}

// -------------------------------------------------------------------

// ReqGetGameZoneDetail

// required int32 gameId = 1;
inline bool ReqGetGameZoneDetail::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqGetGameZoneDetail::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqGetGameZoneDetail::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqGetGameZoneDetail::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 ReqGetGameZoneDetail::gameid() const {
  return gameid_;
}
inline void ReqGetGameZoneDetail::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 roomType = 2;
inline bool ReqGetGameZoneDetail::has_roomtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqGetGameZoneDetail::set_has_roomtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqGetGameZoneDetail::clear_has_roomtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqGetGameZoneDetail::clear_roomtype() {
  roomtype_ = 0;
  clear_has_roomtype();
}
inline ::google::protobuf::int32 ReqGetGameZoneDetail::roomtype() const {
  return roomtype_;
}
inline void ReqGetGameZoneDetail::set_roomtype(::google::protobuf::int32 value) {
  set_has_roomtype();
  roomtype_ = value;
}

// -------------------------------------------------------------------

// ResGetGameZoneDetail

// required .ProtoNet.ResponseResult result = 1;
inline bool ResGetGameZoneDetail::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResGetGameZoneDetail::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResGetGameZoneDetail::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResGetGameZoneDetail::clear_result() {
  if (result_ != NULL) result_->::ProtoNet::ResponseResult::Clear();
  clear_has_result();
}
inline const ::ProtoNet::ResponseResult& ResGetGameZoneDetail::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::ProtoNet::ResponseResult* ResGetGameZoneDetail::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::ProtoNet::ResponseResult;
  return result_;
}
inline ::ProtoNet::ResponseResult* ResGetGameZoneDetail::release_result() {
  clear_has_result();
  ::ProtoNet::ResponseResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline void ResGetGameZoneDetail::set_allocated_result(::ProtoNet::ResponseResult* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// optional int32 gameId = 2;
inline bool ResGetGameZoneDetail::has_gameid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResGetGameZoneDetail::set_has_gameid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResGetGameZoneDetail::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResGetGameZoneDetail::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 ResGetGameZoneDetail::gameid() const {
  return gameid_;
}
inline void ResGetGameZoneDetail::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// repeated .ProtoNet.ServerInfoIpsSafeDetail logicDetails = 3;
inline int ResGetGameZoneDetail::logicdetails_size() const {
  return logicdetails_.size();
}
inline void ResGetGameZoneDetail::clear_logicdetails() {
  logicdetails_.Clear();
}
inline const ::ProtoNet::ServerInfoIpsSafeDetail& ResGetGameZoneDetail::logicdetails(int index) const {
  return logicdetails_.Get(index);
}
inline ::ProtoNet::ServerInfoIpsSafeDetail* ResGetGameZoneDetail::mutable_logicdetails(int index) {
  return logicdetails_.Mutable(index);
}
inline ::ProtoNet::ServerInfoIpsSafeDetail* ResGetGameZoneDetail::add_logicdetails() {
  return logicdetails_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::ServerInfoIpsSafeDetail >&
ResGetGameZoneDetail::logicdetails() const {
  return logicdetails_;
}
inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::ServerInfoIpsSafeDetail >*
ResGetGameZoneDetail::mutable_logicdetails() {
  return &logicdetails_;
}

// repeated .ProtoNet.TimesInfo timesInfos = 4;
inline int ResGetGameZoneDetail::timesinfos_size() const {
  return timesinfos_.size();
}
inline void ResGetGameZoneDetail::clear_timesinfos() {
  timesinfos_.Clear();
}
inline const ::ProtoNet::TimesInfo& ResGetGameZoneDetail::timesinfos(int index) const {
  return timesinfos_.Get(index);
}
inline ::ProtoNet::TimesInfo* ResGetGameZoneDetail::mutable_timesinfos(int index) {
  return timesinfos_.Mutable(index);
}
inline ::ProtoNet::TimesInfo* ResGetGameZoneDetail::add_timesinfos() {
  return timesinfos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::TimesInfo >&
ResGetGameZoneDetail::timesinfos() const {
  return timesinfos_;
}
inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::TimesInfo >*
ResGetGameZoneDetail::mutable_timesinfos() {
  return &timesinfos_;
}

// -------------------------------------------------------------------

// ReqJoinLogicGameRoom

// required string roomId = 1;
inline bool ReqJoinLogicGameRoom::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqJoinLogicGameRoom::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqJoinLogicGameRoom::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqJoinLogicGameRoom::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& ReqJoinLogicGameRoom::roomid() const {
  return *roomid_;
}
inline void ReqJoinLogicGameRoom::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ReqJoinLogicGameRoom::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ReqJoinLogicGameRoom::set_roomid(const char* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqJoinLogicGameRoom::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  return roomid_;
}
inline ::std::string* ReqJoinLogicGameRoom::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqJoinLogicGameRoom::set_allocated_roomid(::std::string* roomid) {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomid_;
  }
  if (roomid) {
    set_has_roomid();
    roomid_ = roomid;
  } else {
    clear_has_roomid();
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ResJoinLogicGameRoom

// required .ProtoNet.ResponseResult result = 1;
inline bool ResJoinLogicGameRoom::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResJoinLogicGameRoom::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResJoinLogicGameRoom::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResJoinLogicGameRoom::clear_result() {
  if (result_ != NULL) result_->::ProtoNet::ResponseResult::Clear();
  clear_has_result();
}
inline const ::ProtoNet::ResponseResult& ResJoinLogicGameRoom::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::ProtoNet::ResponseResult* ResJoinLogicGameRoom::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::ProtoNet::ResponseResult;
  return result_;
}
inline ::ProtoNet::ResponseResult* ResJoinLogicGameRoom::release_result() {
  clear_has_result();
  ::ProtoNet::ResponseResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline void ResJoinLogicGameRoom::set_allocated_result(::ProtoNet::ResponseResult* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// optional .ProtoNet.ServerInfoIpsSafeDetail bestServerInfo = 2;
inline bool ResJoinLogicGameRoom::has_bestserverinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResJoinLogicGameRoom::set_has_bestserverinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResJoinLogicGameRoom::clear_has_bestserverinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResJoinLogicGameRoom::clear_bestserverinfo() {
  if (bestserverinfo_ != NULL) bestserverinfo_->::ProtoNet::ServerInfoIpsSafeDetail::Clear();
  clear_has_bestserverinfo();
}
inline const ::ProtoNet::ServerInfoIpsSafeDetail& ResJoinLogicGameRoom::bestserverinfo() const {
  return bestserverinfo_ != NULL ? *bestserverinfo_ : *default_instance_->bestserverinfo_;
}
inline ::ProtoNet::ServerInfoIpsSafeDetail* ResJoinLogicGameRoom::mutable_bestserverinfo() {
  set_has_bestserverinfo();
  if (bestserverinfo_ == NULL) bestserverinfo_ = new ::ProtoNet::ServerInfoIpsSafeDetail;
  return bestserverinfo_;
}
inline ::ProtoNet::ServerInfoIpsSafeDetail* ResJoinLogicGameRoom::release_bestserverinfo() {
  clear_has_bestserverinfo();
  ::ProtoNet::ServerInfoIpsSafeDetail* temp = bestserverinfo_;
  bestserverinfo_ = NULL;
  return temp;
}
inline void ResJoinLogicGameRoom::set_allocated_bestserverinfo(::ProtoNet::ServerInfoIpsSafeDetail* bestserverinfo) {
  delete bestserverinfo_;
  bestserverinfo_ = bestserverinfo;
  if (bestserverinfo) {
    set_has_bestserverinfo();
  } else {
    clear_has_bestserverinfo();
  }
}

// optional int32 gameId = 3;
inline bool ResJoinLogicGameRoom::has_gameid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResJoinLogicGameRoom::set_has_gameid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResJoinLogicGameRoom::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResJoinLogicGameRoom::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 ResJoinLogicGameRoom::gameid() const {
  return gameid_;
}
inline void ResJoinLogicGameRoom::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional int32 roomType = 4;
inline bool ResJoinLogicGameRoom::has_roomtype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResJoinLogicGameRoom::set_has_roomtype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResJoinLogicGameRoom::clear_has_roomtype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResJoinLogicGameRoom::clear_roomtype() {
  roomtype_ = 0;
  clear_has_roomtype();
}
inline ::google::protobuf::int32 ResJoinLogicGameRoom::roomtype() const {
  return roomtype_;
}
inline void ResJoinLogicGameRoom::set_roomtype(::google::protobuf::int32 value) {
  set_has_roomtype();
  roomtype_ = value;
}

// optional int32 timesType = 5;
inline bool ResJoinLogicGameRoom::has_timestype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResJoinLogicGameRoom::set_has_timestype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResJoinLogicGameRoom::clear_has_timestype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResJoinLogicGameRoom::clear_timestype() {
  timestype_ = 0;
  clear_has_timestype();
}
inline ::google::protobuf::int32 ResJoinLogicGameRoom::timestype() const {
  return timestype_;
}
inline void ResJoinLogicGameRoom::set_timestype(::google::protobuf::int32 value) {
  set_has_timestype();
  timestype_ = value;
}

// -------------------------------------------------------------------

// ReqQuickJoinGameRoom

// required int32 gameId = 1;
inline bool ReqQuickJoinGameRoom::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqQuickJoinGameRoom::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqQuickJoinGameRoom::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqQuickJoinGameRoom::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 ReqQuickJoinGameRoom::gameid() const {
  return gameid_;
}
inline void ReqQuickJoinGameRoom::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 roomType = 2;
inline bool ReqQuickJoinGameRoom::has_roomtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqQuickJoinGameRoom::set_has_roomtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqQuickJoinGameRoom::clear_has_roomtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqQuickJoinGameRoom::clear_roomtype() {
  roomtype_ = 0;
  clear_has_roomtype();
}
inline ::google::protobuf::int32 ReqQuickJoinGameRoom::roomtype() const {
  return roomtype_;
}
inline void ReqQuickJoinGameRoom::set_roomtype(::google::protobuf::int32 value) {
  set_has_roomtype();
  roomtype_ = value;
}

// required int32 timesType = 3;
inline bool ReqQuickJoinGameRoom::has_timestype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqQuickJoinGameRoom::set_has_timestype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqQuickJoinGameRoom::clear_has_timestype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqQuickJoinGameRoom::clear_timestype() {
  timestype_ = 0;
  clear_has_timestype();
}
inline ::google::protobuf::int32 ReqQuickJoinGameRoom::timestype() const {
  return timestype_;
}
inline void ReqQuickJoinGameRoom::set_timestype(::google::protobuf::int32 value) {
  set_has_timestype();
  timestype_ = value;
}

// optional string pipeiParam = 4;
inline bool ReqQuickJoinGameRoom::has_pipeiparam() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqQuickJoinGameRoom::set_has_pipeiparam() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqQuickJoinGameRoom::clear_has_pipeiparam() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqQuickJoinGameRoom::clear_pipeiparam() {
  if (pipeiparam_ != &::google::protobuf::internal::kEmptyString) {
    pipeiparam_->clear();
  }
  clear_has_pipeiparam();
}
inline const ::std::string& ReqQuickJoinGameRoom::pipeiparam() const {
  return *pipeiparam_;
}
inline void ReqQuickJoinGameRoom::set_pipeiparam(const ::std::string& value) {
  set_has_pipeiparam();
  if (pipeiparam_ == &::google::protobuf::internal::kEmptyString) {
    pipeiparam_ = new ::std::string;
  }
  pipeiparam_->assign(value);
}
inline void ReqQuickJoinGameRoom::set_pipeiparam(const char* value) {
  set_has_pipeiparam();
  if (pipeiparam_ == &::google::protobuf::internal::kEmptyString) {
    pipeiparam_ = new ::std::string;
  }
  pipeiparam_->assign(value);
}
inline void ReqQuickJoinGameRoom::set_pipeiparam(const char* value, size_t size) {
  set_has_pipeiparam();
  if (pipeiparam_ == &::google::protobuf::internal::kEmptyString) {
    pipeiparam_ = new ::std::string;
  }
  pipeiparam_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqQuickJoinGameRoom::mutable_pipeiparam() {
  set_has_pipeiparam();
  if (pipeiparam_ == &::google::protobuf::internal::kEmptyString) {
    pipeiparam_ = new ::std::string;
  }
  return pipeiparam_;
}
inline ::std::string* ReqQuickJoinGameRoom::release_pipeiparam() {
  clear_has_pipeiparam();
  if (pipeiparam_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pipeiparam_;
    pipeiparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqQuickJoinGameRoom::set_allocated_pipeiparam(::std::string* pipeiparam) {
  if (pipeiparam_ != &::google::protobuf::internal::kEmptyString) {
    delete pipeiparam_;
  }
  if (pipeiparam) {
    set_has_pipeiparam();
    pipeiparam_ = pipeiparam;
  } else {
    clear_has_pipeiparam();
    pipeiparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ResQuickJoinGameRoom

// required .ProtoNet.ResponseResult result = 1;
inline bool ResQuickJoinGameRoom::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResQuickJoinGameRoom::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResQuickJoinGameRoom::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResQuickJoinGameRoom::clear_result() {
  if (result_ != NULL) result_->::ProtoNet::ResponseResult::Clear();
  clear_has_result();
}
inline const ::ProtoNet::ResponseResult& ResQuickJoinGameRoom::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::ProtoNet::ResponseResult* ResQuickJoinGameRoom::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::ProtoNet::ResponseResult;
  return result_;
}
inline ::ProtoNet::ResponseResult* ResQuickJoinGameRoom::release_result() {
  clear_has_result();
  ::ProtoNet::ResponseResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline void ResQuickJoinGameRoom::set_allocated_result(::ProtoNet::ResponseResult* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// optional int32 operate = 2;
inline bool ResQuickJoinGameRoom::has_operate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResQuickJoinGameRoom::set_has_operate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResQuickJoinGameRoom::clear_has_operate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResQuickJoinGameRoom::clear_operate() {
  operate_ = 0;
  clear_has_operate();
}
inline ::google::protobuf::int32 ResQuickJoinGameRoom::operate() const {
  return operate_;
}
inline void ResQuickJoinGameRoom::set_operate(::google::protobuf::int32 value) {
  set_has_operate();
  operate_ = value;
}

// optional int32 roomType = 3;
inline bool ResQuickJoinGameRoom::has_roomtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResQuickJoinGameRoom::set_has_roomtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResQuickJoinGameRoom::clear_has_roomtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResQuickJoinGameRoom::clear_roomtype() {
  roomtype_ = 0;
  clear_has_roomtype();
}
inline ::google::protobuf::int32 ResQuickJoinGameRoom::roomtype() const {
  return roomtype_;
}
inline void ResQuickJoinGameRoom::set_roomtype(::google::protobuf::int32 value) {
  set_has_roomtype();
  roomtype_ = value;
}

// optional .ProtoNet.ServerInfoIpsSafeDetail bestServerInfo = 4;
inline bool ResQuickJoinGameRoom::has_bestserverinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResQuickJoinGameRoom::set_has_bestserverinfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResQuickJoinGameRoom::clear_has_bestserverinfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResQuickJoinGameRoom::clear_bestserverinfo() {
  if (bestserverinfo_ != NULL) bestserverinfo_->::ProtoNet::ServerInfoIpsSafeDetail::Clear();
  clear_has_bestserverinfo();
}
inline const ::ProtoNet::ServerInfoIpsSafeDetail& ResQuickJoinGameRoom::bestserverinfo() const {
  return bestserverinfo_ != NULL ? *bestserverinfo_ : *default_instance_->bestserverinfo_;
}
inline ::ProtoNet::ServerInfoIpsSafeDetail* ResQuickJoinGameRoom::mutable_bestserverinfo() {
  set_has_bestserverinfo();
  if (bestserverinfo_ == NULL) bestserverinfo_ = new ::ProtoNet::ServerInfoIpsSafeDetail;
  return bestserverinfo_;
}
inline ::ProtoNet::ServerInfoIpsSafeDetail* ResQuickJoinGameRoom::release_bestserverinfo() {
  clear_has_bestserverinfo();
  ::ProtoNet::ServerInfoIpsSafeDetail* temp = bestserverinfo_;
  bestserverinfo_ = NULL;
  return temp;
}
inline void ResQuickJoinGameRoom::set_allocated_bestserverinfo(::ProtoNet::ServerInfoIpsSafeDetail* bestserverinfo) {
  delete bestserverinfo_;
  bestserverinfo_ = bestserverinfo;
  if (bestserverinfo) {
    set_has_bestserverinfo();
  } else {
    clear_has_bestserverinfo();
  }
}

// optional string roomId = 5;
inline bool ResQuickJoinGameRoom::has_roomid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResQuickJoinGameRoom::set_has_roomid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResQuickJoinGameRoom::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResQuickJoinGameRoom::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& ResQuickJoinGameRoom::roomid() const {
  return *roomid_;
}
inline void ResQuickJoinGameRoom::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ResQuickJoinGameRoom::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ResQuickJoinGameRoom::set_roomid(const char* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResQuickJoinGameRoom::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  return roomid_;
}
inline ::std::string* ResQuickJoinGameRoom::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResQuickJoinGameRoom::set_allocated_roomid(::std::string* roomid) {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomid_;
  }
  if (roomid) {
    set_has_roomid();
    roomid_ = roomid;
  } else {
    clear_has_roomid();
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .ProtoNet.ServerInfoIpsSafeDetail logicDetails = 6;
inline int ResQuickJoinGameRoom::logicdetails_size() const {
  return logicdetails_.size();
}
inline void ResQuickJoinGameRoom::clear_logicdetails() {
  logicdetails_.Clear();
}
inline const ::ProtoNet::ServerInfoIpsSafeDetail& ResQuickJoinGameRoom::logicdetails(int index) const {
  return logicdetails_.Get(index);
}
inline ::ProtoNet::ServerInfoIpsSafeDetail* ResQuickJoinGameRoom::mutable_logicdetails(int index) {
  return logicdetails_.Mutable(index);
}
inline ::ProtoNet::ServerInfoIpsSafeDetail* ResQuickJoinGameRoom::add_logicdetails() {
  return logicdetails_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::ServerInfoIpsSafeDetail >&
ResQuickJoinGameRoom::logicdetails() const {
  return logicdetails_;
}
inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::ServerInfoIpsSafeDetail >*
ResQuickJoinGameRoom::mutable_logicdetails() {
  return &logicdetails_;
}

// optional int32 gameId = 7;
inline bool ResQuickJoinGameRoom::has_gameid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ResQuickJoinGameRoom::set_has_gameid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ResQuickJoinGameRoom::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ResQuickJoinGameRoom::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 ResQuickJoinGameRoom::gameid() const {
  return gameid_;
}
inline void ResQuickJoinGameRoom::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional int32 timesType = 8;
inline bool ResQuickJoinGameRoom::has_timestype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ResQuickJoinGameRoom::set_has_timestype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ResQuickJoinGameRoom::clear_has_timestype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ResQuickJoinGameRoom::clear_timestype() {
  timestype_ = 0;
  clear_has_timestype();
}
inline ::google::protobuf::int32 ResQuickJoinGameRoom::timestype() const {
  return timestype_;
}
inline void ResQuickJoinGameRoom::set_timestype(::google::protobuf::int32 value) {
  set_has_timestype();
  timestype_ = value;
}

// -------------------------------------------------------------------

// ResNotifyBroadPlatMarquee

// required int32 type = 1;
inline bool ResNotifyBroadPlatMarquee::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResNotifyBroadPlatMarquee::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResNotifyBroadPlatMarquee::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResNotifyBroadPlatMarquee::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ResNotifyBroadPlatMarquee::type() const {
  return type_;
}
inline void ResNotifyBroadPlatMarquee::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required string msg = 2;
inline bool ResNotifyBroadPlatMarquee::has_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResNotifyBroadPlatMarquee::set_has_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResNotifyBroadPlatMarquee::clear_has_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResNotifyBroadPlatMarquee::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& ResNotifyBroadPlatMarquee::msg() const {
  return *msg_;
}
inline void ResNotifyBroadPlatMarquee::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void ResNotifyBroadPlatMarquee::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void ResNotifyBroadPlatMarquee::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResNotifyBroadPlatMarquee::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* ResNotifyBroadPlatMarquee::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResNotifyBroadPlatMarquee::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 count = 3;
inline bool ResNotifyBroadPlatMarquee::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResNotifyBroadPlatMarquee::set_has_count() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResNotifyBroadPlatMarquee::clear_has_count() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResNotifyBroadPlatMarquee::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 ResNotifyBroadPlatMarquee::count() const {
  return count_;
}
inline void ResNotifyBroadPlatMarquee::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// ResNotifySelfDataChange

// required .ProtoNet.AccountInfo accountInfo = 1;
inline bool ResNotifySelfDataChange::has_accountinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResNotifySelfDataChange::set_has_accountinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResNotifySelfDataChange::clear_has_accountinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResNotifySelfDataChange::clear_accountinfo() {
  if (accountinfo_ != NULL) accountinfo_->::ProtoNet::AccountInfo::Clear();
  clear_has_accountinfo();
}
inline const ::ProtoNet::AccountInfo& ResNotifySelfDataChange::accountinfo() const {
  return accountinfo_ != NULL ? *accountinfo_ : *default_instance_->accountinfo_;
}
inline ::ProtoNet::AccountInfo* ResNotifySelfDataChange::mutable_accountinfo() {
  set_has_accountinfo();
  if (accountinfo_ == NULL) accountinfo_ = new ::ProtoNet::AccountInfo;
  return accountinfo_;
}
inline ::ProtoNet::AccountInfo* ResNotifySelfDataChange::release_accountinfo() {
  clear_has_accountinfo();
  ::ProtoNet::AccountInfo* temp = accountinfo_;
  accountinfo_ = NULL;
  return temp;
}
inline void ResNotifySelfDataChange::set_allocated_accountinfo(::ProtoNet::AccountInfo* accountinfo) {
  delete accountinfo_;
  accountinfo_ = accountinfo;
  if (accountinfo) {
    set_has_accountinfo();
  } else {
    clear_has_accountinfo();
  }
}

// optional int32 charge = 2;
inline bool ResNotifySelfDataChange::has_charge() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResNotifySelfDataChange::set_has_charge() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResNotifySelfDataChange::clear_has_charge() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResNotifySelfDataChange::clear_charge() {
  charge_ = 0;
  clear_has_charge();
}
inline ::google::protobuf::int32 ResNotifySelfDataChange::charge() const {
  return charge_;
}
inline void ResNotifySelfDataChange::set_charge(::google::protobuf::int32 value) {
  set_has_charge();
  charge_ = value;
}

// -------------------------------------------------------------------

// ReqGetRoomBrifeList

// required int32 gameId = 1;
inline bool ReqGetRoomBrifeList::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqGetRoomBrifeList::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqGetRoomBrifeList::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqGetRoomBrifeList::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 ReqGetRoomBrifeList::gameid() const {
  return gameid_;
}
inline void ReqGetRoomBrifeList::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// -------------------------------------------------------------------

// ResGetRoomBrifeList

// required .ProtoNet.ResponseResult result = 1;
inline bool ResGetRoomBrifeList::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResGetRoomBrifeList::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResGetRoomBrifeList::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResGetRoomBrifeList::clear_result() {
  if (result_ != NULL) result_->::ProtoNet::ResponseResult::Clear();
  clear_has_result();
}
inline const ::ProtoNet::ResponseResult& ResGetRoomBrifeList::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::ProtoNet::ResponseResult* ResGetRoomBrifeList::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::ProtoNet::ResponseResult;
  return result_;
}
inline ::ProtoNet::ResponseResult* ResGetRoomBrifeList::release_result() {
  clear_has_result();
  ::ProtoNet::ResponseResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline void ResGetRoomBrifeList::set_allocated_result(::ProtoNet::ResponseResult* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// repeated .ProtoNet.GoldRoomServerInfos goldRoomServerInfos = 2;
inline int ResGetRoomBrifeList::goldroomserverinfos_size() const {
  return goldroomserverinfos_.size();
}
inline void ResGetRoomBrifeList::clear_goldroomserverinfos() {
  goldroomserverinfos_.Clear();
}
inline const ::ProtoNet::GoldRoomServerInfos& ResGetRoomBrifeList::goldroomserverinfos(int index) const {
  return goldroomserverinfos_.Get(index);
}
inline ::ProtoNet::GoldRoomServerInfos* ResGetRoomBrifeList::mutable_goldroomserverinfos(int index) {
  return goldroomserverinfos_.Mutable(index);
}
inline ::ProtoNet::GoldRoomServerInfos* ResGetRoomBrifeList::add_goldroomserverinfos() {
  return goldroomserverinfos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::GoldRoomServerInfos >&
ResGetRoomBrifeList::goldroomserverinfos() const {
  return goldroomserverinfos_;
}
inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::GoldRoomServerInfos >*
ResGetRoomBrifeList::mutable_goldroomserverinfos() {
  return &goldroomserverinfos_;
}

// -------------------------------------------------------------------

// ReqCheckInMatch

// -------------------------------------------------------------------

// ResCheckInMatch

// required .ProtoNet.ResponseResult result = 1;
inline bool ResCheckInMatch::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResCheckInMatch::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResCheckInMatch::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResCheckInMatch::clear_result() {
  if (result_ != NULL) result_->::ProtoNet::ResponseResult::Clear();
  clear_has_result();
}
inline const ::ProtoNet::ResponseResult& ResCheckInMatch::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::ProtoNet::ResponseResult* ResCheckInMatch::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::ProtoNet::ResponseResult;
  return result_;
}
inline ::ProtoNet::ResponseResult* ResCheckInMatch::release_result() {
  clear_has_result();
  ::ProtoNet::ResponseResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline void ResCheckInMatch::set_allocated_result(::ProtoNet::ResponseResult* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// optional int32 inMatch = 2;
inline bool ResCheckInMatch::has_inmatch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResCheckInMatch::set_has_inmatch() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResCheckInMatch::clear_has_inmatch() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResCheckInMatch::clear_inmatch() {
  inmatch_ = 0;
  clear_has_inmatch();
}
inline ::google::protobuf::int32 ResCheckInMatch::inmatch() const {
  return inmatch_;
}
inline void ResCheckInMatch::set_inmatch(::google::protobuf::int32 value) {
  set_has_inmatch();
  inmatch_ = value;
}

// optional string randId = 3;
inline bool ResCheckInMatch::has_randid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResCheckInMatch::set_has_randid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResCheckInMatch::clear_has_randid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResCheckInMatch::clear_randid() {
  if (randid_ != &::google::protobuf::internal::kEmptyString) {
    randid_->clear();
  }
  clear_has_randid();
}
inline const ::std::string& ResCheckInMatch::randid() const {
  return *randid_;
}
inline void ResCheckInMatch::set_randid(const ::std::string& value) {
  set_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    randid_ = new ::std::string;
  }
  randid_->assign(value);
}
inline void ResCheckInMatch::set_randid(const char* value) {
  set_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    randid_ = new ::std::string;
  }
  randid_->assign(value);
}
inline void ResCheckInMatch::set_randid(const char* value, size_t size) {
  set_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    randid_ = new ::std::string;
  }
  randid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResCheckInMatch::mutable_randid() {
  set_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    randid_ = new ::std::string;
  }
  return randid_;
}
inline ::std::string* ResCheckInMatch::release_randid() {
  clear_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = randid_;
    randid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResCheckInMatch::set_allocated_randid(::std::string* randid) {
  if (randid_ != &::google::protobuf::internal::kEmptyString) {
    delete randid_;
  }
  if (randid) {
    set_has_randid();
    randid_ = randid;
  } else {
    clear_has_randid();
    randid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 matchConfigId = 4;
inline bool ResCheckInMatch::has_matchconfigid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResCheckInMatch::set_has_matchconfigid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResCheckInMatch::clear_has_matchconfigid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResCheckInMatch::clear_matchconfigid() {
  matchconfigid_ = 0;
  clear_has_matchconfigid();
}
inline ::google::protobuf::int32 ResCheckInMatch::matchconfigid() const {
  return matchconfigid_;
}
inline void ResCheckInMatch::set_matchconfigid(::google::protobuf::int32 value) {
  set_has_matchconfigid();
  matchconfigid_ = value;
}

// optional int32 gameId = 5;
inline bool ResCheckInMatch::has_gameid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResCheckInMatch::set_has_gameid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResCheckInMatch::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResCheckInMatch::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 ResCheckInMatch::gameid() const {
  return gameid_;
}
inline void ResCheckInMatch::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional int32 selfRank = 6;
inline bool ResCheckInMatch::has_selfrank() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResCheckInMatch::set_has_selfrank() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResCheckInMatch::clear_has_selfrank() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResCheckInMatch::clear_selfrank() {
  selfrank_ = 0;
  clear_has_selfrank();
}
inline ::google::protobuf::int32 ResCheckInMatch::selfrank() const {
  return selfrank_;
}
inline void ResCheckInMatch::set_selfrank(::google::protobuf::int32 value) {
  set_has_selfrank();
  selfrank_ = value;
}

// optional int32 from = 7;
inline bool ResCheckInMatch::has_from() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ResCheckInMatch::set_has_from() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ResCheckInMatch::clear_has_from() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ResCheckInMatch::clear_from() {
  from_ = 0;
  clear_has_from();
}
inline ::google::protobuf::int32 ResCheckInMatch::from() const {
  return from_;
}
inline void ResCheckInMatch::set_from(::google::protobuf::int32 value) {
  set_has_from();
  from_ = value;
}

// optional int32 to = 8;
inline bool ResCheckInMatch::has_to() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ResCheckInMatch::set_has_to() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ResCheckInMatch::clear_has_to() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ResCheckInMatch::clear_to() {
  to_ = 0;
  clear_has_to();
}
inline ::google::protobuf::int32 ResCheckInMatch::to() const {
  return to_;
}
inline void ResCheckInMatch::set_to(::google::protobuf::int32 value) {
  set_has_to();
  to_ = value;
}

// optional int32 taotai = 9;
inline bool ResCheckInMatch::has_taotai() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ResCheckInMatch::set_has_taotai() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ResCheckInMatch::clear_has_taotai() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ResCheckInMatch::clear_taotai() {
  taotai_ = 0;
  clear_has_taotai();
}
inline ::google::protobuf::int32 ResCheckInMatch::taotai() const {
  return taotai_;
}
inline void ResCheckInMatch::set_taotai(::google::protobuf::int32 value) {
  set_has_taotai();
  taotai_ = value;
}

// -------------------------------------------------------------------

// ReqOpenRoomReplace

// required int32 roomType = 1;
inline bool ReqOpenRoomReplace::has_roomtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqOpenRoomReplace::set_has_roomtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqOpenRoomReplace::clear_has_roomtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqOpenRoomReplace::clear_roomtype() {
  roomtype_ = 0;
  clear_has_roomtype();
}
inline ::google::protobuf::int32 ReqOpenRoomReplace::roomtype() const {
  return roomtype_;
}
inline void ReqOpenRoomReplace::set_roomtype(::google::protobuf::int32 value) {
  set_has_roomtype();
  roomtype_ = value;
}

// required int32 times = 2;
inline bool ReqOpenRoomReplace::has_times() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqOpenRoomReplace::set_has_times() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqOpenRoomReplace::clear_has_times() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqOpenRoomReplace::clear_times() {
  times_ = 0;
  clear_has_times();
}
inline ::google::protobuf::int32 ReqOpenRoomReplace::times() const {
  return times_;
}
inline void ReqOpenRoomReplace::set_times(::google::protobuf::int32 value) {
  set_has_times();
  times_ = value;
}

// optional string paramString = 3;
inline bool ReqOpenRoomReplace::has_paramstring() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqOpenRoomReplace::set_has_paramstring() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqOpenRoomReplace::clear_has_paramstring() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqOpenRoomReplace::clear_paramstring() {
  if (paramstring_ != &::google::protobuf::internal::kEmptyString) {
    paramstring_->clear();
  }
  clear_has_paramstring();
}
inline const ::std::string& ReqOpenRoomReplace::paramstring() const {
  return *paramstring_;
}
inline void ReqOpenRoomReplace::set_paramstring(const ::std::string& value) {
  set_has_paramstring();
  if (paramstring_ == &::google::protobuf::internal::kEmptyString) {
    paramstring_ = new ::std::string;
  }
  paramstring_->assign(value);
}
inline void ReqOpenRoomReplace::set_paramstring(const char* value) {
  set_has_paramstring();
  if (paramstring_ == &::google::protobuf::internal::kEmptyString) {
    paramstring_ = new ::std::string;
  }
  paramstring_->assign(value);
}
inline void ReqOpenRoomReplace::set_paramstring(const char* value, size_t size) {
  set_has_paramstring();
  if (paramstring_ == &::google::protobuf::internal::kEmptyString) {
    paramstring_ = new ::std::string;
  }
  paramstring_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqOpenRoomReplace::mutable_paramstring() {
  set_has_paramstring();
  if (paramstring_ == &::google::protobuf::internal::kEmptyString) {
    paramstring_ = new ::std::string;
  }
  return paramstring_;
}
inline ::std::string* ReqOpenRoomReplace::release_paramstring() {
  clear_has_paramstring();
  if (paramstring_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = paramstring_;
    paramstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqOpenRoomReplace::set_allocated_paramstring(::std::string* paramstring) {
  if (paramstring_ != &::google::protobuf::internal::kEmptyString) {
    delete paramstring_;
  }
  if (paramstring) {
    set_has_paramstring();
    paramstring_ = paramstring;
  } else {
    clear_has_paramstring();
    paramstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 timesType = 4;
inline bool ReqOpenRoomReplace::has_timestype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqOpenRoomReplace::set_has_timestype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqOpenRoomReplace::clear_has_timestype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqOpenRoomReplace::clear_timestype() {
  timestype_ = 0;
  clear_has_timestype();
}
inline ::google::protobuf::int32 ReqOpenRoomReplace::timestype() const {
  return timestype_;
}
inline void ReqOpenRoomReplace::set_timestype(::google::protobuf::int32 value) {
  set_has_timestype();
  timestype_ = value;
}

// optional int32 halfWayJoin = 5;
inline bool ReqOpenRoomReplace::has_halfwayjoin() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReqOpenRoomReplace::set_has_halfwayjoin() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReqOpenRoomReplace::clear_has_halfwayjoin() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReqOpenRoomReplace::clear_halfwayjoin() {
  halfwayjoin_ = 0;
  clear_has_halfwayjoin();
}
inline ::google::protobuf::int32 ReqOpenRoomReplace::halfwayjoin() const {
  return halfwayjoin_;
}
inline void ReqOpenRoomReplace::set_halfwayjoin(::google::protobuf::int32 value) {
  set_has_halfwayjoin();
  halfwayjoin_ = value;
}

// optional int32 maxPlayerNum = 6;
inline bool ReqOpenRoomReplace::has_maxplayernum() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReqOpenRoomReplace::set_has_maxplayernum() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReqOpenRoomReplace::clear_has_maxplayernum() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReqOpenRoomReplace::clear_maxplayernum() {
  maxplayernum_ = 0;
  clear_has_maxplayernum();
}
inline ::google::protobuf::int32 ReqOpenRoomReplace::maxplayernum() const {
  return maxplayernum_;
}
inline void ReqOpenRoomReplace::set_maxplayernum(::google::protobuf::int32 value) {
  set_has_maxplayernum();
  maxplayernum_ = value;
}

// optional double yazhu = 7;
inline bool ReqOpenRoomReplace::has_yazhu() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ReqOpenRoomReplace::set_has_yazhu() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ReqOpenRoomReplace::clear_has_yazhu() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ReqOpenRoomReplace::clear_yazhu() {
  yazhu_ = 0;
  clear_has_yazhu();
}
inline double ReqOpenRoomReplace::yazhu() const {
  return yazhu_;
}
inline void ReqOpenRoomReplace::set_yazhu(double value) {
  set_has_yazhu();
  yazhu_ = value;
}

// required int32 gameId = 8;
inline bool ReqOpenRoomReplace::has_gameid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ReqOpenRoomReplace::set_has_gameid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ReqOpenRoomReplace::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ReqOpenRoomReplace::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 ReqOpenRoomReplace::gameid() const {
  return gameid_;
}
inline void ReqOpenRoomReplace::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// -------------------------------------------------------------------

// ResOpenRoomReplace

// required .ProtoNet.ResponseResult result = 1;
inline bool ResOpenRoomReplace::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResOpenRoomReplace::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResOpenRoomReplace::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResOpenRoomReplace::clear_result() {
  if (result_ != NULL) result_->::ProtoNet::ResponseResult::Clear();
  clear_has_result();
}
inline const ::ProtoNet::ResponseResult& ResOpenRoomReplace::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::ProtoNet::ResponseResult* ResOpenRoomReplace::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::ProtoNet::ResponseResult;
  return result_;
}
inline ::ProtoNet::ResponseResult* ResOpenRoomReplace::release_result() {
  clear_has_result();
  ::ProtoNet::ResponseResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline void ResOpenRoomReplace::set_allocated_result(::ProtoNet::ResponseResult* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// optional string roomId = 2;
inline bool ResOpenRoomReplace::has_roomid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResOpenRoomReplace::set_has_roomid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResOpenRoomReplace::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResOpenRoomReplace::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& ResOpenRoomReplace::roomid() const {
  return *roomid_;
}
inline void ResOpenRoomReplace::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ResOpenRoomReplace::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ResOpenRoomReplace::set_roomid(const char* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResOpenRoomReplace::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  return roomid_;
}
inline ::std::string* ResOpenRoomReplace::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResOpenRoomReplace::set_allocated_roomid(::std::string* roomid) {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomid_;
  }
  if (roomid) {
    set_has_roomid();
    roomid_ = roomid;
  } else {
    clear_has_roomid();
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 roomType = 3;
inline bool ResOpenRoomReplace::has_roomtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResOpenRoomReplace::set_has_roomtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResOpenRoomReplace::clear_has_roomtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResOpenRoomReplace::clear_roomtype() {
  roomtype_ = 0;
  clear_has_roomtype();
}
inline ::google::protobuf::int32 ResOpenRoomReplace::roomtype() const {
  return roomtype_;
}
inline void ResOpenRoomReplace::set_roomtype(::google::protobuf::int32 value) {
  set_has_roomtype();
  roomtype_ = value;
}

// optional int32 times = 4;
inline bool ResOpenRoomReplace::has_times() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResOpenRoomReplace::set_has_times() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResOpenRoomReplace::clear_has_times() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResOpenRoomReplace::clear_times() {
  times_ = 0;
  clear_has_times();
}
inline ::google::protobuf::int32 ResOpenRoomReplace::times() const {
  return times_;
}
inline void ResOpenRoomReplace::set_times(::google::protobuf::int32 value) {
  set_has_times();
  times_ = value;
}

// optional string paramString = 5;
inline bool ResOpenRoomReplace::has_paramstring() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResOpenRoomReplace::set_has_paramstring() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResOpenRoomReplace::clear_has_paramstring() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResOpenRoomReplace::clear_paramstring() {
  if (paramstring_ != &::google::protobuf::internal::kEmptyString) {
    paramstring_->clear();
  }
  clear_has_paramstring();
}
inline const ::std::string& ResOpenRoomReplace::paramstring() const {
  return *paramstring_;
}
inline void ResOpenRoomReplace::set_paramstring(const ::std::string& value) {
  set_has_paramstring();
  if (paramstring_ == &::google::protobuf::internal::kEmptyString) {
    paramstring_ = new ::std::string;
  }
  paramstring_->assign(value);
}
inline void ResOpenRoomReplace::set_paramstring(const char* value) {
  set_has_paramstring();
  if (paramstring_ == &::google::protobuf::internal::kEmptyString) {
    paramstring_ = new ::std::string;
  }
  paramstring_->assign(value);
}
inline void ResOpenRoomReplace::set_paramstring(const char* value, size_t size) {
  set_has_paramstring();
  if (paramstring_ == &::google::protobuf::internal::kEmptyString) {
    paramstring_ = new ::std::string;
  }
  paramstring_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResOpenRoomReplace::mutable_paramstring() {
  set_has_paramstring();
  if (paramstring_ == &::google::protobuf::internal::kEmptyString) {
    paramstring_ = new ::std::string;
  }
  return paramstring_;
}
inline ::std::string* ResOpenRoomReplace::release_paramstring() {
  clear_has_paramstring();
  if (paramstring_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = paramstring_;
    paramstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResOpenRoomReplace::set_allocated_paramstring(::std::string* paramstring) {
  if (paramstring_ != &::google::protobuf::internal::kEmptyString) {
    delete paramstring_;
  }
  if (paramstring) {
    set_has_paramstring();
    paramstring_ = paramstring;
  } else {
    clear_has_paramstring();
    paramstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 timesType = 6;
inline bool ResOpenRoomReplace::has_timestype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResOpenRoomReplace::set_has_timestype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResOpenRoomReplace::clear_has_timestype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResOpenRoomReplace::clear_timestype() {
  timestype_ = 0;
  clear_has_timestype();
}
inline ::google::protobuf::int32 ResOpenRoomReplace::timestype() const {
  return timestype_;
}
inline void ResOpenRoomReplace::set_timestype(::google::protobuf::int32 value) {
  set_has_timestype();
  timestype_ = value;
}

// optional int32 halfWayJoin = 7;
inline bool ResOpenRoomReplace::has_halfwayjoin() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ResOpenRoomReplace::set_has_halfwayjoin() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ResOpenRoomReplace::clear_has_halfwayjoin() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ResOpenRoomReplace::clear_halfwayjoin() {
  halfwayjoin_ = 0;
  clear_has_halfwayjoin();
}
inline ::google::protobuf::int32 ResOpenRoomReplace::halfwayjoin() const {
  return halfwayjoin_;
}
inline void ResOpenRoomReplace::set_halfwayjoin(::google::protobuf::int32 value) {
  set_has_halfwayjoin();
  halfwayjoin_ = value;
}

// optional int32 maxPlayerNum = 8;
inline bool ResOpenRoomReplace::has_maxplayernum() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ResOpenRoomReplace::set_has_maxplayernum() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ResOpenRoomReplace::clear_has_maxplayernum() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ResOpenRoomReplace::clear_maxplayernum() {
  maxplayernum_ = 0;
  clear_has_maxplayernum();
}
inline ::google::protobuf::int32 ResOpenRoomReplace::maxplayernum() const {
  return maxplayernum_;
}
inline void ResOpenRoomReplace::set_maxplayernum(::google::protobuf::int32 value) {
  set_has_maxplayernum();
  maxplayernum_ = value;
}

// optional double yazhu = 9;
inline bool ResOpenRoomReplace::has_yazhu() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ResOpenRoomReplace::set_has_yazhu() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ResOpenRoomReplace::clear_has_yazhu() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ResOpenRoomReplace::clear_yazhu() {
  yazhu_ = 0;
  clear_has_yazhu();
}
inline double ResOpenRoomReplace::yazhu() const {
  return yazhu_;
}
inline void ResOpenRoomReplace::set_yazhu(double value) {
  set_has_yazhu();
  yazhu_ = value;
}

// optional int32 gameId = 10;
inline bool ResOpenRoomReplace::has_gameid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ResOpenRoomReplace::set_has_gameid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ResOpenRoomReplace::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ResOpenRoomReplace::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 ResOpenRoomReplace::gameid() const {
  return gameid_;
}
inline void ResOpenRoomReplace::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional .ProtoNet.ServerInfoIpsSafeDetail serverInfo = 11;
inline bool ResOpenRoomReplace::has_serverinfo() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ResOpenRoomReplace::set_has_serverinfo() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ResOpenRoomReplace::clear_has_serverinfo() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ResOpenRoomReplace::clear_serverinfo() {
  if (serverinfo_ != NULL) serverinfo_->::ProtoNet::ServerInfoIpsSafeDetail::Clear();
  clear_has_serverinfo();
}
inline const ::ProtoNet::ServerInfoIpsSafeDetail& ResOpenRoomReplace::serverinfo() const {
  return serverinfo_ != NULL ? *serverinfo_ : *default_instance_->serverinfo_;
}
inline ::ProtoNet::ServerInfoIpsSafeDetail* ResOpenRoomReplace::mutable_serverinfo() {
  set_has_serverinfo();
  if (serverinfo_ == NULL) serverinfo_ = new ::ProtoNet::ServerInfoIpsSafeDetail;
  return serverinfo_;
}
inline ::ProtoNet::ServerInfoIpsSafeDetail* ResOpenRoomReplace::release_serverinfo() {
  clear_has_serverinfo();
  ::ProtoNet::ServerInfoIpsSafeDetail* temp = serverinfo_;
  serverinfo_ = NULL;
  return temp;
}
inline void ResOpenRoomReplace::set_allocated_serverinfo(::ProtoNet::ServerInfoIpsSafeDetail* serverinfo) {
  delete serverinfo_;
  serverinfo_ = serverinfo;
  if (serverinfo) {
    set_has_serverinfo();
  } else {
    clear_has_serverinfo();
  }
}

// -------------------------------------------------------------------

// ReqOpenRoomReplaceRecordList

// required int32 status = 1;
inline bool ReqOpenRoomReplaceRecordList::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqOpenRoomReplaceRecordList::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqOpenRoomReplaceRecordList::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqOpenRoomReplaceRecordList::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 ReqOpenRoomReplaceRecordList::status() const {
  return status_;
}
inline void ReqOpenRoomReplaceRecordList::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// ResOpenRoomReplaceRecord_List

// required .ProtoNet.ResponseResult result = 1;
inline bool ResOpenRoomReplaceRecord_List::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResOpenRoomReplaceRecord_List::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResOpenRoomReplaceRecord_List::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResOpenRoomReplaceRecord_List::clear_result() {
  if (result_ != NULL) result_->::ProtoNet::ResponseResult::Clear();
  clear_has_result();
}
inline const ::ProtoNet::ResponseResult& ResOpenRoomReplaceRecord_List::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::ProtoNet::ResponseResult* ResOpenRoomReplaceRecord_List::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::ProtoNet::ResponseResult;
  return result_;
}
inline ::ProtoNet::ResponseResult* ResOpenRoomReplaceRecord_List::release_result() {
  clear_has_result();
  ::ProtoNet::ResponseResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline void ResOpenRoomReplaceRecord_List::set_allocated_result(::ProtoNet::ResponseResult* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// repeated .ProtoNet.OpenRoomReplaceRecordInfo infos = 2;
inline int ResOpenRoomReplaceRecord_List::infos_size() const {
  return infos_.size();
}
inline void ResOpenRoomReplaceRecord_List::clear_infos() {
  infos_.Clear();
}
inline const ::ProtoNet::OpenRoomReplaceRecordInfo& ResOpenRoomReplaceRecord_List::infos(int index) const {
  return infos_.Get(index);
}
inline ::ProtoNet::OpenRoomReplaceRecordInfo* ResOpenRoomReplaceRecord_List::mutable_infos(int index) {
  return infos_.Mutable(index);
}
inline ::ProtoNet::OpenRoomReplaceRecordInfo* ResOpenRoomReplaceRecord_List::add_infos() {
  return infos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::OpenRoomReplaceRecordInfo >&
ResOpenRoomReplaceRecord_List::infos() const {
  return infos_;
}
inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::OpenRoomReplaceRecordInfo >*
ResOpenRoomReplaceRecord_List::mutable_infos() {
  return &infos_;
}

// optional int32 daikaifangRecordNum = 3;
inline bool ResOpenRoomReplaceRecord_List::has_daikaifangrecordnum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResOpenRoomReplaceRecord_List::set_has_daikaifangrecordnum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResOpenRoomReplaceRecord_List::clear_has_daikaifangrecordnum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResOpenRoomReplaceRecord_List::clear_daikaifangrecordnum() {
  daikaifangrecordnum_ = 0;
  clear_has_daikaifangrecordnum();
}
inline ::google::protobuf::int32 ResOpenRoomReplaceRecord_List::daikaifangrecordnum() const {
  return daikaifangrecordnum_;
}
inline void ResOpenRoomReplaceRecord_List::set_daikaifangrecordnum(::google::protobuf::int32 value) {
  set_has_daikaifangrecordnum();
  daikaifangrecordnum_ = value;
}

// optional int32 status = 4;
inline bool ResOpenRoomReplaceRecord_List::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResOpenRoomReplaceRecord_List::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResOpenRoomReplaceRecord_List::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResOpenRoomReplaceRecord_List::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 ResOpenRoomReplaceRecord_List::status() const {
  return status_;
}
inline void ResOpenRoomReplaceRecord_List::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// -------------------------------------------------------------------

// ReqDissolutionOpenRoomReplace

// required string roomId = 1;
inline bool ReqDissolutionOpenRoomReplace::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqDissolutionOpenRoomReplace::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqDissolutionOpenRoomReplace::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqDissolutionOpenRoomReplace::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& ReqDissolutionOpenRoomReplace::roomid() const {
  return *roomid_;
}
inline void ReqDissolutionOpenRoomReplace::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ReqDissolutionOpenRoomReplace::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ReqDissolutionOpenRoomReplace::set_roomid(const char* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqDissolutionOpenRoomReplace::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  return roomid_;
}
inline ::std::string* ReqDissolutionOpenRoomReplace::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqDissolutionOpenRoomReplace::set_allocated_roomid(::std::string* roomid) {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomid_;
  }
  if (roomid) {
    set_has_roomid();
    roomid_ = roomid;
  } else {
    clear_has_roomid();
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ResDissolutionOpenRoomReplace

// required .ProtoNet.ResponseResult result = 1;
inline bool ResDissolutionOpenRoomReplace::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResDissolutionOpenRoomReplace::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResDissolutionOpenRoomReplace::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResDissolutionOpenRoomReplace::clear_result() {
  if (result_ != NULL) result_->::ProtoNet::ResponseResult::Clear();
  clear_has_result();
}
inline const ::ProtoNet::ResponseResult& ResDissolutionOpenRoomReplace::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::ProtoNet::ResponseResult* ResDissolutionOpenRoomReplace::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::ProtoNet::ResponseResult;
  return result_;
}
inline ::ProtoNet::ResponseResult* ResDissolutionOpenRoomReplace::release_result() {
  clear_has_result();
  ::ProtoNet::ResponseResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline void ResDissolutionOpenRoomReplace::set_allocated_result(::ProtoNet::ResponseResult* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// -------------------------------------------------------------------

// ReqGameRoomList

// required int32 gameId = 1;
inline bool ReqGameRoomList::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqGameRoomList::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqGameRoomList::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqGameRoomList::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 ReqGameRoomList::gameid() const {
  return gameid_;
}
inline void ReqGameRoomList::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 timesType = 2;
inline bool ReqGameRoomList::has_timestype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqGameRoomList::set_has_timestype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqGameRoomList::clear_has_timestype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqGameRoomList::clear_timestype() {
  timestype_ = 0;
  clear_has_timestype();
}
inline ::google::protobuf::int32 ReqGameRoomList::timestype() const {
  return timestype_;
}
inline void ReqGameRoomList::set_timestype(::google::protobuf::int32 value) {
  set_has_timestype();
  timestype_ = value;
}

// required int32 fangkaJinbi = 3;
inline bool ReqGameRoomList::has_fangkajinbi() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqGameRoomList::set_has_fangkajinbi() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqGameRoomList::clear_has_fangkajinbi() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqGameRoomList::clear_fangkajinbi() {
  fangkajinbi_ = 0;
  clear_has_fangkajinbi();
}
inline ::google::protobuf::int32 ReqGameRoomList::fangkajinbi() const {
  return fangkajinbi_;
}
inline void ReqGameRoomList::set_fangkajinbi(::google::protobuf::int32 value) {
  set_has_fangkajinbi();
  fangkajinbi_ = value;
}

// -------------------------------------------------------------------

// ResGameRoomList

// required .ProtoNet.ResponseResult result = 1;
inline bool ResGameRoomList::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResGameRoomList::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResGameRoomList::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResGameRoomList::clear_result() {
  if (result_ != NULL) result_->::ProtoNet::ResponseResult::Clear();
  clear_has_result();
}
inline const ::ProtoNet::ResponseResult& ResGameRoomList::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::ProtoNet::ResponseResult* ResGameRoomList::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::ProtoNet::ResponseResult;
  return result_;
}
inline ::ProtoNet::ResponseResult* ResGameRoomList::release_result() {
  clear_has_result();
  ::ProtoNet::ResponseResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline void ResGameRoomList::set_allocated_result(::ProtoNet::ResponseResult* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// repeated .ProtoNet.GameRoomList list = 2;
inline int ResGameRoomList::list_size() const {
  return list_.size();
}
inline void ResGameRoomList::clear_list() {
  list_.Clear();
}
inline const ::ProtoNet::GameRoomList& ResGameRoomList::list(int index) const {
  return list_.Get(index);
}
inline ::ProtoNet::GameRoomList* ResGameRoomList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::ProtoNet::GameRoomList* ResGameRoomList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::GameRoomList >&
ResGameRoomList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::GameRoomList >*
ResGameRoomList::mutable_list() {
  return &list_;
}

// -------------------------------------------------------------------

// GameRoomList

// required string roomId = 1;
inline bool GameRoomList::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameRoomList::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameRoomList::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameRoomList::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& GameRoomList::roomid() const {
  return *roomid_;
}
inline void GameRoomList::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void GameRoomList::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void GameRoomList::set_roomid(const char* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameRoomList::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  return roomid_;
}
inline ::std::string* GameRoomList::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameRoomList::set_allocated_roomid(::std::string* roomid) {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomid_;
  }
  if (roomid) {
    set_has_roomid();
    roomid_ = roomid;
  } else {
    clear_has_roomid();
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string paramString = 2;
inline bool GameRoomList::has_paramstring() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameRoomList::set_has_paramstring() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameRoomList::clear_has_paramstring() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameRoomList::clear_paramstring() {
  if (paramstring_ != &::google::protobuf::internal::kEmptyString) {
    paramstring_->clear();
  }
  clear_has_paramstring();
}
inline const ::std::string& GameRoomList::paramstring() const {
  return *paramstring_;
}
inline void GameRoomList::set_paramstring(const ::std::string& value) {
  set_has_paramstring();
  if (paramstring_ == &::google::protobuf::internal::kEmptyString) {
    paramstring_ = new ::std::string;
  }
  paramstring_->assign(value);
}
inline void GameRoomList::set_paramstring(const char* value) {
  set_has_paramstring();
  if (paramstring_ == &::google::protobuf::internal::kEmptyString) {
    paramstring_ = new ::std::string;
  }
  paramstring_->assign(value);
}
inline void GameRoomList::set_paramstring(const char* value, size_t size) {
  set_has_paramstring();
  if (paramstring_ == &::google::protobuf::internal::kEmptyString) {
    paramstring_ = new ::std::string;
  }
  paramstring_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameRoomList::mutable_paramstring() {
  set_has_paramstring();
  if (paramstring_ == &::google::protobuf::internal::kEmptyString) {
    paramstring_ = new ::std::string;
  }
  return paramstring_;
}
inline ::std::string* GameRoomList::release_paramstring() {
  clear_has_paramstring();
  if (paramstring_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = paramstring_;
    paramstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameRoomList::set_allocated_paramstring(::std::string* paramstring) {
  if (paramstring_ != &::google::protobuf::internal::kEmptyString) {
    delete paramstring_;
  }
  if (paramstring) {
    set_has_paramstring();
    paramstring_ = paramstring;
  } else {
    clear_has_paramstring();
    paramstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required double yazhu = 3;
inline bool GameRoomList::has_yazhu() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameRoomList::set_has_yazhu() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameRoomList::clear_has_yazhu() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameRoomList::clear_yazhu() {
  yazhu_ = 0;
  clear_has_yazhu();
}
inline double GameRoomList::yazhu() const {
  return yazhu_;
}
inline void GameRoomList::set_yazhu(double value) {
  set_has_yazhu();
  yazhu_ = value;
}

// required int32 halfWayJoin = 4;
inline bool GameRoomList::has_halfwayjoin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameRoomList::set_has_halfwayjoin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameRoomList::clear_has_halfwayjoin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameRoomList::clear_halfwayjoin() {
  halfwayjoin_ = 0;
  clear_has_halfwayjoin();
}
inline ::google::protobuf::int32 GameRoomList::halfwayjoin() const {
  return halfwayjoin_;
}
inline void GameRoomList::set_halfwayjoin(::google::protobuf::int32 value) {
  set_has_halfwayjoin();
  halfwayjoin_ = value;
}

// required int32 maxPlayerNum = 5;
inline bool GameRoomList::has_maxplayernum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameRoomList::set_has_maxplayernum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameRoomList::clear_has_maxplayernum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameRoomList::clear_maxplayernum() {
  maxplayernum_ = 0;
  clear_has_maxplayernum();
}
inline ::google::protobuf::int32 GameRoomList::maxplayernum() const {
  return maxplayernum_;
}
inline void GameRoomList::set_maxplayernum(::google::protobuf::int32 value) {
  set_has_maxplayernum();
  maxplayernum_ = value;
}

// required int32 fangkaJinbi = 6;
inline bool GameRoomList::has_fangkajinbi() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GameRoomList::set_has_fangkajinbi() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GameRoomList::clear_has_fangkajinbi() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GameRoomList::clear_fangkajinbi() {
  fangkajinbi_ = 0;
  clear_has_fangkajinbi();
}
inline ::google::protobuf::int32 GameRoomList::fangkajinbi() const {
  return fangkajinbi_;
}
inline void GameRoomList::set_fangkajinbi(::google::protobuf::int32 value) {
  set_has_fangkajinbi();
  fangkajinbi_ = value;
}

// required double minNeed = 7;
inline bool GameRoomList::has_minneed() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GameRoomList::set_has_minneed() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GameRoomList::clear_has_minneed() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GameRoomList::clear_minneed() {
  minneed_ = 0;
  clear_has_minneed();
}
inline double GameRoomList::minneed() const {
  return minneed_;
}
inline void GameRoomList::set_minneed(double value) {
  set_has_minneed();
  minneed_ = value;
}

// required string pipeiParam = 8;
inline bool GameRoomList::has_pipeiparam() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GameRoomList::set_has_pipeiparam() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GameRoomList::clear_has_pipeiparam() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GameRoomList::clear_pipeiparam() {
  if (pipeiparam_ != &::google::protobuf::internal::kEmptyString) {
    pipeiparam_->clear();
  }
  clear_has_pipeiparam();
}
inline const ::std::string& GameRoomList::pipeiparam() const {
  return *pipeiparam_;
}
inline void GameRoomList::set_pipeiparam(const ::std::string& value) {
  set_has_pipeiparam();
  if (pipeiparam_ == &::google::protobuf::internal::kEmptyString) {
    pipeiparam_ = new ::std::string;
  }
  pipeiparam_->assign(value);
}
inline void GameRoomList::set_pipeiparam(const char* value) {
  set_has_pipeiparam();
  if (pipeiparam_ == &::google::protobuf::internal::kEmptyString) {
    pipeiparam_ = new ::std::string;
  }
  pipeiparam_->assign(value);
}
inline void GameRoomList::set_pipeiparam(const char* value, size_t size) {
  set_has_pipeiparam();
  if (pipeiparam_ == &::google::protobuf::internal::kEmptyString) {
    pipeiparam_ = new ::std::string;
  }
  pipeiparam_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameRoomList::mutable_pipeiparam() {
  set_has_pipeiparam();
  if (pipeiparam_ == &::google::protobuf::internal::kEmptyString) {
    pipeiparam_ = new ::std::string;
  }
  return pipeiparam_;
}
inline ::std::string* GameRoomList::release_pipeiparam() {
  clear_has_pipeiparam();
  if (pipeiparam_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pipeiparam_;
    pipeiparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameRoomList::set_allocated_pipeiparam(::std::string* pipeiparam) {
  if (pipeiparam_ != &::google::protobuf::internal::kEmptyString) {
    delete pipeiparam_;
  }
  if (pipeiparam) {
    set_has_pipeiparam();
    pipeiparam_ = pipeiparam;
  } else {
    clear_has_pipeiparam();
    pipeiparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .ProtoNet.ServerInfoIpsSafeDetail serverInfo = 9;
inline bool GameRoomList::has_serverinfo() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GameRoomList::set_has_serverinfo() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GameRoomList::clear_has_serverinfo() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GameRoomList::clear_serverinfo() {
  if (serverinfo_ != NULL) serverinfo_->::ProtoNet::ServerInfoIpsSafeDetail::Clear();
  clear_has_serverinfo();
}
inline const ::ProtoNet::ServerInfoIpsSafeDetail& GameRoomList::serverinfo() const {
  return serverinfo_ != NULL ? *serverinfo_ : *default_instance_->serverinfo_;
}
inline ::ProtoNet::ServerInfoIpsSafeDetail* GameRoomList::mutable_serverinfo() {
  set_has_serverinfo();
  if (serverinfo_ == NULL) serverinfo_ = new ::ProtoNet::ServerInfoIpsSafeDetail;
  return serverinfo_;
}
inline ::ProtoNet::ServerInfoIpsSafeDetail* GameRoomList::release_serverinfo() {
  clear_has_serverinfo();
  ::ProtoNet::ServerInfoIpsSafeDetail* temp = serverinfo_;
  serverinfo_ = NULL;
  return temp;
}
inline void GameRoomList::set_allocated_serverinfo(::ProtoNet::ServerInfoIpsSafeDetail* serverinfo) {
  delete serverinfo_;
  serverinfo_ = serverinfo;
  if (serverinfo) {
    set_has_serverinfo();
  } else {
    clear_has_serverinfo();
  }
}

// required int32 gameId = 10;
inline bool GameRoomList::has_gameid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GameRoomList::set_has_gameid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GameRoomList::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GameRoomList::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 GameRoomList::gameid() const {
  return gameid_;
}
inline void GameRoomList::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 currentPlayerNum = 11;
inline bool GameRoomList::has_currentplayernum() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GameRoomList::set_has_currentplayernum() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GameRoomList::clear_has_currentplayernum() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GameRoomList::clear_currentplayernum() {
  currentplayernum_ = 0;
  clear_has_currentplayernum();
}
inline ::google::protobuf::int32 GameRoomList::currentplayernum() const {
  return currentplayernum_;
}
inline void GameRoomList::set_currentplayernum(::google::protobuf::int32 value) {
  set_has_currentplayernum();
  currentplayernum_ = value;
}

// required int32 roomStatus = 12;
inline bool GameRoomList::has_roomstatus() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GameRoomList::set_has_roomstatus() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GameRoomList::clear_has_roomstatus() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GameRoomList::clear_roomstatus() {
  roomstatus_ = 0;
  clear_has_roomstatus();
}
inline ::google::protobuf::int32 GameRoomList::roomstatus() const {
  return roomstatus_;
}
inline void GameRoomList::set_roomstatus(::google::protobuf::int32 value) {
  set_has_roomstatus();
  roomstatus_ = value;
}

// required int32 currentWatchPlayerNum = 13;
inline bool GameRoomList::has_currentwatchplayernum() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GameRoomList::set_has_currentwatchplayernum() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GameRoomList::clear_has_currentwatchplayernum() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GameRoomList::clear_currentwatchplayernum() {
  currentwatchplayernum_ = 0;
  clear_has_currentwatchplayernum();
}
inline ::google::protobuf::int32 GameRoomList::currentwatchplayernum() const {
  return currentwatchplayernum_;
}
inline void GameRoomList::set_currentwatchplayernum(::google::protobuf::int32 value) {
  set_has_currentwatchplayernum();
  currentwatchplayernum_ = value;
}

// optional int32 roomType = 14;
inline bool GameRoomList::has_roomtype() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GameRoomList::set_has_roomtype() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GameRoomList::clear_has_roomtype() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GameRoomList::clear_roomtype() {
  roomtype_ = 0;
  clear_has_roomtype();
}
inline ::google::protobuf::int32 GameRoomList::roomtype() const {
  return roomtype_;
}
inline void GameRoomList::set_roomtype(::google::protobuf::int32 value) {
  set_has_roomtype();
  roomtype_ = value;
}

// optional int32 timesType = 15;
inline bool GameRoomList::has_timestype() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void GameRoomList::set_has_timestype() {
  _has_bits_[0] |= 0x00004000u;
}
inline void GameRoomList::clear_has_timestype() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void GameRoomList::clear_timestype() {
  timestype_ = 0;
  clear_has_timestype();
}
inline ::google::protobuf::int32 GameRoomList::timestype() const {
  return timestype_;
}
inline void GameRoomList::set_timestype(::google::protobuf::int32 value) {
  set_has_timestype();
  timestype_ = value;
}

// repeated .ProtoNet.RoomRoleInfo roomRoleInfo = 16;
inline int GameRoomList::roomroleinfo_size() const {
  return roomroleinfo_.size();
}
inline void GameRoomList::clear_roomroleinfo() {
  roomroleinfo_.Clear();
}
inline const ::ProtoNet::RoomRoleInfo& GameRoomList::roomroleinfo(int index) const {
  return roomroleinfo_.Get(index);
}
inline ::ProtoNet::RoomRoleInfo* GameRoomList::mutable_roomroleinfo(int index) {
  return roomroleinfo_.Mutable(index);
}
inline ::ProtoNet::RoomRoleInfo* GameRoomList::add_roomroleinfo() {
  return roomroleinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::RoomRoleInfo >&
GameRoomList::roomroleinfo() const {
  return roomroleinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::RoomRoleInfo >*
GameRoomList::mutable_roomroleinfo() {
  return &roomroleinfo_;
}

// optional string tableNum = 17;
inline bool GameRoomList::has_tablenum() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void GameRoomList::set_has_tablenum() {
  _has_bits_[0] |= 0x00010000u;
}
inline void GameRoomList::clear_has_tablenum() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void GameRoomList::clear_tablenum() {
  if (tablenum_ != &::google::protobuf::internal::kEmptyString) {
    tablenum_->clear();
  }
  clear_has_tablenum();
}
inline const ::std::string& GameRoomList::tablenum() const {
  return *tablenum_;
}
inline void GameRoomList::set_tablenum(const ::std::string& value) {
  set_has_tablenum();
  if (tablenum_ == &::google::protobuf::internal::kEmptyString) {
    tablenum_ = new ::std::string;
  }
  tablenum_->assign(value);
}
inline void GameRoomList::set_tablenum(const char* value) {
  set_has_tablenum();
  if (tablenum_ == &::google::protobuf::internal::kEmptyString) {
    tablenum_ = new ::std::string;
  }
  tablenum_->assign(value);
}
inline void GameRoomList::set_tablenum(const char* value, size_t size) {
  set_has_tablenum();
  if (tablenum_ == &::google::protobuf::internal::kEmptyString) {
    tablenum_ = new ::std::string;
  }
  tablenum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameRoomList::mutable_tablenum() {
  set_has_tablenum();
  if (tablenum_ == &::google::protobuf::internal::kEmptyString) {
    tablenum_ = new ::std::string;
  }
  return tablenum_;
}
inline ::std::string* GameRoomList::release_tablenum() {
  clear_has_tablenum();
  if (tablenum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tablenum_;
    tablenum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameRoomList::set_allocated_tablenum(::std::string* tablenum) {
  if (tablenum_ != &::google::protobuf::internal::kEmptyString) {
    delete tablenum_;
  }
  if (tablenum) {
    set_has_tablenum();
    tablenum_ = tablenum;
  } else {
    clear_has_tablenum();
    tablenum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ReqClubGameRoomList

// required int32 roomType = 1;
inline bool ReqClubGameRoomList::has_roomtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqClubGameRoomList::set_has_roomtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqClubGameRoomList::clear_has_roomtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqClubGameRoomList::clear_roomtype() {
  roomtype_ = 0;
  clear_has_roomtype();
}
inline ::google::protobuf::int32 ReqClubGameRoomList::roomtype() const {
  return roomtype_;
}
inline void ReqClubGameRoomList::set_roomtype(::google::protobuf::int32 value) {
  set_has_roomtype();
  roomtype_ = value;
}

// required int32 gameId = 2;
inline bool ReqClubGameRoomList::has_gameid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqClubGameRoomList::set_has_gameid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqClubGameRoomList::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqClubGameRoomList::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 ReqClubGameRoomList::gameid() const {
  return gameid_;
}
inline void ReqClubGameRoomList::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required string clubId = 3;
inline bool ReqClubGameRoomList::has_clubid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqClubGameRoomList::set_has_clubid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqClubGameRoomList::clear_has_clubid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqClubGameRoomList::clear_clubid() {
  if (clubid_ != &::google::protobuf::internal::kEmptyString) {
    clubid_->clear();
  }
  clear_has_clubid();
}
inline const ::std::string& ReqClubGameRoomList::clubid() const {
  return *clubid_;
}
inline void ReqClubGameRoomList::set_clubid(const ::std::string& value) {
  set_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    clubid_ = new ::std::string;
  }
  clubid_->assign(value);
}
inline void ReqClubGameRoomList::set_clubid(const char* value) {
  set_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    clubid_ = new ::std::string;
  }
  clubid_->assign(value);
}
inline void ReqClubGameRoomList::set_clubid(const char* value, size_t size) {
  set_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    clubid_ = new ::std::string;
  }
  clubid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqClubGameRoomList::mutable_clubid() {
  set_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    clubid_ = new ::std::string;
  }
  return clubid_;
}
inline ::std::string* ReqClubGameRoomList::release_clubid() {
  clear_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clubid_;
    clubid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqClubGameRoomList::set_allocated_clubid(::std::string* clubid) {
  if (clubid_ != &::google::protobuf::internal::kEmptyString) {
    delete clubid_;
  }
  if (clubid) {
    set_has_clubid();
    clubid_ = clubid;
  } else {
    clear_has_clubid();
    clubid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string clubPipeiParam = 4;
inline bool ReqClubGameRoomList::has_clubpipeiparam() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqClubGameRoomList::set_has_clubpipeiparam() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqClubGameRoomList::clear_has_clubpipeiparam() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqClubGameRoomList::clear_clubpipeiparam() {
  if (clubpipeiparam_ != &::google::protobuf::internal::kEmptyString) {
    clubpipeiparam_->clear();
  }
  clear_has_clubpipeiparam();
}
inline const ::std::string& ReqClubGameRoomList::clubpipeiparam() const {
  return *clubpipeiparam_;
}
inline void ReqClubGameRoomList::set_clubpipeiparam(const ::std::string& value) {
  set_has_clubpipeiparam();
  if (clubpipeiparam_ == &::google::protobuf::internal::kEmptyString) {
    clubpipeiparam_ = new ::std::string;
  }
  clubpipeiparam_->assign(value);
}
inline void ReqClubGameRoomList::set_clubpipeiparam(const char* value) {
  set_has_clubpipeiparam();
  if (clubpipeiparam_ == &::google::protobuf::internal::kEmptyString) {
    clubpipeiparam_ = new ::std::string;
  }
  clubpipeiparam_->assign(value);
}
inline void ReqClubGameRoomList::set_clubpipeiparam(const char* value, size_t size) {
  set_has_clubpipeiparam();
  if (clubpipeiparam_ == &::google::protobuf::internal::kEmptyString) {
    clubpipeiparam_ = new ::std::string;
  }
  clubpipeiparam_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqClubGameRoomList::mutable_clubpipeiparam() {
  set_has_clubpipeiparam();
  if (clubpipeiparam_ == &::google::protobuf::internal::kEmptyString) {
    clubpipeiparam_ = new ::std::string;
  }
  return clubpipeiparam_;
}
inline ::std::string* ReqClubGameRoomList::release_clubpipeiparam() {
  clear_has_clubpipeiparam();
  if (clubpipeiparam_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clubpipeiparam_;
    clubpipeiparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqClubGameRoomList::set_allocated_clubpipeiparam(::std::string* clubpipeiparam) {
  if (clubpipeiparam_ != &::google::protobuf::internal::kEmptyString) {
    delete clubpipeiparam_;
  }
  if (clubpipeiparam) {
    set_has_clubpipeiparam();
    clubpipeiparam_ = clubpipeiparam;
  } else {
    clear_has_clubpipeiparam();
    clubpipeiparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string clubGameTypeId = 5;
inline bool ReqClubGameRoomList::has_clubgametypeid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReqClubGameRoomList::set_has_clubgametypeid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReqClubGameRoomList::clear_has_clubgametypeid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReqClubGameRoomList::clear_clubgametypeid() {
  if (clubgametypeid_ != &::google::protobuf::internal::kEmptyString) {
    clubgametypeid_->clear();
  }
  clear_has_clubgametypeid();
}
inline const ::std::string& ReqClubGameRoomList::clubgametypeid() const {
  return *clubgametypeid_;
}
inline void ReqClubGameRoomList::set_clubgametypeid(const ::std::string& value) {
  set_has_clubgametypeid();
  if (clubgametypeid_ == &::google::protobuf::internal::kEmptyString) {
    clubgametypeid_ = new ::std::string;
  }
  clubgametypeid_->assign(value);
}
inline void ReqClubGameRoomList::set_clubgametypeid(const char* value) {
  set_has_clubgametypeid();
  if (clubgametypeid_ == &::google::protobuf::internal::kEmptyString) {
    clubgametypeid_ = new ::std::string;
  }
  clubgametypeid_->assign(value);
}
inline void ReqClubGameRoomList::set_clubgametypeid(const char* value, size_t size) {
  set_has_clubgametypeid();
  if (clubgametypeid_ == &::google::protobuf::internal::kEmptyString) {
    clubgametypeid_ = new ::std::string;
  }
  clubgametypeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqClubGameRoomList::mutable_clubgametypeid() {
  set_has_clubgametypeid();
  if (clubgametypeid_ == &::google::protobuf::internal::kEmptyString) {
    clubgametypeid_ = new ::std::string;
  }
  return clubgametypeid_;
}
inline ::std::string* ReqClubGameRoomList::release_clubgametypeid() {
  clear_has_clubgametypeid();
  if (clubgametypeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clubgametypeid_;
    clubgametypeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqClubGameRoomList::set_allocated_clubgametypeid(::std::string* clubgametypeid) {
  if (clubgametypeid_ != &::google::protobuf::internal::kEmptyString) {
    delete clubgametypeid_;
  }
  if (clubgametypeid) {
    set_has_clubgametypeid();
    clubgametypeid_ = clubgametypeid;
  } else {
    clear_has_clubgametypeid();
    clubgametypeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ResClubGameRoomList

// required .ProtoNet.ResponseResult result = 1;
inline bool ResClubGameRoomList::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResClubGameRoomList::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResClubGameRoomList::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResClubGameRoomList::clear_result() {
  if (result_ != NULL) result_->::ProtoNet::ResponseResult::Clear();
  clear_has_result();
}
inline const ::ProtoNet::ResponseResult& ResClubGameRoomList::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::ProtoNet::ResponseResult* ResClubGameRoomList::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::ProtoNet::ResponseResult;
  return result_;
}
inline ::ProtoNet::ResponseResult* ResClubGameRoomList::release_result() {
  clear_has_result();
  ::ProtoNet::ResponseResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline void ResClubGameRoomList::set_allocated_result(::ProtoNet::ResponseResult* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// repeated .ProtoNet.ClubGameRoomList list = 2;
inline int ResClubGameRoomList::list_size() const {
  return list_.size();
}
inline void ResClubGameRoomList::clear_list() {
  list_.Clear();
}
inline const ::ProtoNet::ClubGameRoomList& ResClubGameRoomList::list(int index) const {
  return list_.Get(index);
}
inline ::ProtoNet::ClubGameRoomList* ResClubGameRoomList::mutable_list(int index) {
  return list_.Mutable(index);
}
inline ::ProtoNet::ClubGameRoomList* ResClubGameRoomList::add_list() {
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::ClubGameRoomList >&
ResClubGameRoomList::list() const {
  return list_;
}
inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::ClubGameRoomList >*
ResClubGameRoomList::mutable_list() {
  return &list_;
}

// optional int32 clubCurNum = 3;
inline bool ResClubGameRoomList::has_clubcurnum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResClubGameRoomList::set_has_clubcurnum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResClubGameRoomList::clear_has_clubcurnum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResClubGameRoomList::clear_clubcurnum() {
  clubcurnum_ = 0;
  clear_has_clubcurnum();
}
inline ::google::protobuf::int32 ResClubGameRoomList::clubcurnum() const {
  return clubcurnum_;
}
inline void ResClubGameRoomList::set_clubcurnum(::google::protobuf::int32 value) {
  set_has_clubcurnum();
  clubcurnum_ = value;
}

// optional int32 clubTotalNumLimit = 4;
inline bool ResClubGameRoomList::has_clubtotalnumlimit() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResClubGameRoomList::set_has_clubtotalnumlimit() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResClubGameRoomList::clear_has_clubtotalnumlimit() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResClubGameRoomList::clear_clubtotalnumlimit() {
  clubtotalnumlimit_ = 0;
  clear_has_clubtotalnumlimit();
}
inline ::google::protobuf::int32 ResClubGameRoomList::clubtotalnumlimit() const {
  return clubtotalnumlimit_;
}
inline void ResClubGameRoomList::set_clubtotalnumlimit(::google::protobuf::int32 value) {
  set_has_clubtotalnumlimit();
  clubtotalnumlimit_ = value;
}

// optional int32 onlineTotal = 5;
inline bool ResClubGameRoomList::has_onlinetotal() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResClubGameRoomList::set_has_onlinetotal() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResClubGameRoomList::clear_has_onlinetotal() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResClubGameRoomList::clear_onlinetotal() {
  onlinetotal_ = 0;
  clear_has_onlinetotal();
}
inline ::google::protobuf::int32 ResClubGameRoomList::onlinetotal() const {
  return onlinetotal_;
}
inline void ResClubGameRoomList::set_onlinetotal(::google::protobuf::int32 value) {
  set_has_onlinetotal();
  onlinetotal_ = value;
}

// optional string clubId = 6;
inline bool ResClubGameRoomList::has_clubid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResClubGameRoomList::set_has_clubid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResClubGameRoomList::clear_has_clubid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResClubGameRoomList::clear_clubid() {
  if (clubid_ != &::google::protobuf::internal::kEmptyString) {
    clubid_->clear();
  }
  clear_has_clubid();
}
inline const ::std::string& ResClubGameRoomList::clubid() const {
  return *clubid_;
}
inline void ResClubGameRoomList::set_clubid(const ::std::string& value) {
  set_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    clubid_ = new ::std::string;
  }
  clubid_->assign(value);
}
inline void ResClubGameRoomList::set_clubid(const char* value) {
  set_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    clubid_ = new ::std::string;
  }
  clubid_->assign(value);
}
inline void ResClubGameRoomList::set_clubid(const char* value, size_t size) {
  set_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    clubid_ = new ::std::string;
  }
  clubid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResClubGameRoomList::mutable_clubid() {
  set_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    clubid_ = new ::std::string;
  }
  return clubid_;
}
inline ::std::string* ResClubGameRoomList::release_clubid() {
  clear_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clubid_;
    clubid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResClubGameRoomList::set_allocated_clubid(::std::string* clubid) {
  if (clubid_ != &::google::protobuf::internal::kEmptyString) {
    delete clubid_;
  }
  if (clubid) {
    set_has_clubid();
    clubid_ = clubid;
  } else {
    clear_has_clubid();
    clubid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 totalCard = 7;
inline bool ResClubGameRoomList::has_totalcard() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ResClubGameRoomList::set_has_totalcard() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ResClubGameRoomList::clear_has_totalcard() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ResClubGameRoomList::clear_totalcard() {
  totalcard_ = 0;
  clear_has_totalcard();
}
inline ::google::protobuf::int32 ResClubGameRoomList::totalcard() const {
  return totalcard_;
}
inline void ResClubGameRoomList::set_totalcard(::google::protobuf::int32 value) {
  set_has_totalcard();
  totalcard_ = value;
}

// optional string intro = 8;
inline bool ResClubGameRoomList::has_intro() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ResClubGameRoomList::set_has_intro() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ResClubGameRoomList::clear_has_intro() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ResClubGameRoomList::clear_intro() {
  if (intro_ != &::google::protobuf::internal::kEmptyString) {
    intro_->clear();
  }
  clear_has_intro();
}
inline const ::std::string& ResClubGameRoomList::intro() const {
  return *intro_;
}
inline void ResClubGameRoomList::set_intro(const ::std::string& value) {
  set_has_intro();
  if (intro_ == &::google::protobuf::internal::kEmptyString) {
    intro_ = new ::std::string;
  }
  intro_->assign(value);
}
inline void ResClubGameRoomList::set_intro(const char* value) {
  set_has_intro();
  if (intro_ == &::google::protobuf::internal::kEmptyString) {
    intro_ = new ::std::string;
  }
  intro_->assign(value);
}
inline void ResClubGameRoomList::set_intro(const char* value, size_t size) {
  set_has_intro();
  if (intro_ == &::google::protobuf::internal::kEmptyString) {
    intro_ = new ::std::string;
  }
  intro_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResClubGameRoomList::mutable_intro() {
  set_has_intro();
  if (intro_ == &::google::protobuf::internal::kEmptyString) {
    intro_ = new ::std::string;
  }
  return intro_;
}
inline ::std::string* ResClubGameRoomList::release_intro() {
  clear_has_intro();
  if (intro_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = intro_;
    intro_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResClubGameRoomList::set_allocated_intro(::std::string* intro) {
  if (intro_ != &::google::protobuf::internal::kEmptyString) {
    delete intro_;
  }
  if (intro) {
    set_has_intro();
    intro_ = intro;
  } else {
    clear_has_intro();
    intro_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 playingNum = 9;
inline bool ResClubGameRoomList::has_playingnum() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ResClubGameRoomList::set_has_playingnum() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ResClubGameRoomList::clear_has_playingnum() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ResClubGameRoomList::clear_playingnum() {
  playingnum_ = 0;
  clear_has_playingnum();
}
inline ::google::protobuf::int32 ResClubGameRoomList::playingnum() const {
  return playingnum_;
}
inline void ResClubGameRoomList::set_playingnum(::google::protobuf::int32 value) {
  set_has_playingnum();
  playingnum_ = value;
}

// -------------------------------------------------------------------

// ClubGameRoomList

// required string roomId = 1;
inline bool ClubGameRoomList::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClubGameRoomList::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClubGameRoomList::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClubGameRoomList::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& ClubGameRoomList::roomid() const {
  return *roomid_;
}
inline void ClubGameRoomList::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ClubGameRoomList::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ClubGameRoomList::set_roomid(const char* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClubGameRoomList::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  return roomid_;
}
inline ::std::string* ClubGameRoomList::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClubGameRoomList::set_allocated_roomid(::std::string* roomid) {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomid_;
  }
  if (roomid) {
    set_has_roomid();
    roomid_ = roomid;
  } else {
    clear_has_roomid();
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string paramString = 2;
inline bool ClubGameRoomList::has_paramstring() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClubGameRoomList::set_has_paramstring() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClubGameRoomList::clear_has_paramstring() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClubGameRoomList::clear_paramstring() {
  if (paramstring_ != &::google::protobuf::internal::kEmptyString) {
    paramstring_->clear();
  }
  clear_has_paramstring();
}
inline const ::std::string& ClubGameRoomList::paramstring() const {
  return *paramstring_;
}
inline void ClubGameRoomList::set_paramstring(const ::std::string& value) {
  set_has_paramstring();
  if (paramstring_ == &::google::protobuf::internal::kEmptyString) {
    paramstring_ = new ::std::string;
  }
  paramstring_->assign(value);
}
inline void ClubGameRoomList::set_paramstring(const char* value) {
  set_has_paramstring();
  if (paramstring_ == &::google::protobuf::internal::kEmptyString) {
    paramstring_ = new ::std::string;
  }
  paramstring_->assign(value);
}
inline void ClubGameRoomList::set_paramstring(const char* value, size_t size) {
  set_has_paramstring();
  if (paramstring_ == &::google::protobuf::internal::kEmptyString) {
    paramstring_ = new ::std::string;
  }
  paramstring_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClubGameRoomList::mutable_paramstring() {
  set_has_paramstring();
  if (paramstring_ == &::google::protobuf::internal::kEmptyString) {
    paramstring_ = new ::std::string;
  }
  return paramstring_;
}
inline ::std::string* ClubGameRoomList::release_paramstring() {
  clear_has_paramstring();
  if (paramstring_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = paramstring_;
    paramstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClubGameRoomList::set_allocated_paramstring(::std::string* paramstring) {
  if (paramstring_ != &::google::protobuf::internal::kEmptyString) {
    delete paramstring_;
  }
  if (paramstring) {
    set_has_paramstring();
    paramstring_ = paramstring;
  } else {
    clear_has_paramstring();
    paramstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required double yazhu = 3;
inline bool ClubGameRoomList::has_yazhu() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClubGameRoomList::set_has_yazhu() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClubGameRoomList::clear_has_yazhu() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClubGameRoomList::clear_yazhu() {
  yazhu_ = 0;
  clear_has_yazhu();
}
inline double ClubGameRoomList::yazhu() const {
  return yazhu_;
}
inline void ClubGameRoomList::set_yazhu(double value) {
  set_has_yazhu();
  yazhu_ = value;
}

// required int32 halfWayJoin = 4;
inline bool ClubGameRoomList::has_halfwayjoin() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClubGameRoomList::set_has_halfwayjoin() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClubGameRoomList::clear_has_halfwayjoin() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClubGameRoomList::clear_halfwayjoin() {
  halfwayjoin_ = 0;
  clear_has_halfwayjoin();
}
inline ::google::protobuf::int32 ClubGameRoomList::halfwayjoin() const {
  return halfwayjoin_;
}
inline void ClubGameRoomList::set_halfwayjoin(::google::protobuf::int32 value) {
  set_has_halfwayjoin();
  halfwayjoin_ = value;
}

// required int32 maxPlayerNum = 5;
inline bool ClubGameRoomList::has_maxplayernum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClubGameRoomList::set_has_maxplayernum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClubGameRoomList::clear_has_maxplayernum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClubGameRoomList::clear_maxplayernum() {
  maxplayernum_ = 0;
  clear_has_maxplayernum();
}
inline ::google::protobuf::int32 ClubGameRoomList::maxplayernum() const {
  return maxplayernum_;
}
inline void ClubGameRoomList::set_maxplayernum(::google::protobuf::int32 value) {
  set_has_maxplayernum();
  maxplayernum_ = value;
}

// required int32 fangkaJinbi = 6;
inline bool ClubGameRoomList::has_fangkajinbi() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClubGameRoomList::set_has_fangkajinbi() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClubGameRoomList::clear_has_fangkajinbi() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClubGameRoomList::clear_fangkajinbi() {
  fangkajinbi_ = 0;
  clear_has_fangkajinbi();
}
inline ::google::protobuf::int32 ClubGameRoomList::fangkajinbi() const {
  return fangkajinbi_;
}
inline void ClubGameRoomList::set_fangkajinbi(::google::protobuf::int32 value) {
  set_has_fangkajinbi();
  fangkajinbi_ = value;
}

// required double minNeed = 7;
inline bool ClubGameRoomList::has_minneed() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ClubGameRoomList::set_has_minneed() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ClubGameRoomList::clear_has_minneed() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ClubGameRoomList::clear_minneed() {
  minneed_ = 0;
  clear_has_minneed();
}
inline double ClubGameRoomList::minneed() const {
  return minneed_;
}
inline void ClubGameRoomList::set_minneed(double value) {
  set_has_minneed();
  minneed_ = value;
}

// required string pipeiParam = 8;
inline bool ClubGameRoomList::has_pipeiparam() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ClubGameRoomList::set_has_pipeiparam() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ClubGameRoomList::clear_has_pipeiparam() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ClubGameRoomList::clear_pipeiparam() {
  if (pipeiparam_ != &::google::protobuf::internal::kEmptyString) {
    pipeiparam_->clear();
  }
  clear_has_pipeiparam();
}
inline const ::std::string& ClubGameRoomList::pipeiparam() const {
  return *pipeiparam_;
}
inline void ClubGameRoomList::set_pipeiparam(const ::std::string& value) {
  set_has_pipeiparam();
  if (pipeiparam_ == &::google::protobuf::internal::kEmptyString) {
    pipeiparam_ = new ::std::string;
  }
  pipeiparam_->assign(value);
}
inline void ClubGameRoomList::set_pipeiparam(const char* value) {
  set_has_pipeiparam();
  if (pipeiparam_ == &::google::protobuf::internal::kEmptyString) {
    pipeiparam_ = new ::std::string;
  }
  pipeiparam_->assign(value);
}
inline void ClubGameRoomList::set_pipeiparam(const char* value, size_t size) {
  set_has_pipeiparam();
  if (pipeiparam_ == &::google::protobuf::internal::kEmptyString) {
    pipeiparam_ = new ::std::string;
  }
  pipeiparam_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClubGameRoomList::mutable_pipeiparam() {
  set_has_pipeiparam();
  if (pipeiparam_ == &::google::protobuf::internal::kEmptyString) {
    pipeiparam_ = new ::std::string;
  }
  return pipeiparam_;
}
inline ::std::string* ClubGameRoomList::release_pipeiparam() {
  clear_has_pipeiparam();
  if (pipeiparam_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pipeiparam_;
    pipeiparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClubGameRoomList::set_allocated_pipeiparam(::std::string* pipeiparam) {
  if (pipeiparam_ != &::google::protobuf::internal::kEmptyString) {
    delete pipeiparam_;
  }
  if (pipeiparam) {
    set_has_pipeiparam();
    pipeiparam_ = pipeiparam;
  } else {
    clear_has_pipeiparam();
    pipeiparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .ProtoNet.ServerInfoIpsSafeDetail serverInfo = 9;
inline bool ClubGameRoomList::has_serverinfo() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ClubGameRoomList::set_has_serverinfo() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ClubGameRoomList::clear_has_serverinfo() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ClubGameRoomList::clear_serverinfo() {
  if (serverinfo_ != NULL) serverinfo_->::ProtoNet::ServerInfoIpsSafeDetail::Clear();
  clear_has_serverinfo();
}
inline const ::ProtoNet::ServerInfoIpsSafeDetail& ClubGameRoomList::serverinfo() const {
  return serverinfo_ != NULL ? *serverinfo_ : *default_instance_->serverinfo_;
}
inline ::ProtoNet::ServerInfoIpsSafeDetail* ClubGameRoomList::mutable_serverinfo() {
  set_has_serverinfo();
  if (serverinfo_ == NULL) serverinfo_ = new ::ProtoNet::ServerInfoIpsSafeDetail;
  return serverinfo_;
}
inline ::ProtoNet::ServerInfoIpsSafeDetail* ClubGameRoomList::release_serverinfo() {
  clear_has_serverinfo();
  ::ProtoNet::ServerInfoIpsSafeDetail* temp = serverinfo_;
  serverinfo_ = NULL;
  return temp;
}
inline void ClubGameRoomList::set_allocated_serverinfo(::ProtoNet::ServerInfoIpsSafeDetail* serverinfo) {
  delete serverinfo_;
  serverinfo_ = serverinfo;
  if (serverinfo) {
    set_has_serverinfo();
  } else {
    clear_has_serverinfo();
  }
}

// required int32 gameId = 10;
inline bool ClubGameRoomList::has_gameid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ClubGameRoomList::set_has_gameid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ClubGameRoomList::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ClubGameRoomList::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 ClubGameRoomList::gameid() const {
  return gameid_;
}
inline void ClubGameRoomList::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 currentPlayerNum = 11;
inline bool ClubGameRoomList::has_currentplayernum() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ClubGameRoomList::set_has_currentplayernum() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ClubGameRoomList::clear_has_currentplayernum() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ClubGameRoomList::clear_currentplayernum() {
  currentplayernum_ = 0;
  clear_has_currentplayernum();
}
inline ::google::protobuf::int32 ClubGameRoomList::currentplayernum() const {
  return currentplayernum_;
}
inline void ClubGameRoomList::set_currentplayernum(::google::protobuf::int32 value) {
  set_has_currentplayernum();
  currentplayernum_ = value;
}

// required int32 roomStatus = 12;
inline bool ClubGameRoomList::has_roomstatus() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ClubGameRoomList::set_has_roomstatus() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ClubGameRoomList::clear_has_roomstatus() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ClubGameRoomList::clear_roomstatus() {
  roomstatus_ = 0;
  clear_has_roomstatus();
}
inline ::google::protobuf::int32 ClubGameRoomList::roomstatus() const {
  return roomstatus_;
}
inline void ClubGameRoomList::set_roomstatus(::google::protobuf::int32 value) {
  set_has_roomstatus();
  roomstatus_ = value;
}

// required int32 currentWatchPlayerNum = 13;
inline bool ClubGameRoomList::has_currentwatchplayernum() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ClubGameRoomList::set_has_currentwatchplayernum() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ClubGameRoomList::clear_has_currentwatchplayernum() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ClubGameRoomList::clear_currentwatchplayernum() {
  currentwatchplayernum_ = 0;
  clear_has_currentwatchplayernum();
}
inline ::google::protobuf::int32 ClubGameRoomList::currentwatchplayernum() const {
  return currentwatchplayernum_;
}
inline void ClubGameRoomList::set_currentwatchplayernum(::google::protobuf::int32 value) {
  set_has_currentwatchplayernum();
  currentwatchplayernum_ = value;
}

// required int32 roomType = 14;
inline bool ClubGameRoomList::has_roomtype() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ClubGameRoomList::set_has_roomtype() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ClubGameRoomList::clear_has_roomtype() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ClubGameRoomList::clear_roomtype() {
  roomtype_ = 0;
  clear_has_roomtype();
}
inline ::google::protobuf::int32 ClubGameRoomList::roomtype() const {
  return roomtype_;
}
inline void ClubGameRoomList::set_roomtype(::google::protobuf::int32 value) {
  set_has_roomtype();
  roomtype_ = value;
}

// required int32 timesType = 15;
inline bool ClubGameRoomList::has_timestype() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ClubGameRoomList::set_has_timestype() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ClubGameRoomList::clear_has_timestype() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ClubGameRoomList::clear_timestype() {
  timestype_ = 0;
  clear_has_timestype();
}
inline ::google::protobuf::int32 ClubGameRoomList::timestype() const {
  return timestype_;
}
inline void ClubGameRoomList::set_timestype(::google::protobuf::int32 value) {
  set_has_timestype();
  timestype_ = value;
}

// optional string tableNum = 16;
inline bool ClubGameRoomList::has_tablenum() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ClubGameRoomList::set_has_tablenum() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ClubGameRoomList::clear_has_tablenum() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ClubGameRoomList::clear_tablenum() {
  if (tablenum_ != &::google::protobuf::internal::kEmptyString) {
    tablenum_->clear();
  }
  clear_has_tablenum();
}
inline const ::std::string& ClubGameRoomList::tablenum() const {
  return *tablenum_;
}
inline void ClubGameRoomList::set_tablenum(const ::std::string& value) {
  set_has_tablenum();
  if (tablenum_ == &::google::protobuf::internal::kEmptyString) {
    tablenum_ = new ::std::string;
  }
  tablenum_->assign(value);
}
inline void ClubGameRoomList::set_tablenum(const char* value) {
  set_has_tablenum();
  if (tablenum_ == &::google::protobuf::internal::kEmptyString) {
    tablenum_ = new ::std::string;
  }
  tablenum_->assign(value);
}
inline void ClubGameRoomList::set_tablenum(const char* value, size_t size) {
  set_has_tablenum();
  if (tablenum_ == &::google::protobuf::internal::kEmptyString) {
    tablenum_ = new ::std::string;
  }
  tablenum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClubGameRoomList::mutable_tablenum() {
  set_has_tablenum();
  if (tablenum_ == &::google::protobuf::internal::kEmptyString) {
    tablenum_ = new ::std::string;
  }
  return tablenum_;
}
inline ::std::string* ClubGameRoomList::release_tablenum() {
  clear_has_tablenum();
  if (tablenum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tablenum_;
    tablenum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClubGameRoomList::set_allocated_tablenum(::std::string* tablenum) {
  if (tablenum_ != &::google::protobuf::internal::kEmptyString) {
    delete tablenum_;
  }
  if (tablenum) {
    set_has_tablenum();
    tablenum_ = tablenum;
  } else {
    clear_has_tablenum();
    tablenum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .ProtoNet.RoomRoleInfo roomRoleInfo = 17;
inline int ClubGameRoomList::roomroleinfo_size() const {
  return roomroleinfo_.size();
}
inline void ClubGameRoomList::clear_roomroleinfo() {
  roomroleinfo_.Clear();
}
inline const ::ProtoNet::RoomRoleInfo& ClubGameRoomList::roomroleinfo(int index) const {
  return roomroleinfo_.Get(index);
}
inline ::ProtoNet::RoomRoleInfo* ClubGameRoomList::mutable_roomroleinfo(int index) {
  return roomroleinfo_.Mutable(index);
}
inline ::ProtoNet::RoomRoleInfo* ClubGameRoomList::add_roomroleinfo() {
  return roomroleinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::RoomRoleInfo >&
ClubGameRoomList::roomroleinfo() const {
  return roomroleinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::RoomRoleInfo >*
ClubGameRoomList::mutable_roomroleinfo() {
  return &roomroleinfo_;
}

// optional string roomerUniqueId = 18;
inline bool ClubGameRoomList::has_roomeruniqueid() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ClubGameRoomList::set_has_roomeruniqueid() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ClubGameRoomList::clear_has_roomeruniqueid() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ClubGameRoomList::clear_roomeruniqueid() {
  if (roomeruniqueid_ != &::google::protobuf::internal::kEmptyString) {
    roomeruniqueid_->clear();
  }
  clear_has_roomeruniqueid();
}
inline const ::std::string& ClubGameRoomList::roomeruniqueid() const {
  return *roomeruniqueid_;
}
inline void ClubGameRoomList::set_roomeruniqueid(const ::std::string& value) {
  set_has_roomeruniqueid();
  if (roomeruniqueid_ == &::google::protobuf::internal::kEmptyString) {
    roomeruniqueid_ = new ::std::string;
  }
  roomeruniqueid_->assign(value);
}
inline void ClubGameRoomList::set_roomeruniqueid(const char* value) {
  set_has_roomeruniqueid();
  if (roomeruniqueid_ == &::google::protobuf::internal::kEmptyString) {
    roomeruniqueid_ = new ::std::string;
  }
  roomeruniqueid_->assign(value);
}
inline void ClubGameRoomList::set_roomeruniqueid(const char* value, size_t size) {
  set_has_roomeruniqueid();
  if (roomeruniqueid_ == &::google::protobuf::internal::kEmptyString) {
    roomeruniqueid_ = new ::std::string;
  }
  roomeruniqueid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClubGameRoomList::mutable_roomeruniqueid() {
  set_has_roomeruniqueid();
  if (roomeruniqueid_ == &::google::protobuf::internal::kEmptyString) {
    roomeruniqueid_ = new ::std::string;
  }
  return roomeruniqueid_;
}
inline ::std::string* ClubGameRoomList::release_roomeruniqueid() {
  clear_has_roomeruniqueid();
  if (roomeruniqueid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomeruniqueid_;
    roomeruniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClubGameRoomList::set_allocated_roomeruniqueid(::std::string* roomeruniqueid) {
  if (roomeruniqueid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomeruniqueid_;
  }
  if (roomeruniqueid) {
    set_has_roomeruniqueid();
    roomeruniqueid_ = roomeruniqueid;
  } else {
    clear_has_roomeruniqueid();
    roomeruniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RoomRoleInfo

// required string uniqueId = 1;
inline bool RoomRoleInfo::has_uniqueid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomRoleInfo::set_has_uniqueid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomRoleInfo::clear_has_uniqueid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomRoleInfo::clear_uniqueid() {
  if (uniqueid_ != &::google::protobuf::internal::kEmptyString) {
    uniqueid_->clear();
  }
  clear_has_uniqueid();
}
inline const ::std::string& RoomRoleInfo::uniqueid() const {
  return *uniqueid_;
}
inline void RoomRoleInfo::set_uniqueid(const ::std::string& value) {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  uniqueid_->assign(value);
}
inline void RoomRoleInfo::set_uniqueid(const char* value) {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  uniqueid_->assign(value);
}
inline void RoomRoleInfo::set_uniqueid(const char* value, size_t size) {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  uniqueid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomRoleInfo::mutable_uniqueid() {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  return uniqueid_;
}
inline ::std::string* RoomRoleInfo::release_uniqueid() {
  clear_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uniqueid_;
    uniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomRoleInfo::set_allocated_uniqueid(::std::string* uniqueid) {
  if (uniqueid_ != &::google::protobuf::internal::kEmptyString) {
    delete uniqueid_;
  }
  if (uniqueid) {
    set_has_uniqueid();
    uniqueid_ = uniqueid;
  } else {
    clear_has_uniqueid();
    uniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string nickName = 2;
inline bool RoomRoleInfo::has_nickname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomRoleInfo::set_has_nickname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomRoleInfo::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomRoleInfo::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& RoomRoleInfo::nickname() const {
  return *nickname_;
}
inline void RoomRoleInfo::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void RoomRoleInfo::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void RoomRoleInfo::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomRoleInfo::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* RoomRoleInfo::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomRoleInfo::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string headImg = 3;
inline bool RoomRoleInfo::has_headimg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoomRoleInfo::set_has_headimg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoomRoleInfo::clear_has_headimg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoomRoleInfo::clear_headimg() {
  if (headimg_ != &::google::protobuf::internal::kEmptyString) {
    headimg_->clear();
  }
  clear_has_headimg();
}
inline const ::std::string& RoomRoleInfo::headimg() const {
  return *headimg_;
}
inline void RoomRoleInfo::set_headimg(const ::std::string& value) {
  set_has_headimg();
  if (headimg_ == &::google::protobuf::internal::kEmptyString) {
    headimg_ = new ::std::string;
  }
  headimg_->assign(value);
}
inline void RoomRoleInfo::set_headimg(const char* value) {
  set_has_headimg();
  if (headimg_ == &::google::protobuf::internal::kEmptyString) {
    headimg_ = new ::std::string;
  }
  headimg_->assign(value);
}
inline void RoomRoleInfo::set_headimg(const char* value, size_t size) {
  set_has_headimg();
  if (headimg_ == &::google::protobuf::internal::kEmptyString) {
    headimg_ = new ::std::string;
  }
  headimg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomRoleInfo::mutable_headimg() {
  set_has_headimg();
  if (headimg_ == &::google::protobuf::internal::kEmptyString) {
    headimg_ = new ::std::string;
  }
  return headimg_;
}
inline ::std::string* RoomRoleInfo::release_headimg() {
  clear_has_headimg();
  if (headimg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = headimg_;
    headimg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomRoleInfo::set_allocated_headimg(::std::string* headimg) {
  if (headimg_ != &::google::protobuf::internal::kEmptyString) {
    delete headimg_;
  }
  if (headimg) {
    set_has_headimg();
    headimg_ = headimg;
  } else {
    clear_has_headimg();
    headimg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 head = 4;
inline bool RoomRoleInfo::has_head() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoomRoleInfo::set_has_head() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoomRoleInfo::clear_has_head() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoomRoleInfo::clear_head() {
  head_ = 0;
  clear_has_head();
}
inline ::google::protobuf::int32 RoomRoleInfo::head() const {
  return head_;
}
inline void RoomRoleInfo::set_head(::google::protobuf::int32 value) {
  set_has_head();
  head_ = value;
}

// required int32 pos = 5;
inline bool RoomRoleInfo::has_pos() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RoomRoleInfo::set_has_pos() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RoomRoleInfo::clear_has_pos() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RoomRoleInfo::clear_pos() {
  pos_ = 0;
  clear_has_pos();
}
inline ::google::protobuf::int32 RoomRoleInfo::pos() const {
  return pos_;
}
inline void RoomRoleInfo::set_pos(::google::protobuf::int32 value) {
  set_has_pos();
  pos_ = value;
}

// -------------------------------------------------------------------

// ReqClubPipeiRoom

// optional int32 roomType = 1;
inline bool ReqClubPipeiRoom::has_roomtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqClubPipeiRoom::set_has_roomtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqClubPipeiRoom::clear_has_roomtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqClubPipeiRoom::clear_roomtype() {
  roomtype_ = 0;
  clear_has_roomtype();
}
inline ::google::protobuf::int32 ReqClubPipeiRoom::roomtype() const {
  return roomtype_;
}
inline void ReqClubPipeiRoom::set_roomtype(::google::protobuf::int32 value) {
  set_has_roomtype();
  roomtype_ = value;
}

// optional int32 times = 2;
inline bool ReqClubPipeiRoom::has_times() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqClubPipeiRoom::set_has_times() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqClubPipeiRoom::clear_has_times() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqClubPipeiRoom::clear_times() {
  times_ = 0;
  clear_has_times();
}
inline ::google::protobuf::int32 ReqClubPipeiRoom::times() const {
  return times_;
}
inline void ReqClubPipeiRoom::set_times(::google::protobuf::int32 value) {
  set_has_times();
  times_ = value;
}

// optional string paramString = 3;
inline bool ReqClubPipeiRoom::has_paramstring() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqClubPipeiRoom::set_has_paramstring() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqClubPipeiRoom::clear_has_paramstring() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqClubPipeiRoom::clear_paramstring() {
  if (paramstring_ != &::google::protobuf::internal::kEmptyString) {
    paramstring_->clear();
  }
  clear_has_paramstring();
}
inline const ::std::string& ReqClubPipeiRoom::paramstring() const {
  return *paramstring_;
}
inline void ReqClubPipeiRoom::set_paramstring(const ::std::string& value) {
  set_has_paramstring();
  if (paramstring_ == &::google::protobuf::internal::kEmptyString) {
    paramstring_ = new ::std::string;
  }
  paramstring_->assign(value);
}
inline void ReqClubPipeiRoom::set_paramstring(const char* value) {
  set_has_paramstring();
  if (paramstring_ == &::google::protobuf::internal::kEmptyString) {
    paramstring_ = new ::std::string;
  }
  paramstring_->assign(value);
}
inline void ReqClubPipeiRoom::set_paramstring(const char* value, size_t size) {
  set_has_paramstring();
  if (paramstring_ == &::google::protobuf::internal::kEmptyString) {
    paramstring_ = new ::std::string;
  }
  paramstring_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqClubPipeiRoom::mutable_paramstring() {
  set_has_paramstring();
  if (paramstring_ == &::google::protobuf::internal::kEmptyString) {
    paramstring_ = new ::std::string;
  }
  return paramstring_;
}
inline ::std::string* ReqClubPipeiRoom::release_paramstring() {
  clear_has_paramstring();
  if (paramstring_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = paramstring_;
    paramstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqClubPipeiRoom::set_allocated_paramstring(::std::string* paramstring) {
  if (paramstring_ != &::google::protobuf::internal::kEmptyString) {
    delete paramstring_;
  }
  if (paramstring) {
    set_has_paramstring();
    paramstring_ = paramstring;
  } else {
    clear_has_paramstring();
    paramstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 timesType = 4;
inline bool ReqClubPipeiRoom::has_timestype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqClubPipeiRoom::set_has_timestype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqClubPipeiRoom::clear_has_timestype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqClubPipeiRoom::clear_timestype() {
  timestype_ = 0;
  clear_has_timestype();
}
inline ::google::protobuf::int32 ReqClubPipeiRoom::timestype() const {
  return timestype_;
}
inline void ReqClubPipeiRoom::set_timestype(::google::protobuf::int32 value) {
  set_has_timestype();
  timestype_ = value;
}

// optional int32 halfWayJoin = 5;
inline bool ReqClubPipeiRoom::has_halfwayjoin() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReqClubPipeiRoom::set_has_halfwayjoin() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReqClubPipeiRoom::clear_has_halfwayjoin() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReqClubPipeiRoom::clear_halfwayjoin() {
  halfwayjoin_ = 0;
  clear_has_halfwayjoin();
}
inline ::google::protobuf::int32 ReqClubPipeiRoom::halfwayjoin() const {
  return halfwayjoin_;
}
inline void ReqClubPipeiRoom::set_halfwayjoin(::google::protobuf::int32 value) {
  set_has_halfwayjoin();
  halfwayjoin_ = value;
}

// optional int32 maxPlayerNum = 6;
inline bool ReqClubPipeiRoom::has_maxplayernum() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReqClubPipeiRoom::set_has_maxplayernum() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReqClubPipeiRoom::clear_has_maxplayernum() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReqClubPipeiRoom::clear_maxplayernum() {
  maxplayernum_ = 0;
  clear_has_maxplayernum();
}
inline ::google::protobuf::int32 ReqClubPipeiRoom::maxplayernum() const {
  return maxplayernum_;
}
inline void ReqClubPipeiRoom::set_maxplayernum(::google::protobuf::int32 value) {
  set_has_maxplayernum();
  maxplayernum_ = value;
}

// optional double yazhu = 7;
inline bool ReqClubPipeiRoom::has_yazhu() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ReqClubPipeiRoom::set_has_yazhu() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ReqClubPipeiRoom::clear_has_yazhu() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ReqClubPipeiRoom::clear_yazhu() {
  yazhu_ = 0;
  clear_has_yazhu();
}
inline double ReqClubPipeiRoom::yazhu() const {
  return yazhu_;
}
inline void ReqClubPipeiRoom::set_yazhu(double value) {
  set_has_yazhu();
  yazhu_ = value;
}

// optional int32 gameId = 8;
inline bool ReqClubPipeiRoom::has_gameid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ReqClubPipeiRoom::set_has_gameid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ReqClubPipeiRoom::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ReqClubPipeiRoom::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 ReqClubPipeiRoom::gameid() const {
  return gameid_;
}
inline void ReqClubPipeiRoom::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional int32 clubId = 9;
inline bool ReqClubPipeiRoom::has_clubid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ReqClubPipeiRoom::set_has_clubid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ReqClubPipeiRoom::clear_has_clubid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ReqClubPipeiRoom::clear_clubid() {
  clubid_ = 0;
  clear_has_clubid();
}
inline ::google::protobuf::int32 ReqClubPipeiRoom::clubid() const {
  return clubid_;
}
inline void ReqClubPipeiRoom::set_clubid(::google::protobuf::int32 value) {
  set_has_clubid();
  clubid_ = value;
}

// optional int32 playerId = 10;
inline bool ReqClubPipeiRoom::has_playerid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ReqClubPipeiRoom::set_has_playerid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ReqClubPipeiRoom::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ReqClubPipeiRoom::clear_playerid() {
  playerid_ = 0;
  clear_has_playerid();
}
inline ::google::protobuf::int32 ReqClubPipeiRoom::playerid() const {
  return playerid_;
}
inline void ReqClubPipeiRoom::set_playerid(::google::protobuf::int32 value) {
  set_has_playerid();
  playerid_ = value;
}

// optional int32 payType = 11;
inline bool ReqClubPipeiRoom::has_paytype() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ReqClubPipeiRoom::set_has_paytype() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ReqClubPipeiRoom::clear_has_paytype() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ReqClubPipeiRoom::clear_paytype() {
  paytype_ = 0;
  clear_has_paytype();
}
inline ::google::protobuf::int32 ReqClubPipeiRoom::paytype() const {
  return paytype_;
}
inline void ReqClubPipeiRoom::set_paytype(::google::protobuf::int32 value) {
  set_has_paytype();
  paytype_ = value;
}

// -------------------------------------------------------------------

// ResClubPipeiRoom

// required .ProtoNet.ResponseResult result = 1;
inline bool ResClubPipeiRoom::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResClubPipeiRoom::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResClubPipeiRoom::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResClubPipeiRoom::clear_result() {
  if (result_ != NULL) result_->::ProtoNet::ResponseResult::Clear();
  clear_has_result();
}
inline const ::ProtoNet::ResponseResult& ResClubPipeiRoom::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::ProtoNet::ResponseResult* ResClubPipeiRoom::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::ProtoNet::ResponseResult;
  return result_;
}
inline ::ProtoNet::ResponseResult* ResClubPipeiRoom::release_result() {
  clear_has_result();
  ::ProtoNet::ResponseResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline void ResClubPipeiRoom::set_allocated_result(::ProtoNet::ResponseResult* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// -------------------------------------------------------------------

// ReqExitClubPipeiRoom

// -------------------------------------------------------------------

// ResExitClubPipeiRoom

// required .ProtoNet.ResponseResult result = 1;
inline bool ResExitClubPipeiRoom::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResExitClubPipeiRoom::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResExitClubPipeiRoom::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResExitClubPipeiRoom::clear_result() {
  if (result_ != NULL) result_->::ProtoNet::ResponseResult::Clear();
  clear_has_result();
}
inline const ::ProtoNet::ResponseResult& ResExitClubPipeiRoom::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::ProtoNet::ResponseResult* ResExitClubPipeiRoom::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::ProtoNet::ResponseResult;
  return result_;
}
inline ::ProtoNet::ResponseResult* ResExitClubPipeiRoom::release_result() {
  clear_has_result();
  ::ProtoNet::ResponseResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline void ResExitClubPipeiRoom::set_allocated_result(::ProtoNet::ResponseResult* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// -------------------------------------------------------------------

// ReqClubPipeiRoomStatus

// -------------------------------------------------------------------

// ResClubPipeiRoomStatus

// required .ProtoNet.ResponseResult result = 1;
inline bool ResClubPipeiRoomStatus::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResClubPipeiRoomStatus::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResClubPipeiRoomStatus::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResClubPipeiRoomStatus::clear_result() {
  if (result_ != NULL) result_->::ProtoNet::ResponseResult::Clear();
  clear_has_result();
}
inline const ::ProtoNet::ResponseResult& ResClubPipeiRoomStatus::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::ProtoNet::ResponseResult* ResClubPipeiRoomStatus::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::ProtoNet::ResponseResult;
  return result_;
}
inline ::ProtoNet::ResponseResult* ResClubPipeiRoomStatus::release_result() {
  clear_has_result();
  ::ProtoNet::ResponseResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline void ResClubPipeiRoomStatus::set_allocated_result(::ProtoNet::ResponseResult* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// optional int32 gameId = 2;
inline bool ResClubPipeiRoomStatus::has_gameid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResClubPipeiRoomStatus::set_has_gameid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResClubPipeiRoomStatus::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResClubPipeiRoomStatus::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 ResClubPipeiRoomStatus::gameid() const {
  return gameid_;
}
inline void ResClubPipeiRoomStatus::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional int32 clubId = 3;
inline bool ResClubPipeiRoomStatus::has_clubid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResClubPipeiRoomStatus::set_has_clubid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResClubPipeiRoomStatus::clear_has_clubid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResClubPipeiRoomStatus::clear_clubid() {
  clubid_ = 0;
  clear_has_clubid();
}
inline ::google::protobuf::int32 ResClubPipeiRoomStatus::clubid() const {
  return clubid_;
}
inline void ResClubPipeiRoomStatus::set_clubid(::google::protobuf::int32 value) {
  set_has_clubid();
  clubid_ = value;
}

// optional int32 times = 4;
inline bool ResClubPipeiRoomStatus::has_times() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResClubPipeiRoomStatus::set_has_times() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResClubPipeiRoomStatus::clear_has_times() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResClubPipeiRoomStatus::clear_times() {
  times_ = 0;
  clear_has_times();
}
inline ::google::protobuf::int32 ResClubPipeiRoomStatus::times() const {
  return times_;
}
inline void ResClubPipeiRoomStatus::set_times(::google::protobuf::int32 value) {
  set_has_times();
  times_ = value;
}

// optional string paramString = 5;
inline bool ResClubPipeiRoomStatus::has_paramstring() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResClubPipeiRoomStatus::set_has_paramstring() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResClubPipeiRoomStatus::clear_has_paramstring() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResClubPipeiRoomStatus::clear_paramstring() {
  if (paramstring_ != &::google::protobuf::internal::kEmptyString) {
    paramstring_->clear();
  }
  clear_has_paramstring();
}
inline const ::std::string& ResClubPipeiRoomStatus::paramstring() const {
  return *paramstring_;
}
inline void ResClubPipeiRoomStatus::set_paramstring(const ::std::string& value) {
  set_has_paramstring();
  if (paramstring_ == &::google::protobuf::internal::kEmptyString) {
    paramstring_ = new ::std::string;
  }
  paramstring_->assign(value);
}
inline void ResClubPipeiRoomStatus::set_paramstring(const char* value) {
  set_has_paramstring();
  if (paramstring_ == &::google::protobuf::internal::kEmptyString) {
    paramstring_ = new ::std::string;
  }
  paramstring_->assign(value);
}
inline void ResClubPipeiRoomStatus::set_paramstring(const char* value, size_t size) {
  set_has_paramstring();
  if (paramstring_ == &::google::protobuf::internal::kEmptyString) {
    paramstring_ = new ::std::string;
  }
  paramstring_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResClubPipeiRoomStatus::mutable_paramstring() {
  set_has_paramstring();
  if (paramstring_ == &::google::protobuf::internal::kEmptyString) {
    paramstring_ = new ::std::string;
  }
  return paramstring_;
}
inline ::std::string* ResClubPipeiRoomStatus::release_paramstring() {
  clear_has_paramstring();
  if (paramstring_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = paramstring_;
    paramstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResClubPipeiRoomStatus::set_allocated_paramstring(::std::string* paramstring) {
  if (paramstring_ != &::google::protobuf::internal::kEmptyString) {
    delete paramstring_;
  }
  if (paramstring) {
    set_has_paramstring();
    paramstring_ = paramstring;
  } else {
    clear_has_paramstring();
    paramstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 maxPlayerNum = 6;
inline bool ResClubPipeiRoomStatus::has_maxplayernum() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResClubPipeiRoomStatus::set_has_maxplayernum() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResClubPipeiRoomStatus::clear_has_maxplayernum() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResClubPipeiRoomStatus::clear_maxplayernum() {
  maxplayernum_ = 0;
  clear_has_maxplayernum();
}
inline ::google::protobuf::int32 ResClubPipeiRoomStatus::maxplayernum() const {
  return maxplayernum_;
}
inline void ResClubPipeiRoomStatus::set_maxplayernum(::google::protobuf::int32 value) {
  set_has_maxplayernum();
  maxplayernum_ = value;
}

// optional int32 matchPlayerNum = 7;
inline bool ResClubPipeiRoomStatus::has_matchplayernum() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ResClubPipeiRoomStatus::set_has_matchplayernum() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ResClubPipeiRoomStatus::clear_has_matchplayernum() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ResClubPipeiRoomStatus::clear_matchplayernum() {
  matchplayernum_ = 0;
  clear_has_matchplayernum();
}
inline ::google::protobuf::int32 ResClubPipeiRoomStatus::matchplayernum() const {
  return matchplayernum_;
}
inline void ResClubPipeiRoomStatus::set_matchplayernum(::google::protobuf::int32 value) {
  set_has_matchplayernum();
  matchplayernum_ = value;
}

// -------------------------------------------------------------------

// ResNotifyClubPipeiSuc

// optional string clubId = 1;
inline bool ResNotifyClubPipeiSuc::has_clubid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResNotifyClubPipeiSuc::set_has_clubid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResNotifyClubPipeiSuc::clear_has_clubid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResNotifyClubPipeiSuc::clear_clubid() {
  if (clubid_ != &::google::protobuf::internal::kEmptyString) {
    clubid_->clear();
  }
  clear_has_clubid();
}
inline const ::std::string& ResNotifyClubPipeiSuc::clubid() const {
  return *clubid_;
}
inline void ResNotifyClubPipeiSuc::set_clubid(const ::std::string& value) {
  set_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    clubid_ = new ::std::string;
  }
  clubid_->assign(value);
}
inline void ResNotifyClubPipeiSuc::set_clubid(const char* value) {
  set_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    clubid_ = new ::std::string;
  }
  clubid_->assign(value);
}
inline void ResNotifyClubPipeiSuc::set_clubid(const char* value, size_t size) {
  set_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    clubid_ = new ::std::string;
  }
  clubid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResNotifyClubPipeiSuc::mutable_clubid() {
  set_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    clubid_ = new ::std::string;
  }
  return clubid_;
}
inline ::std::string* ResNotifyClubPipeiSuc::release_clubid() {
  clear_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clubid_;
    clubid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResNotifyClubPipeiSuc::set_allocated_clubid(::std::string* clubid) {
  if (clubid_ != &::google::protobuf::internal::kEmptyString) {
    delete clubid_;
  }
  if (clubid) {
    set_has_clubid();
    clubid_ = clubid;
  } else {
    clear_has_clubid();
    clubid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string roomId = 2;
inline bool ResNotifyClubPipeiSuc::has_roomid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResNotifyClubPipeiSuc::set_has_roomid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResNotifyClubPipeiSuc::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResNotifyClubPipeiSuc::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& ResNotifyClubPipeiSuc::roomid() const {
  return *roomid_;
}
inline void ResNotifyClubPipeiSuc::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ResNotifyClubPipeiSuc::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ResNotifyClubPipeiSuc::set_roomid(const char* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResNotifyClubPipeiSuc::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  return roomid_;
}
inline ::std::string* ResNotifyClubPipeiSuc::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResNotifyClubPipeiSuc::set_allocated_roomid(::std::string* roomid) {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomid_;
  }
  if (roomid) {
    set_has_roomid();
    roomid_ = roomid;
  } else {
    clear_has_roomid();
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 roomType = 3;
inline bool ResNotifyClubPipeiSuc::has_roomtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResNotifyClubPipeiSuc::set_has_roomtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResNotifyClubPipeiSuc::clear_has_roomtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResNotifyClubPipeiSuc::clear_roomtype() {
  roomtype_ = 0;
  clear_has_roomtype();
}
inline ::google::protobuf::int32 ResNotifyClubPipeiSuc::roomtype() const {
  return roomtype_;
}
inline void ResNotifyClubPipeiSuc::set_roomtype(::google::protobuf::int32 value) {
  set_has_roomtype();
  roomtype_ = value;
}

// optional int32 times = 4;
inline bool ResNotifyClubPipeiSuc::has_times() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResNotifyClubPipeiSuc::set_has_times() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResNotifyClubPipeiSuc::clear_has_times() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResNotifyClubPipeiSuc::clear_times() {
  times_ = 0;
  clear_has_times();
}
inline ::google::protobuf::int32 ResNotifyClubPipeiSuc::times() const {
  return times_;
}
inline void ResNotifyClubPipeiSuc::set_times(::google::protobuf::int32 value) {
  set_has_times();
  times_ = value;
}

// optional string paramString = 5;
inline bool ResNotifyClubPipeiSuc::has_paramstring() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResNotifyClubPipeiSuc::set_has_paramstring() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResNotifyClubPipeiSuc::clear_has_paramstring() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResNotifyClubPipeiSuc::clear_paramstring() {
  if (paramstring_ != &::google::protobuf::internal::kEmptyString) {
    paramstring_->clear();
  }
  clear_has_paramstring();
}
inline const ::std::string& ResNotifyClubPipeiSuc::paramstring() const {
  return *paramstring_;
}
inline void ResNotifyClubPipeiSuc::set_paramstring(const ::std::string& value) {
  set_has_paramstring();
  if (paramstring_ == &::google::protobuf::internal::kEmptyString) {
    paramstring_ = new ::std::string;
  }
  paramstring_->assign(value);
}
inline void ResNotifyClubPipeiSuc::set_paramstring(const char* value) {
  set_has_paramstring();
  if (paramstring_ == &::google::protobuf::internal::kEmptyString) {
    paramstring_ = new ::std::string;
  }
  paramstring_->assign(value);
}
inline void ResNotifyClubPipeiSuc::set_paramstring(const char* value, size_t size) {
  set_has_paramstring();
  if (paramstring_ == &::google::protobuf::internal::kEmptyString) {
    paramstring_ = new ::std::string;
  }
  paramstring_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResNotifyClubPipeiSuc::mutable_paramstring() {
  set_has_paramstring();
  if (paramstring_ == &::google::protobuf::internal::kEmptyString) {
    paramstring_ = new ::std::string;
  }
  return paramstring_;
}
inline ::std::string* ResNotifyClubPipeiSuc::release_paramstring() {
  clear_has_paramstring();
  if (paramstring_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = paramstring_;
    paramstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResNotifyClubPipeiSuc::set_allocated_paramstring(::std::string* paramstring) {
  if (paramstring_ != &::google::protobuf::internal::kEmptyString) {
    delete paramstring_;
  }
  if (paramstring) {
    set_has_paramstring();
    paramstring_ = paramstring;
  } else {
    clear_has_paramstring();
    paramstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 timesType = 6;
inline bool ResNotifyClubPipeiSuc::has_timestype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResNotifyClubPipeiSuc::set_has_timestype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResNotifyClubPipeiSuc::clear_has_timestype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResNotifyClubPipeiSuc::clear_timestype() {
  timestype_ = 0;
  clear_has_timestype();
}
inline ::google::protobuf::int32 ResNotifyClubPipeiSuc::timestype() const {
  return timestype_;
}
inline void ResNotifyClubPipeiSuc::set_timestype(::google::protobuf::int32 value) {
  set_has_timestype();
  timestype_ = value;
}

// optional int32 halfWayJoin = 7;
inline bool ResNotifyClubPipeiSuc::has_halfwayjoin() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ResNotifyClubPipeiSuc::set_has_halfwayjoin() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ResNotifyClubPipeiSuc::clear_has_halfwayjoin() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ResNotifyClubPipeiSuc::clear_halfwayjoin() {
  halfwayjoin_ = 0;
  clear_has_halfwayjoin();
}
inline ::google::protobuf::int32 ResNotifyClubPipeiSuc::halfwayjoin() const {
  return halfwayjoin_;
}
inline void ResNotifyClubPipeiSuc::set_halfwayjoin(::google::protobuf::int32 value) {
  set_has_halfwayjoin();
  halfwayjoin_ = value;
}

// optional int32 maxPlayerNum = 8;
inline bool ResNotifyClubPipeiSuc::has_maxplayernum() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ResNotifyClubPipeiSuc::set_has_maxplayernum() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ResNotifyClubPipeiSuc::clear_has_maxplayernum() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ResNotifyClubPipeiSuc::clear_maxplayernum() {
  maxplayernum_ = 0;
  clear_has_maxplayernum();
}
inline ::google::protobuf::int32 ResNotifyClubPipeiSuc::maxplayernum() const {
  return maxplayernum_;
}
inline void ResNotifyClubPipeiSuc::set_maxplayernum(::google::protobuf::int32 value) {
  set_has_maxplayernum();
  maxplayernum_ = value;
}

// optional double yazhu = 9;
inline bool ResNotifyClubPipeiSuc::has_yazhu() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ResNotifyClubPipeiSuc::set_has_yazhu() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ResNotifyClubPipeiSuc::clear_has_yazhu() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ResNotifyClubPipeiSuc::clear_yazhu() {
  yazhu_ = 0;
  clear_has_yazhu();
}
inline double ResNotifyClubPipeiSuc::yazhu() const {
  return yazhu_;
}
inline void ResNotifyClubPipeiSuc::set_yazhu(double value) {
  set_has_yazhu();
  yazhu_ = value;
}

// optional int32 gameId = 10;
inline bool ResNotifyClubPipeiSuc::has_gameid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ResNotifyClubPipeiSuc::set_has_gameid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ResNotifyClubPipeiSuc::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ResNotifyClubPipeiSuc::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 ResNotifyClubPipeiSuc::gameid() const {
  return gameid_;
}
inline void ResNotifyClubPipeiSuc::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional .ProtoNet.ServerInfoIpsSafeDetail serverInfo = 11;
inline bool ResNotifyClubPipeiSuc::has_serverinfo() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ResNotifyClubPipeiSuc::set_has_serverinfo() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ResNotifyClubPipeiSuc::clear_has_serverinfo() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ResNotifyClubPipeiSuc::clear_serverinfo() {
  if (serverinfo_ != NULL) serverinfo_->::ProtoNet::ServerInfoIpsSafeDetail::Clear();
  clear_has_serverinfo();
}
inline const ::ProtoNet::ServerInfoIpsSafeDetail& ResNotifyClubPipeiSuc::serverinfo() const {
  return serverinfo_ != NULL ? *serverinfo_ : *default_instance_->serverinfo_;
}
inline ::ProtoNet::ServerInfoIpsSafeDetail* ResNotifyClubPipeiSuc::mutable_serverinfo() {
  set_has_serverinfo();
  if (serverinfo_ == NULL) serverinfo_ = new ::ProtoNet::ServerInfoIpsSafeDetail;
  return serverinfo_;
}
inline ::ProtoNet::ServerInfoIpsSafeDetail* ResNotifyClubPipeiSuc::release_serverinfo() {
  clear_has_serverinfo();
  ::ProtoNet::ServerInfoIpsSafeDetail* temp = serverinfo_;
  serverinfo_ = NULL;
  return temp;
}
inline void ResNotifyClubPipeiSuc::set_allocated_serverinfo(::ProtoNet::ServerInfoIpsSafeDetail* serverinfo) {
  delete serverinfo_;
  serverinfo_ = serverinfo;
  if (serverinfo) {
    set_has_serverinfo();
  } else {
    clear_has_serverinfo();
  }
}

// -------------------------------------------------------------------

// ResNotifyRefreshClubGameRoomList

// -------------------------------------------------------------------

// ResNotifyRefreshClubRedBotNews

// -------------------------------------------------------------------

// ResNotifyClubDismiss

// optional string clubId = 1;
inline bool ResNotifyClubDismiss::has_clubid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResNotifyClubDismiss::set_has_clubid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResNotifyClubDismiss::clear_has_clubid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResNotifyClubDismiss::clear_clubid() {
  if (clubid_ != &::google::protobuf::internal::kEmptyString) {
    clubid_->clear();
  }
  clear_has_clubid();
}
inline const ::std::string& ResNotifyClubDismiss::clubid() const {
  return *clubid_;
}
inline void ResNotifyClubDismiss::set_clubid(const ::std::string& value) {
  set_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    clubid_ = new ::std::string;
  }
  clubid_->assign(value);
}
inline void ResNotifyClubDismiss::set_clubid(const char* value) {
  set_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    clubid_ = new ::std::string;
  }
  clubid_->assign(value);
}
inline void ResNotifyClubDismiss::set_clubid(const char* value, size_t size) {
  set_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    clubid_ = new ::std::string;
  }
  clubid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResNotifyClubDismiss::mutable_clubid() {
  set_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    clubid_ = new ::std::string;
  }
  return clubid_;
}
inline ::std::string* ResNotifyClubDismiss::release_clubid() {
  clear_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clubid_;
    clubid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResNotifyClubDismiss::set_allocated_clubid(::std::string* clubid) {
  if (clubid_ != &::google::protobuf::internal::kEmptyString) {
    delete clubid_;
  }
  if (clubid) {
    set_has_clubid();
    clubid_ = clubid;
  } else {
    clear_has_clubid();
    clubid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ResNotifyClubKickedOut

// optional string clubId = 1;
inline bool ResNotifyClubKickedOut::has_clubid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResNotifyClubKickedOut::set_has_clubid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResNotifyClubKickedOut::clear_has_clubid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResNotifyClubKickedOut::clear_clubid() {
  if (clubid_ != &::google::protobuf::internal::kEmptyString) {
    clubid_->clear();
  }
  clear_has_clubid();
}
inline const ::std::string& ResNotifyClubKickedOut::clubid() const {
  return *clubid_;
}
inline void ResNotifyClubKickedOut::set_clubid(const ::std::string& value) {
  set_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    clubid_ = new ::std::string;
  }
  clubid_->assign(value);
}
inline void ResNotifyClubKickedOut::set_clubid(const char* value) {
  set_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    clubid_ = new ::std::string;
  }
  clubid_->assign(value);
}
inline void ResNotifyClubKickedOut::set_clubid(const char* value, size_t size) {
  set_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    clubid_ = new ::std::string;
  }
  clubid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResNotifyClubKickedOut::mutable_clubid() {
  set_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    clubid_ = new ::std::string;
  }
  return clubid_;
}
inline ::std::string* ResNotifyClubKickedOut::release_clubid() {
  clear_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clubid_;
    clubid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResNotifyClubKickedOut::set_allocated_clubid(::std::string* clubid) {
  if (clubid_ != &::google::protobuf::internal::kEmptyString) {
    delete clubid_;
  }
  if (clubid) {
    set_has_clubid();
    clubid_ = clubid;
  } else {
    clear_has_clubid();
    clubid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ResNotifyClubChangeGameType

// optional string clubId = 1;
inline bool ResNotifyClubChangeGameType::has_clubid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResNotifyClubChangeGameType::set_has_clubid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResNotifyClubChangeGameType::clear_has_clubid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResNotifyClubChangeGameType::clear_clubid() {
  if (clubid_ != &::google::protobuf::internal::kEmptyString) {
    clubid_->clear();
  }
  clear_has_clubid();
}
inline const ::std::string& ResNotifyClubChangeGameType::clubid() const {
  return *clubid_;
}
inline void ResNotifyClubChangeGameType::set_clubid(const ::std::string& value) {
  set_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    clubid_ = new ::std::string;
  }
  clubid_->assign(value);
}
inline void ResNotifyClubChangeGameType::set_clubid(const char* value) {
  set_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    clubid_ = new ::std::string;
  }
  clubid_->assign(value);
}
inline void ResNotifyClubChangeGameType::set_clubid(const char* value, size_t size) {
  set_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    clubid_ = new ::std::string;
  }
  clubid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResNotifyClubChangeGameType::mutable_clubid() {
  set_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    clubid_ = new ::std::string;
  }
  return clubid_;
}
inline ::std::string* ResNotifyClubChangeGameType::release_clubid() {
  clear_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clubid_;
    clubid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResNotifyClubChangeGameType::set_allocated_clubid(::std::string* clubid) {
  if (clubid_ != &::google::protobuf::internal::kEmptyString) {
    delete clubid_;
  }
  if (clubid) {
    set_has_clubid();
    clubid_ = clubid;
  } else {
    clear_has_clubid();
    clubid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ProtoNet

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_MsgGate_2eproto__INCLUDED
