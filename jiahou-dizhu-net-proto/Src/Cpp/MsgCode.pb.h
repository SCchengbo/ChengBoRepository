// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MsgCode.proto

#ifndef PROTOBUF_MsgCode_2eproto__INCLUDED
#define PROTOBUF_MsgCode_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace ProtoNet {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_MsgCode_2eproto();
void protobuf_AssignDesc_MsgCode_2eproto();
void protobuf_ShutdownFile_MsgCode_2eproto();

class ResponseResult;
class PlayerAccount;
class ResNotifyAlert;
class ResNotifyDissolutionConnect;
class ResNotifyChatArrive;
class ResChat;
class ReqChat;
class ResNotifyBeKickOut;
class ResExceptionCatch;
class ResConnectCreat;
class ReqHeartBeat;
class ResHeartBeat;

enum RoomType {
  GOLD_ROOM = 1,
  CARD_ROOM = 2,
  MATCH_ROOM = 3,
  SHANGZHUANG_ROOM = 4
};
bool RoomType_IsValid(int value);
const RoomType RoomType_MIN = GOLD_ROOM;
const RoomType RoomType_MAX = SHANGZHUANG_ROOM;
const int RoomType_ARRAYSIZE = RoomType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoomType_descriptor();
inline const ::std::string& RoomType_Name(RoomType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoomType_descriptor(), value);
}
inline bool RoomType_Parse(
    const ::std::string& name, RoomType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoomType>(
    RoomType_descriptor(), name, value);
}
enum GameCode {
  REQ_GET_MATCH_LIST = 699999,
  RES_GET_MATCH_LIST = 699998,
  REQ_SIGNUP_MATCH = 699997,
  RES_SIGNUP_MATCH = 699996,
  RES_NOTIFY_ENTER_MATCH = 699995,
  REQ_CANLE_SIGN_MATCH = 699994,
  RES_CANLE_SIGN_MATCH = 699993,
  RES_NOTIFY_MATCHROOM_WAITTING_CHANGE = 699992,
  RES_NOTIFY_TIMES_OVER = 699991,
  REQ_CONTINUE_MATCH = 699990,
  RES_CONTINUE_MATCH = 699989,
  REQ_GATE_LOGIN = 899999,
  RES_GATE_LOGIN = 899998,
  REQ_GET_ACCOUNTINFO = 899997,
  RES_GET_ACCOUNTINFO = 899996,
  REQ_GET_GAMEZONEINFO_LIST = 899995,
  RES_GET_GAMEZONEINFO_LIST = 899994,
  REQ_GET_GAMEZONE_DETAIL = 899993,
  RES_GET_GAMEZONE_DETAIL = 899992,
  REQ_JOIN_LOGIC_GAMEROOM = 899991,
  RES_JOIN_LOGIC_GAMEROOM = 899990,
  REQ_QUICK_JOIN_GAMEROOM = 899989,
  RES_QUICK_JOIN_GAMEROOM = 899988,
  RES_NOTIFY_BROAD_PLAT_MARQUEE = 899987,
  RES_NOTIFY_SELF_DATA_CHANGE = 899986,
  REQ_GET_ROOMBRIFE_LIST = 899985,
  RES_GET_ROOMBRIFE_LIST = 899984,
  REQ_CHECK_IN_MATCH = 899983,
  RES_CHECK_IN_MATCH = 899982,
  REQ_OPEN_ROOM_REPLACE = 899981,
  RES_OPEN_ROOM_REPLACE = 899980,
  REQ_OPEN_ROOM_REPLACE_RECORD_LIST = 899979,
  RES_OPEN_ROOM_REPLACE_RECORD_LIST = 899978,
  REQ_DISSOLUTION_OPEN_ROOM_REPLACE = 899977,
  RES_DISSOLUTION_OPEN_ROOM_REPLACE = 899976,
  REQ_GAME_ROOM_LIST = 899975,
  RES_GAME_ROOM_LIST = 899974,
  REQ_CLUB_GAME_ROOM_LIST = 899973,
  RES_CLUB_GAME_ROOM_LIST = 899972,
  REQ_CLUB_PIPEI_ROOM = 899971,
  RES_CLUB_PIPEI_ROOM = 899970,
  REQ_EXIT_CLUB_PIPEI_ROOM = 899969,
  RES_EXIT_CLUB_PIPEI_ROOM = 899968,
  REQ_CLUB_PIPEI_ROOM_STATUS = 899967,
  RES_CLUB_PIPEI_ROOM_STATUS = 899966,
  RES_NOTIFY_CLUB_PIPEI_SUC = 899965,
  RES_NOTIFY_REFRESH_CLUB_GAME_ROOM_LIST = 899964,
  RES_NOTIFY_REFRESH_CLUB_RED_BOT_NEWS = 899963,
  RES_NOTIFY_CLUB_DISMISS = 899962,
  RES_NOTIFY_CLUB_KICKED_OUT = 899961,
  RES_NOTIFY_CLUB_CHANGE_GAME_TYPE = 899960,
  REQ_LOGIC_LOGIN = 799999,
  RES_LOGIC_LOGIN = 799998,
  REQ_CREATE_GAMEROOM = 799997,
  RES_CREATE_GAMEROOM = 799996,
  RES_NOTIFY_GAMEROOM_CREATE = 799995,
  REQ_JOIN_GAMEROOM = 799994,
  RES_JOIN_GAMEROOM = 799993,
  RES_NOTIFY_SOMEONE_JOIN_GAMEROOM = 799992,
  REQ_EXIT_GAMEROOM = 799991,
  RES_EXIT_GAMEROOM = 799990,
  RES_NOTIFY_SOMEONE_EXIT_GAMEROOM = 799989,
  REQ_GAME_READY = 799988,
  RES_GAME_READY = 799987,
  REQ_DISSOLUTION_GAMEROOM = 799983,
  RES_DISSOLUTION_GAMEROOM = 799982,
  RES_NOTIFY_SOMEONE_REQ_DISSOLUTION_GAMEROOM = 799981,
  REQ_AGREE_DISSOLUTION_GAMEROOM = 799980,
  RES_AGREE_DISSOLUTION_GAMEROOM = 799979,
  RES_NOTIFY_SOMEONE_AGREE_DISSOLUTION_GAMEROOM = 799978,
  RES_NOTIFY_GAMEROOM_DISSOLUTION = 799977,
  RES_NOTIFY_GAMEOVER = 799976,
  REQ_GET_ROOM_INFO = 799975,
  RES_GET_ROOM_INFO = 799974,
  RES_NOTIFY_SOMEONE_GAME_READY = 799973,
  REQ_CHANGE_ONLINE_STATUS = 799972,
  RES_CHANGE_ONLINE_STATUS = 799971,
  RES_NOTIFY_SOMEONE_CHANGE_ONLINE_STATUS = 799970,
  RES_NOTIFY_BIG_CALCULATE_PANEL = 799969,
  REQ_CORRECT_TIMER = 799966,
  RES_CORRECT_TIMER = 799965,
  REQ_QUICK_CHANGE_ROOM = 799964,
  RES_QUICK_CHANGE_ROOM = 799963,
  RES_NOTIFY_SOMEONE_CHANGE_ROBOT = 799962,
  RES_NOTIFY_CHANGE_TO_OLDROOM = 799961,
  REQ_SIT_DOWN = 799960,
  RES_SIT_DOWN = 799959,
  RES_NOTIFY_SOMEONE_SIT_DOWN = 799958,
  REQ_STAND_UP = 799957,
  RES_STAND_UP = 799956,
  RES_NOTIFY_SOMEONE_STAND_UP = 799955,
  RES_NOTIFY_SOMEONE_ENTER_CHARGE = 799954,
  RES_NOTIFY_ACCOUNTS_CHANGE = 799953,
  RES_NOTIFY_CHARGE_OVER = 799952,
  REQ_WATCHER_LIST = 799951,
  RES_WATCHER_LIST = 799950,
  REQ_ONCE_MORE = 799948,
  RES_ONCE_MORE = 799949,
  RES_ONOTIFY_ONCE_MORE = 799947,
  REQ_LOGIC_SERVER_TIME = 799946,
  RES_LOGIC_SERVER_TIME = 799945,
  REQ_SEAT_DOWN = 799799,
  RES_SEAT_DOWN = 799798,
  REQ_BE_WATHER = 799797,
  RES_BE_WATHER = 799796,
  RES_NOTIFY_ADD_WATHER = 799795,
  RES_NOTIFY_REMOVE_WATHER = 799794,
  RES_NOTIFY_DISSOLUTION_CONNECT = 999990,
  RES_NOTIFY_CHAT_ARRIVE = 999991,
  RES_CHAT = 999992,
  REQ_CHAT = 999993,
  RES_NOTIFY_BE_KICK_OUT = 999994,
  RES_EXCEPTION_CATCH = 999995,
  RES_HEART_BEAT = 999996,
  REQ_HEART_BEAT = 999997,
  RES_CONNECT_CREATE = 999998,
  RES_NOTIFY_ALERT = 999999
};
bool GameCode_IsValid(int value);
const GameCode GameCode_MIN = RES_CONTINUE_MATCH;
const GameCode GameCode_MAX = RES_NOTIFY_ALERT;
const int GameCode_ARRAYSIZE = GameCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* GameCode_descriptor();
inline const ::std::string& GameCode_Name(GameCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    GameCode_descriptor(), value);
}
inline bool GameCode_Parse(
    const ::std::string& name, GameCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GameCode>(
    GameCode_descriptor(), name, value);
}
// ===================================================================

class ResponseResult : public ::google::protobuf::Message {
 public:
  ResponseResult();
  virtual ~ResponseResult();

  ResponseResult(const ResponseResult& from);

  inline ResponseResult& operator=(const ResponseResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResponseResult& default_instance();

  void Swap(ResponseResult* other);

  // implements Message ----------------------------------------------

  ResponseResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResponseResult& from);
  void MergeFrom(const ResponseResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // required bool success = 2;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 2;
  inline bool success() const;
  inline void set_success(bool value);

  // optional string msg = 3;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 3;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResponseResult)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_msg();
  inline void clear_has_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 code_;
  bool success_;
  ::std::string* msg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_MsgCode_2eproto();
  friend void protobuf_AssignDesc_MsgCode_2eproto();
  friend void protobuf_ShutdownFile_MsgCode_2eproto();

  void InitAsDefaultInstance();
  static ResponseResult* default_instance_;
};
// -------------------------------------------------------------------

class PlayerAccount : public ::google::protobuf::Message {
 public:
  PlayerAccount();
  virtual ~PlayerAccount();

  PlayerAccount(const PlayerAccount& from);

  inline PlayerAccount& operator=(const PlayerAccount& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerAccount& default_instance();

  void Swap(PlayerAccount* other);

  // implements Message ----------------------------------------------

  PlayerAccount* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerAccount& from);
  void MergeFrom(const PlayerAccount& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional double count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline double count() const;
  inline void set_count(double value);

  // optional double bankcount = 3;
  inline bool has_bankcount() const;
  inline void clear_bankcount();
  static const int kBankcountFieldNumber = 3;
  inline double bankcount() const;
  inline void set_bankcount(double value);

  // @@protoc_insertion_point(class_scope:ProtoNet.PlayerAccount)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_bankcount();
  inline void clear_has_bankcount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double count_;
  double bankcount_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_MsgCode_2eproto();
  friend void protobuf_AssignDesc_MsgCode_2eproto();
  friend void protobuf_ShutdownFile_MsgCode_2eproto();

  void InitAsDefaultInstance();
  static PlayerAccount* default_instance_;
};
// -------------------------------------------------------------------

class ResNotifyAlert : public ::google::protobuf::Message {
 public:
  ResNotifyAlert();
  virtual ~ResNotifyAlert();

  ResNotifyAlert(const ResNotifyAlert& from);

  inline ResNotifyAlert& operator=(const ResNotifyAlert& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResNotifyAlert& default_instance();

  void Swap(ResNotifyAlert* other);

  // implements Message ----------------------------------------------

  ResNotifyAlert* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResNotifyAlert& from);
  void MergeFrom(const ResNotifyAlert& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string msg = 1;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 1;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // required string extendStr = 2;
  inline bool has_extendstr() const;
  inline void clear_extendstr();
  static const int kExtendStrFieldNumber = 2;
  inline const ::std::string& extendstr() const;
  inline void set_extendstr(const ::std::string& value);
  inline void set_extendstr(const char* value);
  inline void set_extendstr(const char* value, size_t size);
  inline ::std::string* mutable_extendstr();
  inline ::std::string* release_extendstr();
  inline void set_allocated_extendstr(::std::string* extendstr);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResNotifyAlert)
 private:
  inline void set_has_msg();
  inline void clear_has_msg();
  inline void set_has_extendstr();
  inline void clear_has_extendstr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msg_;
  ::std::string* extendstr_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MsgCode_2eproto();
  friend void protobuf_AssignDesc_MsgCode_2eproto();
  friend void protobuf_ShutdownFile_MsgCode_2eproto();

  void InitAsDefaultInstance();
  static ResNotifyAlert* default_instance_;
};
// -------------------------------------------------------------------

class ResNotifyDissolutionConnect : public ::google::protobuf::Message {
 public:
  ResNotifyDissolutionConnect();
  virtual ~ResNotifyDissolutionConnect();

  ResNotifyDissolutionConnect(const ResNotifyDissolutionConnect& from);

  inline ResNotifyDissolutionConnect& operator=(const ResNotifyDissolutionConnect& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResNotifyDissolutionConnect& default_instance();

  void Swap(ResNotifyDissolutionConnect* other);

  // implements Message ----------------------------------------------

  ResNotifyDissolutionConnect* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResNotifyDissolutionConnect& from);
  void MergeFrom(const ResNotifyDissolutionConnect& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);

  // required int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional string msg = 3;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 3;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResNotifyDissolutionConnect)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_msg();
  inline void clear_has_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 type_;
  ::std::string* msg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_MsgCode_2eproto();
  friend void protobuf_AssignDesc_MsgCode_2eproto();
  friend void protobuf_ShutdownFile_MsgCode_2eproto();

  void InitAsDefaultInstance();
  static ResNotifyDissolutionConnect* default_instance_;
};
// -------------------------------------------------------------------

class ResNotifyChatArrive : public ::google::protobuf::Message {
 public:
  ResNotifyChatArrive();
  virtual ~ResNotifyChatArrive();

  ResNotifyChatArrive(const ResNotifyChatArrive& from);

  inline ResNotifyChatArrive& operator=(const ResNotifyChatArrive& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResNotifyChatArrive& default_instance();

  void Swap(ResNotifyChatArrive* other);

  // implements Message ----------------------------------------------

  ResNotifyChatArrive* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResNotifyChatArrive& from);
  void MergeFrom(const ResNotifyChatArrive& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string msgId = 1;
  inline bool has_msgid() const;
  inline void clear_msgid();
  static const int kMsgIdFieldNumber = 1;
  inline const ::std::string& msgid() const;
  inline void set_msgid(const ::std::string& value);
  inline void set_msgid(const char* value);
  inline void set_msgid(const char* value, size_t size);
  inline ::std::string* mutable_msgid();
  inline ::std::string* release_msgid();
  inline void set_allocated_msgid(::std::string* msgid);

  // required int32 msgType = 2;
  inline bool has_msgtype() const;
  inline void clear_msgtype();
  static const int kMsgTypeFieldNumber = 2;
  inline ::google::protobuf::int32 msgtype() const;
  inline void set_msgtype(::google::protobuf::int32 value);

  // required string msg = 3;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 3;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // required int32 chanel = 4;
  inline bool has_chanel() const;
  inline void clear_chanel();
  static const int kChanelFieldNumber = 4;
  inline ::google::protobuf::int32 chanel() const;
  inline void set_chanel(::google::protobuf::int32 value);

  // required int64 msgCreateTime = 5;
  inline bool has_msgcreatetime() const;
  inline void clear_msgcreatetime();
  static const int kMsgCreateTimeFieldNumber = 5;
  inline ::google::protobuf::int64 msgcreatetime() const;
  inline void set_msgcreatetime(::google::protobuf::int64 value);

  // required string fromUniqueId = 6;
  inline bool has_fromuniqueid() const;
  inline void clear_fromuniqueid();
  static const int kFromUniqueIdFieldNumber = 6;
  inline const ::std::string& fromuniqueid() const;
  inline void set_fromuniqueid(const ::std::string& value);
  inline void set_fromuniqueid(const char* value);
  inline void set_fromuniqueid(const char* value, size_t size);
  inline ::std::string* mutable_fromuniqueid();
  inline ::std::string* release_fromuniqueid();
  inline void set_allocated_fromuniqueid(::std::string* fromuniqueid);

  // optional int32 pos = 7;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 7;
  inline ::google::protobuf::int32 pos() const;
  inline void set_pos(::google::protobuf::int32 value);

  // optional string fromControllerNick = 8;
  inline bool has_fromcontrollernick() const;
  inline void clear_fromcontrollernick();
  static const int kFromControllerNickFieldNumber = 8;
  inline const ::std::string& fromcontrollernick() const;
  inline void set_fromcontrollernick(const ::std::string& value);
  inline void set_fromcontrollernick(const char* value);
  inline void set_fromcontrollernick(const char* value, size_t size);
  inline ::std::string* mutable_fromcontrollernick();
  inline ::std::string* release_fromcontrollernick();
  inline void set_allocated_fromcontrollernick(::std::string* fromcontrollernick);

  // optional string fromControllerHeadurl = 9;
  inline bool has_fromcontrollerheadurl() const;
  inline void clear_fromcontrollerheadurl();
  static const int kFromControllerHeadurlFieldNumber = 9;
  inline const ::std::string& fromcontrollerheadurl() const;
  inline void set_fromcontrollerheadurl(const ::std::string& value);
  inline void set_fromcontrollerheadurl(const char* value);
  inline void set_fromcontrollerheadurl(const char* value, size_t size);
  inline ::std::string* mutable_fromcontrollerheadurl();
  inline ::std::string* release_fromcontrollerheadurl();
  inline void set_allocated_fromcontrollerheadurl(::std::string* fromcontrollerheadurl);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResNotifyChatArrive)
 private:
  inline void set_has_msgid();
  inline void clear_has_msgid();
  inline void set_has_msgtype();
  inline void clear_has_msgtype();
  inline void set_has_msg();
  inline void clear_has_msg();
  inline void set_has_chanel();
  inline void clear_has_chanel();
  inline void set_has_msgcreatetime();
  inline void clear_has_msgcreatetime();
  inline void set_has_fromuniqueid();
  inline void clear_has_fromuniqueid();
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_fromcontrollernick();
  inline void clear_has_fromcontrollernick();
  inline void set_has_fromcontrollerheadurl();
  inline void clear_has_fromcontrollerheadurl();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msgid_;
  ::std::string* msg_;
  ::google::protobuf::int32 msgtype_;
  ::google::protobuf::int32 chanel_;
  ::google::protobuf::int64 msgcreatetime_;
  ::std::string* fromuniqueid_;
  ::std::string* fromcontrollernick_;
  ::std::string* fromcontrollerheadurl_;
  ::google::protobuf::int32 pos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_MsgCode_2eproto();
  friend void protobuf_AssignDesc_MsgCode_2eproto();
  friend void protobuf_ShutdownFile_MsgCode_2eproto();

  void InitAsDefaultInstance();
  static ResNotifyChatArrive* default_instance_;
};
// -------------------------------------------------------------------

class ResChat : public ::google::protobuf::Message {
 public:
  ResChat();
  virtual ~ResChat();

  ResChat(const ResChat& from);

  inline ResChat& operator=(const ResChat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResChat& default_instance();

  void Swap(ResChat* other);

  // implements Message ----------------------------------------------

  ResChat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResChat& from);
  void MergeFrom(const ResChat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoNet.ResponseResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::ProtoNet::ResponseResult& result() const;
  inline ::ProtoNet::ResponseResult* mutable_result();
  inline ::ProtoNet::ResponseResult* release_result();
  inline void set_allocated_result(::ProtoNet::ResponseResult* result);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResChat)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoNet::ResponseResult* result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MsgCode_2eproto();
  friend void protobuf_AssignDesc_MsgCode_2eproto();
  friend void protobuf_ShutdownFile_MsgCode_2eproto();

  void InitAsDefaultInstance();
  static ResChat* default_instance_;
};
// -------------------------------------------------------------------

class ReqChat : public ::google::protobuf::Message {
 public:
  ReqChat();
  virtual ~ReqChat();

  ReqChat(const ReqChat& from);

  inline ReqChat& operator=(const ReqChat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqChat& default_instance();

  void Swap(ReqChat* other);

  // implements Message ----------------------------------------------

  ReqChat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqChat& from);
  void MergeFrom(const ReqChat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 msgType = 1;
  inline bool has_msgtype() const;
  inline void clear_msgtype();
  static const int kMsgTypeFieldNumber = 1;
  inline ::google::protobuf::int32 msgtype() const;
  inline void set_msgtype(::google::protobuf::int32 value);

  // required string msg = 2;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 2;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // required int32 chanel = 3;
  inline bool has_chanel() const;
  inline void clear_chanel();
  static const int kChanelFieldNumber = 3;
  inline ::google::protobuf::int32 chanel() const;
  inline void set_chanel(::google::protobuf::int32 value);

  // optional string toUniqueId = 4;
  inline bool has_touniqueid() const;
  inline void clear_touniqueid();
  static const int kToUniqueIdFieldNumber = 4;
  inline const ::std::string& touniqueid() const;
  inline void set_touniqueid(const ::std::string& value);
  inline void set_touniqueid(const char* value);
  inline void set_touniqueid(const char* value, size_t size);
  inline ::std::string* mutable_touniqueid();
  inline ::std::string* release_touniqueid();
  inline void set_allocated_touniqueid(::std::string* touniqueid);

  // optional string clubId = 5;
  inline bool has_clubid() const;
  inline void clear_clubid();
  static const int kClubIdFieldNumber = 5;
  inline const ::std::string& clubid() const;
  inline void set_clubid(const ::std::string& value);
  inline void set_clubid(const char* value);
  inline void set_clubid(const char* value, size_t size);
  inline ::std::string* mutable_clubid();
  inline ::std::string* release_clubid();
  inline void set_allocated_clubid(::std::string* clubid);

  // @@protoc_insertion_point(class_scope:ProtoNet.ReqChat)
 private:
  inline void set_has_msgtype();
  inline void clear_has_msgtype();
  inline void set_has_msg();
  inline void clear_has_msg();
  inline void set_has_chanel();
  inline void clear_has_chanel();
  inline void set_has_touniqueid();
  inline void clear_has_touniqueid();
  inline void set_has_clubid();
  inline void clear_has_clubid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msg_;
  ::google::protobuf::int32 msgtype_;
  ::google::protobuf::int32 chanel_;
  ::std::string* touniqueid_;
  ::std::string* clubid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_MsgCode_2eproto();
  friend void protobuf_AssignDesc_MsgCode_2eproto();
  friend void protobuf_ShutdownFile_MsgCode_2eproto();

  void InitAsDefaultInstance();
  static ReqChat* default_instance_;
};
// -------------------------------------------------------------------

class ResNotifyBeKickOut : public ::google::protobuf::Message {
 public:
  ResNotifyBeKickOut();
  virtual ~ResNotifyBeKickOut();

  ResNotifyBeKickOut(const ResNotifyBeKickOut& from);

  inline ResNotifyBeKickOut& operator=(const ResNotifyBeKickOut& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResNotifyBeKickOut& default_instance();

  void Swap(ResNotifyBeKickOut* other);

  // implements Message ----------------------------------------------

  ResNotifyBeKickOut* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResNotifyBeKickOut& from);
  void MergeFrom(const ResNotifyBeKickOut& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ProtoNet.ResNotifyBeKickOut)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_MsgCode_2eproto();
  friend void protobuf_AssignDesc_MsgCode_2eproto();
  friend void protobuf_ShutdownFile_MsgCode_2eproto();

  void InitAsDefaultInstance();
  static ResNotifyBeKickOut* default_instance_;
};
// -------------------------------------------------------------------

class ResExceptionCatch : public ::google::protobuf::Message {
 public:
  ResExceptionCatch();
  virtual ~ResExceptionCatch();

  ResExceptionCatch(const ResExceptionCatch& from);

  inline ResExceptionCatch& operator=(const ResExceptionCatch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResExceptionCatch& default_instance();

  void Swap(ResExceptionCatch* other);

  // implements Message ----------------------------------------------

  ResExceptionCatch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResExceptionCatch& from);
  void MergeFrom(const ResExceptionCatch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string msg = 1;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 1;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResExceptionCatch)
 private:
  inline void set_has_msg();
  inline void clear_has_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* msg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MsgCode_2eproto();
  friend void protobuf_AssignDesc_MsgCode_2eproto();
  friend void protobuf_ShutdownFile_MsgCode_2eproto();

  void InitAsDefaultInstance();
  static ResExceptionCatch* default_instance_;
};
// -------------------------------------------------------------------

class ResConnectCreat : public ::google::protobuf::Message {
 public:
  ResConnectCreat();
  virtual ~ResConnectCreat();

  ResConnectCreat(const ResConnectCreat& from);

  inline ResConnectCreat& operator=(const ResConnectCreat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResConnectCreat& default_instance();

  void Swap(ResConnectCreat* other);

  // implements Message ----------------------------------------------

  ResConnectCreat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResConnectCreat& from);
  void MergeFrom(const ResConnectCreat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 now = 1;
  inline bool has_now() const;
  inline void clear_now();
  static const int kNowFieldNumber = 1;
  inline ::google::protobuf::int64 now() const;
  inline void set_now(::google::protobuf::int64 value);

  // required int64 heartbeartTime = 2;
  inline bool has_heartbearttime() const;
  inline void clear_heartbearttime();
  static const int kHeartbeartTimeFieldNumber = 2;
  inline ::google::protobuf::int64 heartbearttime() const;
  inline void set_heartbearttime(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResConnectCreat)
 private:
  inline void set_has_now();
  inline void clear_has_now();
  inline void set_has_heartbearttime();
  inline void clear_has_heartbearttime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 now_;
  ::google::protobuf::int64 heartbearttime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MsgCode_2eproto();
  friend void protobuf_AssignDesc_MsgCode_2eproto();
  friend void protobuf_ShutdownFile_MsgCode_2eproto();

  void InitAsDefaultInstance();
  static ResConnectCreat* default_instance_;
};
// -------------------------------------------------------------------

class ReqHeartBeat : public ::google::protobuf::Message {
 public:
  ReqHeartBeat();
  virtual ~ReqHeartBeat();

  ReqHeartBeat(const ReqHeartBeat& from);

  inline ReqHeartBeat& operator=(const ReqHeartBeat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqHeartBeat& default_instance();

  void Swap(ReqHeartBeat* other);

  // implements Message ----------------------------------------------

  ReqHeartBeat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqHeartBeat& from);
  void MergeFrom(const ReqHeartBeat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ProtoNet.ReqHeartBeat)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_MsgCode_2eproto();
  friend void protobuf_AssignDesc_MsgCode_2eproto();
  friend void protobuf_ShutdownFile_MsgCode_2eproto();

  void InitAsDefaultInstance();
  static ReqHeartBeat* default_instance_;
};
// -------------------------------------------------------------------

class ResHeartBeat : public ::google::protobuf::Message {
 public:
  ResHeartBeat();
  virtual ~ResHeartBeat();

  ResHeartBeat(const ResHeartBeat& from);

  inline ResHeartBeat& operator=(const ResHeartBeat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResHeartBeat& default_instance();

  void Swap(ResHeartBeat* other);

  // implements Message ----------------------------------------------

  ResHeartBeat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResHeartBeat& from);
  void MergeFrom(const ResHeartBeat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResHeartBeat)
 private:
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MsgCode_2eproto();
  friend void protobuf_AssignDesc_MsgCode_2eproto();
  friend void protobuf_ShutdownFile_MsgCode_2eproto();

  void InitAsDefaultInstance();
  static ResHeartBeat* default_instance_;
};
// ===================================================================


// ===================================================================

// ResponseResult

// required int32 code = 1;
inline bool ResponseResult::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResponseResult::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResponseResult::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResponseResult::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 ResponseResult::code() const {
  return code_;
}
inline void ResponseResult::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
}

// required bool success = 2;
inline bool ResponseResult::has_success() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResponseResult::set_has_success() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResponseResult::clear_has_success() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResponseResult::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool ResponseResult::success() const {
  return success_;
}
inline void ResponseResult::set_success(bool value) {
  set_has_success();
  success_ = value;
}

// optional string msg = 3;
inline bool ResponseResult::has_msg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResponseResult::set_has_msg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResponseResult::clear_has_msg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResponseResult::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& ResponseResult::msg() const {
  return *msg_;
}
inline void ResponseResult::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void ResponseResult::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void ResponseResult::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResponseResult::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* ResponseResult::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResponseResult::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PlayerAccount

// optional int32 type = 1;
inline bool PlayerAccount::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerAccount::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerAccount::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerAccount::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 PlayerAccount::type() const {
  return type_;
}
inline void PlayerAccount::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional double count = 2;
inline bool PlayerAccount::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerAccount::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerAccount::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerAccount::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline double PlayerAccount::count() const {
  return count_;
}
inline void PlayerAccount::set_count(double value) {
  set_has_count();
  count_ = value;
}

// optional double bankcount = 3;
inline bool PlayerAccount::has_bankcount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlayerAccount::set_has_bankcount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlayerAccount::clear_has_bankcount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlayerAccount::clear_bankcount() {
  bankcount_ = 0;
  clear_has_bankcount();
}
inline double PlayerAccount::bankcount() const {
  return bankcount_;
}
inline void PlayerAccount::set_bankcount(double value) {
  set_has_bankcount();
  bankcount_ = value;
}

// -------------------------------------------------------------------

// ResNotifyAlert

// required string msg = 1;
inline bool ResNotifyAlert::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResNotifyAlert::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResNotifyAlert::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResNotifyAlert::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& ResNotifyAlert::msg() const {
  return *msg_;
}
inline void ResNotifyAlert::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void ResNotifyAlert::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void ResNotifyAlert::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResNotifyAlert::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* ResNotifyAlert::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResNotifyAlert::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string extendStr = 2;
inline bool ResNotifyAlert::has_extendstr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResNotifyAlert::set_has_extendstr() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResNotifyAlert::clear_has_extendstr() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResNotifyAlert::clear_extendstr() {
  if (extendstr_ != &::google::protobuf::internal::kEmptyString) {
    extendstr_->clear();
  }
  clear_has_extendstr();
}
inline const ::std::string& ResNotifyAlert::extendstr() const {
  return *extendstr_;
}
inline void ResNotifyAlert::set_extendstr(const ::std::string& value) {
  set_has_extendstr();
  if (extendstr_ == &::google::protobuf::internal::kEmptyString) {
    extendstr_ = new ::std::string;
  }
  extendstr_->assign(value);
}
inline void ResNotifyAlert::set_extendstr(const char* value) {
  set_has_extendstr();
  if (extendstr_ == &::google::protobuf::internal::kEmptyString) {
    extendstr_ = new ::std::string;
  }
  extendstr_->assign(value);
}
inline void ResNotifyAlert::set_extendstr(const char* value, size_t size) {
  set_has_extendstr();
  if (extendstr_ == &::google::protobuf::internal::kEmptyString) {
    extendstr_ = new ::std::string;
  }
  extendstr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResNotifyAlert::mutable_extendstr() {
  set_has_extendstr();
  if (extendstr_ == &::google::protobuf::internal::kEmptyString) {
    extendstr_ = new ::std::string;
  }
  return extendstr_;
}
inline ::std::string* ResNotifyAlert::release_extendstr() {
  clear_has_extendstr();
  if (extendstr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extendstr_;
    extendstr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResNotifyAlert::set_allocated_extendstr(::std::string* extendstr) {
  if (extendstr_ != &::google::protobuf::internal::kEmptyString) {
    delete extendstr_;
  }
  if (extendstr) {
    set_has_extendstr();
    extendstr_ = extendstr;
  } else {
    clear_has_extendstr();
    extendstr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ResNotifyDissolutionConnect

// optional int32 gameId = 1;
inline bool ResNotifyDissolutionConnect::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResNotifyDissolutionConnect::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResNotifyDissolutionConnect::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResNotifyDissolutionConnect::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 ResNotifyDissolutionConnect::gameid() const {
  return gameid_;
}
inline void ResNotifyDissolutionConnect::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 type = 2;
inline bool ResNotifyDissolutionConnect::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResNotifyDissolutionConnect::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResNotifyDissolutionConnect::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResNotifyDissolutionConnect::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ResNotifyDissolutionConnect::type() const {
  return type_;
}
inline void ResNotifyDissolutionConnect::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional string msg = 3;
inline bool ResNotifyDissolutionConnect::has_msg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResNotifyDissolutionConnect::set_has_msg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResNotifyDissolutionConnect::clear_has_msg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResNotifyDissolutionConnect::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& ResNotifyDissolutionConnect::msg() const {
  return *msg_;
}
inline void ResNotifyDissolutionConnect::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void ResNotifyDissolutionConnect::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void ResNotifyDissolutionConnect::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResNotifyDissolutionConnect::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* ResNotifyDissolutionConnect::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResNotifyDissolutionConnect::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ResNotifyChatArrive

// required string msgId = 1;
inline bool ResNotifyChatArrive::has_msgid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResNotifyChatArrive::set_has_msgid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResNotifyChatArrive::clear_has_msgid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResNotifyChatArrive::clear_msgid() {
  if (msgid_ != &::google::protobuf::internal::kEmptyString) {
    msgid_->clear();
  }
  clear_has_msgid();
}
inline const ::std::string& ResNotifyChatArrive::msgid() const {
  return *msgid_;
}
inline void ResNotifyChatArrive::set_msgid(const ::std::string& value) {
  set_has_msgid();
  if (msgid_ == &::google::protobuf::internal::kEmptyString) {
    msgid_ = new ::std::string;
  }
  msgid_->assign(value);
}
inline void ResNotifyChatArrive::set_msgid(const char* value) {
  set_has_msgid();
  if (msgid_ == &::google::protobuf::internal::kEmptyString) {
    msgid_ = new ::std::string;
  }
  msgid_->assign(value);
}
inline void ResNotifyChatArrive::set_msgid(const char* value, size_t size) {
  set_has_msgid();
  if (msgid_ == &::google::protobuf::internal::kEmptyString) {
    msgid_ = new ::std::string;
  }
  msgid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResNotifyChatArrive::mutable_msgid() {
  set_has_msgid();
  if (msgid_ == &::google::protobuf::internal::kEmptyString) {
    msgid_ = new ::std::string;
  }
  return msgid_;
}
inline ::std::string* ResNotifyChatArrive::release_msgid() {
  clear_has_msgid();
  if (msgid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msgid_;
    msgid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResNotifyChatArrive::set_allocated_msgid(::std::string* msgid) {
  if (msgid_ != &::google::protobuf::internal::kEmptyString) {
    delete msgid_;
  }
  if (msgid) {
    set_has_msgid();
    msgid_ = msgid;
  } else {
    clear_has_msgid();
    msgid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 msgType = 2;
inline bool ResNotifyChatArrive::has_msgtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResNotifyChatArrive::set_has_msgtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResNotifyChatArrive::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResNotifyChatArrive::clear_msgtype() {
  msgtype_ = 0;
  clear_has_msgtype();
}
inline ::google::protobuf::int32 ResNotifyChatArrive::msgtype() const {
  return msgtype_;
}
inline void ResNotifyChatArrive::set_msgtype(::google::protobuf::int32 value) {
  set_has_msgtype();
  msgtype_ = value;
}

// required string msg = 3;
inline bool ResNotifyChatArrive::has_msg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResNotifyChatArrive::set_has_msg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResNotifyChatArrive::clear_has_msg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResNotifyChatArrive::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& ResNotifyChatArrive::msg() const {
  return *msg_;
}
inline void ResNotifyChatArrive::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void ResNotifyChatArrive::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void ResNotifyChatArrive::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResNotifyChatArrive::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* ResNotifyChatArrive::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResNotifyChatArrive::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 chanel = 4;
inline bool ResNotifyChatArrive::has_chanel() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResNotifyChatArrive::set_has_chanel() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResNotifyChatArrive::clear_has_chanel() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResNotifyChatArrive::clear_chanel() {
  chanel_ = 0;
  clear_has_chanel();
}
inline ::google::protobuf::int32 ResNotifyChatArrive::chanel() const {
  return chanel_;
}
inline void ResNotifyChatArrive::set_chanel(::google::protobuf::int32 value) {
  set_has_chanel();
  chanel_ = value;
}

// required int64 msgCreateTime = 5;
inline bool ResNotifyChatArrive::has_msgcreatetime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResNotifyChatArrive::set_has_msgcreatetime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResNotifyChatArrive::clear_has_msgcreatetime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResNotifyChatArrive::clear_msgcreatetime() {
  msgcreatetime_ = GOOGLE_LONGLONG(0);
  clear_has_msgcreatetime();
}
inline ::google::protobuf::int64 ResNotifyChatArrive::msgcreatetime() const {
  return msgcreatetime_;
}
inline void ResNotifyChatArrive::set_msgcreatetime(::google::protobuf::int64 value) {
  set_has_msgcreatetime();
  msgcreatetime_ = value;
}

// required string fromUniqueId = 6;
inline bool ResNotifyChatArrive::has_fromuniqueid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResNotifyChatArrive::set_has_fromuniqueid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResNotifyChatArrive::clear_has_fromuniqueid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResNotifyChatArrive::clear_fromuniqueid() {
  if (fromuniqueid_ != &::google::protobuf::internal::kEmptyString) {
    fromuniqueid_->clear();
  }
  clear_has_fromuniqueid();
}
inline const ::std::string& ResNotifyChatArrive::fromuniqueid() const {
  return *fromuniqueid_;
}
inline void ResNotifyChatArrive::set_fromuniqueid(const ::std::string& value) {
  set_has_fromuniqueid();
  if (fromuniqueid_ == &::google::protobuf::internal::kEmptyString) {
    fromuniqueid_ = new ::std::string;
  }
  fromuniqueid_->assign(value);
}
inline void ResNotifyChatArrive::set_fromuniqueid(const char* value) {
  set_has_fromuniqueid();
  if (fromuniqueid_ == &::google::protobuf::internal::kEmptyString) {
    fromuniqueid_ = new ::std::string;
  }
  fromuniqueid_->assign(value);
}
inline void ResNotifyChatArrive::set_fromuniqueid(const char* value, size_t size) {
  set_has_fromuniqueid();
  if (fromuniqueid_ == &::google::protobuf::internal::kEmptyString) {
    fromuniqueid_ = new ::std::string;
  }
  fromuniqueid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResNotifyChatArrive::mutable_fromuniqueid() {
  set_has_fromuniqueid();
  if (fromuniqueid_ == &::google::protobuf::internal::kEmptyString) {
    fromuniqueid_ = new ::std::string;
  }
  return fromuniqueid_;
}
inline ::std::string* ResNotifyChatArrive::release_fromuniqueid() {
  clear_has_fromuniqueid();
  if (fromuniqueid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fromuniqueid_;
    fromuniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResNotifyChatArrive::set_allocated_fromuniqueid(::std::string* fromuniqueid) {
  if (fromuniqueid_ != &::google::protobuf::internal::kEmptyString) {
    delete fromuniqueid_;
  }
  if (fromuniqueid) {
    set_has_fromuniqueid();
    fromuniqueid_ = fromuniqueid;
  } else {
    clear_has_fromuniqueid();
    fromuniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 pos = 7;
inline bool ResNotifyChatArrive::has_pos() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ResNotifyChatArrive::set_has_pos() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ResNotifyChatArrive::clear_has_pos() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ResNotifyChatArrive::clear_pos() {
  pos_ = 0;
  clear_has_pos();
}
inline ::google::protobuf::int32 ResNotifyChatArrive::pos() const {
  return pos_;
}
inline void ResNotifyChatArrive::set_pos(::google::protobuf::int32 value) {
  set_has_pos();
  pos_ = value;
}

// optional string fromControllerNick = 8;
inline bool ResNotifyChatArrive::has_fromcontrollernick() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ResNotifyChatArrive::set_has_fromcontrollernick() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ResNotifyChatArrive::clear_has_fromcontrollernick() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ResNotifyChatArrive::clear_fromcontrollernick() {
  if (fromcontrollernick_ != &::google::protobuf::internal::kEmptyString) {
    fromcontrollernick_->clear();
  }
  clear_has_fromcontrollernick();
}
inline const ::std::string& ResNotifyChatArrive::fromcontrollernick() const {
  return *fromcontrollernick_;
}
inline void ResNotifyChatArrive::set_fromcontrollernick(const ::std::string& value) {
  set_has_fromcontrollernick();
  if (fromcontrollernick_ == &::google::protobuf::internal::kEmptyString) {
    fromcontrollernick_ = new ::std::string;
  }
  fromcontrollernick_->assign(value);
}
inline void ResNotifyChatArrive::set_fromcontrollernick(const char* value) {
  set_has_fromcontrollernick();
  if (fromcontrollernick_ == &::google::protobuf::internal::kEmptyString) {
    fromcontrollernick_ = new ::std::string;
  }
  fromcontrollernick_->assign(value);
}
inline void ResNotifyChatArrive::set_fromcontrollernick(const char* value, size_t size) {
  set_has_fromcontrollernick();
  if (fromcontrollernick_ == &::google::protobuf::internal::kEmptyString) {
    fromcontrollernick_ = new ::std::string;
  }
  fromcontrollernick_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResNotifyChatArrive::mutable_fromcontrollernick() {
  set_has_fromcontrollernick();
  if (fromcontrollernick_ == &::google::protobuf::internal::kEmptyString) {
    fromcontrollernick_ = new ::std::string;
  }
  return fromcontrollernick_;
}
inline ::std::string* ResNotifyChatArrive::release_fromcontrollernick() {
  clear_has_fromcontrollernick();
  if (fromcontrollernick_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fromcontrollernick_;
    fromcontrollernick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResNotifyChatArrive::set_allocated_fromcontrollernick(::std::string* fromcontrollernick) {
  if (fromcontrollernick_ != &::google::protobuf::internal::kEmptyString) {
    delete fromcontrollernick_;
  }
  if (fromcontrollernick) {
    set_has_fromcontrollernick();
    fromcontrollernick_ = fromcontrollernick;
  } else {
    clear_has_fromcontrollernick();
    fromcontrollernick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string fromControllerHeadurl = 9;
inline bool ResNotifyChatArrive::has_fromcontrollerheadurl() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ResNotifyChatArrive::set_has_fromcontrollerheadurl() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ResNotifyChatArrive::clear_has_fromcontrollerheadurl() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ResNotifyChatArrive::clear_fromcontrollerheadurl() {
  if (fromcontrollerheadurl_ != &::google::protobuf::internal::kEmptyString) {
    fromcontrollerheadurl_->clear();
  }
  clear_has_fromcontrollerheadurl();
}
inline const ::std::string& ResNotifyChatArrive::fromcontrollerheadurl() const {
  return *fromcontrollerheadurl_;
}
inline void ResNotifyChatArrive::set_fromcontrollerheadurl(const ::std::string& value) {
  set_has_fromcontrollerheadurl();
  if (fromcontrollerheadurl_ == &::google::protobuf::internal::kEmptyString) {
    fromcontrollerheadurl_ = new ::std::string;
  }
  fromcontrollerheadurl_->assign(value);
}
inline void ResNotifyChatArrive::set_fromcontrollerheadurl(const char* value) {
  set_has_fromcontrollerheadurl();
  if (fromcontrollerheadurl_ == &::google::protobuf::internal::kEmptyString) {
    fromcontrollerheadurl_ = new ::std::string;
  }
  fromcontrollerheadurl_->assign(value);
}
inline void ResNotifyChatArrive::set_fromcontrollerheadurl(const char* value, size_t size) {
  set_has_fromcontrollerheadurl();
  if (fromcontrollerheadurl_ == &::google::protobuf::internal::kEmptyString) {
    fromcontrollerheadurl_ = new ::std::string;
  }
  fromcontrollerheadurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResNotifyChatArrive::mutable_fromcontrollerheadurl() {
  set_has_fromcontrollerheadurl();
  if (fromcontrollerheadurl_ == &::google::protobuf::internal::kEmptyString) {
    fromcontrollerheadurl_ = new ::std::string;
  }
  return fromcontrollerheadurl_;
}
inline ::std::string* ResNotifyChatArrive::release_fromcontrollerheadurl() {
  clear_has_fromcontrollerheadurl();
  if (fromcontrollerheadurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fromcontrollerheadurl_;
    fromcontrollerheadurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResNotifyChatArrive::set_allocated_fromcontrollerheadurl(::std::string* fromcontrollerheadurl) {
  if (fromcontrollerheadurl_ != &::google::protobuf::internal::kEmptyString) {
    delete fromcontrollerheadurl_;
  }
  if (fromcontrollerheadurl) {
    set_has_fromcontrollerheadurl();
    fromcontrollerheadurl_ = fromcontrollerheadurl;
  } else {
    clear_has_fromcontrollerheadurl();
    fromcontrollerheadurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ResChat

// required .ProtoNet.ResponseResult result = 1;
inline bool ResChat::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResChat::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResChat::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResChat::clear_result() {
  if (result_ != NULL) result_->::ProtoNet::ResponseResult::Clear();
  clear_has_result();
}
inline const ::ProtoNet::ResponseResult& ResChat::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::ProtoNet::ResponseResult* ResChat::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::ProtoNet::ResponseResult;
  return result_;
}
inline ::ProtoNet::ResponseResult* ResChat::release_result() {
  clear_has_result();
  ::ProtoNet::ResponseResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline void ResChat::set_allocated_result(::ProtoNet::ResponseResult* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// -------------------------------------------------------------------

// ReqChat

// required int32 msgType = 1;
inline bool ReqChat::has_msgtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqChat::set_has_msgtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqChat::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqChat::clear_msgtype() {
  msgtype_ = 0;
  clear_has_msgtype();
}
inline ::google::protobuf::int32 ReqChat::msgtype() const {
  return msgtype_;
}
inline void ReqChat::set_msgtype(::google::protobuf::int32 value) {
  set_has_msgtype();
  msgtype_ = value;
}

// required string msg = 2;
inline bool ReqChat::has_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqChat::set_has_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqChat::clear_has_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqChat::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& ReqChat::msg() const {
  return *msg_;
}
inline void ReqChat::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void ReqChat::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void ReqChat::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqChat::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* ReqChat::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqChat::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 chanel = 3;
inline bool ReqChat::has_chanel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqChat::set_has_chanel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqChat::clear_has_chanel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqChat::clear_chanel() {
  chanel_ = 0;
  clear_has_chanel();
}
inline ::google::protobuf::int32 ReqChat::chanel() const {
  return chanel_;
}
inline void ReqChat::set_chanel(::google::protobuf::int32 value) {
  set_has_chanel();
  chanel_ = value;
}

// optional string toUniqueId = 4;
inline bool ReqChat::has_touniqueid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqChat::set_has_touniqueid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqChat::clear_has_touniqueid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqChat::clear_touniqueid() {
  if (touniqueid_ != &::google::protobuf::internal::kEmptyString) {
    touniqueid_->clear();
  }
  clear_has_touniqueid();
}
inline const ::std::string& ReqChat::touniqueid() const {
  return *touniqueid_;
}
inline void ReqChat::set_touniqueid(const ::std::string& value) {
  set_has_touniqueid();
  if (touniqueid_ == &::google::protobuf::internal::kEmptyString) {
    touniqueid_ = new ::std::string;
  }
  touniqueid_->assign(value);
}
inline void ReqChat::set_touniqueid(const char* value) {
  set_has_touniqueid();
  if (touniqueid_ == &::google::protobuf::internal::kEmptyString) {
    touniqueid_ = new ::std::string;
  }
  touniqueid_->assign(value);
}
inline void ReqChat::set_touniqueid(const char* value, size_t size) {
  set_has_touniqueid();
  if (touniqueid_ == &::google::protobuf::internal::kEmptyString) {
    touniqueid_ = new ::std::string;
  }
  touniqueid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqChat::mutable_touniqueid() {
  set_has_touniqueid();
  if (touniqueid_ == &::google::protobuf::internal::kEmptyString) {
    touniqueid_ = new ::std::string;
  }
  return touniqueid_;
}
inline ::std::string* ReqChat::release_touniqueid() {
  clear_has_touniqueid();
  if (touniqueid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = touniqueid_;
    touniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqChat::set_allocated_touniqueid(::std::string* touniqueid) {
  if (touniqueid_ != &::google::protobuf::internal::kEmptyString) {
    delete touniqueid_;
  }
  if (touniqueid) {
    set_has_touniqueid();
    touniqueid_ = touniqueid;
  } else {
    clear_has_touniqueid();
    touniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string clubId = 5;
inline bool ReqChat::has_clubid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReqChat::set_has_clubid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReqChat::clear_has_clubid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReqChat::clear_clubid() {
  if (clubid_ != &::google::protobuf::internal::kEmptyString) {
    clubid_->clear();
  }
  clear_has_clubid();
}
inline const ::std::string& ReqChat::clubid() const {
  return *clubid_;
}
inline void ReqChat::set_clubid(const ::std::string& value) {
  set_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    clubid_ = new ::std::string;
  }
  clubid_->assign(value);
}
inline void ReqChat::set_clubid(const char* value) {
  set_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    clubid_ = new ::std::string;
  }
  clubid_->assign(value);
}
inline void ReqChat::set_clubid(const char* value, size_t size) {
  set_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    clubid_ = new ::std::string;
  }
  clubid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqChat::mutable_clubid() {
  set_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    clubid_ = new ::std::string;
  }
  return clubid_;
}
inline ::std::string* ReqChat::release_clubid() {
  clear_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clubid_;
    clubid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqChat::set_allocated_clubid(::std::string* clubid) {
  if (clubid_ != &::google::protobuf::internal::kEmptyString) {
    delete clubid_;
  }
  if (clubid) {
    set_has_clubid();
    clubid_ = clubid;
  } else {
    clear_has_clubid();
    clubid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ResNotifyBeKickOut

// -------------------------------------------------------------------

// ResExceptionCatch

// required string msg = 1;
inline bool ResExceptionCatch::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResExceptionCatch::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResExceptionCatch::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResExceptionCatch::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& ResExceptionCatch::msg() const {
  return *msg_;
}
inline void ResExceptionCatch::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void ResExceptionCatch::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void ResExceptionCatch::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResExceptionCatch::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* ResExceptionCatch::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResExceptionCatch::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ResConnectCreat

// required int64 now = 1;
inline bool ResConnectCreat::has_now() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResConnectCreat::set_has_now() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResConnectCreat::clear_has_now() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResConnectCreat::clear_now() {
  now_ = GOOGLE_LONGLONG(0);
  clear_has_now();
}
inline ::google::protobuf::int64 ResConnectCreat::now() const {
  return now_;
}
inline void ResConnectCreat::set_now(::google::protobuf::int64 value) {
  set_has_now();
  now_ = value;
}

// required int64 heartbeartTime = 2;
inline bool ResConnectCreat::has_heartbearttime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResConnectCreat::set_has_heartbearttime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResConnectCreat::clear_has_heartbearttime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResConnectCreat::clear_heartbearttime() {
  heartbearttime_ = GOOGLE_LONGLONG(0);
  clear_has_heartbearttime();
}
inline ::google::protobuf::int64 ResConnectCreat::heartbearttime() const {
  return heartbearttime_;
}
inline void ResConnectCreat::set_heartbearttime(::google::protobuf::int64 value) {
  set_has_heartbearttime();
  heartbearttime_ = value;
}

// -------------------------------------------------------------------

// ReqHeartBeat

// -------------------------------------------------------------------

// ResHeartBeat

// required int64 time = 1;
inline bool ResHeartBeat::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResHeartBeat::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResHeartBeat::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResHeartBeat::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 ResHeartBeat::time() const {
  return time_;
}
inline void ResHeartBeat::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ProtoNet

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoNet::RoomType>() {
  return ::ProtoNet::RoomType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ProtoNet::GameCode>() {
  return ::ProtoNet::GameCode_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_MsgCode_2eproto__INCLUDED
