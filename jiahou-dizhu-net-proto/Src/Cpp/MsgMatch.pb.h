// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MsgMatch.proto

#ifndef PROTOBUF_MsgMatch_2eproto__INCLUDED
#define PROTOBUF_MsgMatch_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "MsgCode.pb.h"
#include "MsgGate.pb.h"
// @@protoc_insertion_point(includes)

namespace ProtoNet {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_MsgMatch_2eproto();
void protobuf_AssignDesc_MsgMatch_2eproto();
void protobuf_ShutdownFile_MsgMatch_2eproto();

class ItemInfo;
class MatchSignInfo;
class ReqGetMatchList;
class ResGetMatchList;
class ReqSignUpMatch;
class ResSignUpMatch;
class ResNotifyEnterMatch;
class ReqCanleSignMatch;
class ResCanleSignMatch;
class ResNotifyMatchRoomWattingChange;
class ResNotifyTimesOver;
class ReqContinueMatch;
class ResContinueMatch;

// ===================================================================

class ItemInfo : public ::google::protobuf::Message {
 public:
  ItemInfo();
  virtual ~ItemInfo();

  ItemInfo(const ItemInfo& from);

  inline ItemInfo& operator=(const ItemInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ItemInfo& default_instance();

  void Swap(ItemInfo* other);

  // implements Message ----------------------------------------------

  ItemInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ItemInfo& from);
  void MergeFrom(const ItemInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 itemId = 1;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIdFieldNumber = 1;
  inline ::google::protobuf::int32 itemid() const;
  inline void set_itemid(::google::protobuf::int32 value);

  // required int32 num = 2;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 2;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ProtoNet.ItemInfo)
 private:
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_num();
  inline void clear_has_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 itemid_;
  ::google::protobuf::int32 num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MsgMatch_2eproto();
  friend void protobuf_AssignDesc_MsgMatch_2eproto();
  friend void protobuf_ShutdownFile_MsgMatch_2eproto();

  void InitAsDefaultInstance();
  static ItemInfo* default_instance_;
};
// -------------------------------------------------------------------

class MatchSignInfo : public ::google::protobuf::Message {
 public:
  MatchSignInfo();
  virtual ~MatchSignInfo();

  MatchSignInfo(const MatchSignInfo& from);

  inline MatchSignInfo& operator=(const MatchSignInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MatchSignInfo& default_instance();

  void Swap(MatchSignInfo* other);

  // implements Message ----------------------------------------------

  MatchSignInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MatchSignInfo& from);
  void MergeFrom(const MatchSignInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 matchConfigId = 1;
  inline bool has_matchconfigid() const;
  inline void clear_matchconfigid();
  static const int kMatchConfigIdFieldNumber = 1;
  inline ::google::protobuf::int32 matchconfigid() const;
  inline void set_matchconfigid(::google::protobuf::int32 value);

  // required string matchName = 2;
  inline bool has_matchname() const;
  inline void clear_matchname();
  static const int kMatchNameFieldNumber = 2;
  inline const ::std::string& matchname() const;
  inline void set_matchname(const ::std::string& value);
  inline void set_matchname(const char* value);
  inline void set_matchname(const char* value, size_t size);
  inline ::std::string* mutable_matchname();
  inline ::std::string* release_matchname();
  inline void set_allocated_matchname(::std::string* matchname);

  // required string matchBigName = 3;
  inline bool has_matchbigname() const;
  inline void clear_matchbigname();
  static const int kMatchBigNameFieldNumber = 3;
  inline const ::std::string& matchbigname() const;
  inline void set_matchbigname(const ::std::string& value);
  inline void set_matchbigname(const char* value);
  inline void set_matchbigname(const char* value, size_t size);
  inline ::std::string* mutable_matchbigname();
  inline ::std::string* release_matchbigname();
  inline void set_allocated_matchbigname(::std::string* matchbigname);

  // required string matchDesc = 4;
  inline bool has_matchdesc() const;
  inline void clear_matchdesc();
  static const int kMatchDescFieldNumber = 4;
  inline const ::std::string& matchdesc() const;
  inline void set_matchdesc(const ::std::string& value);
  inline void set_matchdesc(const char* value);
  inline void set_matchdesc(const char* value, size_t size);
  inline ::std::string* mutable_matchdesc();
  inline ::std::string* release_matchdesc();
  inline void set_allocated_matchdesc(::std::string* matchdesc);

  // required int32 maxPlayer = 5;
  inline bool has_maxplayer() const;
  inline void clear_maxplayer();
  static const int kMaxPlayerFieldNumber = 5;
  inline ::google::protobuf::int32 maxplayer() const;
  inline void set_maxplayer(::google::protobuf::int32 value);

  // required int32 currentPlayerNum = 6;
  inline bool has_currentplayernum() const;
  inline void clear_currentplayernum();
  static const int kCurrentPlayerNumFieldNumber = 6;
  inline ::google::protobuf::int32 currentplayernum() const;
  inline void set_currentplayernum(::google::protobuf::int32 value);

  // required int64 signBeginTime = 7;
  inline bool has_signbegintime() const;
  inline void clear_signbegintime();
  static const int kSignBeginTimeFieldNumber = 7;
  inline ::google::protobuf::int64 signbegintime() const;
  inline void set_signbegintime(::google::protobuf::int64 value);

  // required int64 duringTime = 8;
  inline bool has_duringtime() const;
  inline void clear_duringtime();
  static const int kDuringTimeFieldNumber = 8;
  inline ::google::protobuf::int64 duringtime() const;
  inline void set_duringtime(::google::protobuf::int64 value);

  // required int64 matchBeginTime = 9;
  inline bool has_matchbegintime() const;
  inline void clear_matchbegintime();
  static const int kMatchBeginTimeFieldNumber = 9;
  inline ::google::protobuf::int64 matchbegintime() const;
  inline void set_matchbegintime(::google::protobuf::int64 value);

  // repeated .ProtoNet.ItemInfo rewardInfos = 10;
  inline int rewardinfos_size() const;
  inline void clear_rewardinfos();
  static const int kRewardInfosFieldNumber = 10;
  inline const ::ProtoNet::ItemInfo& rewardinfos(int index) const;
  inline ::ProtoNet::ItemInfo* mutable_rewardinfos(int index);
  inline ::ProtoNet::ItemInfo* add_rewardinfos();
  inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::ItemInfo >&
      rewardinfos() const;
  inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::ItemInfo >*
      mutable_rewardinfos();

  // repeated .ProtoNet.ItemInfo costInfos = 11;
  inline int costinfos_size() const;
  inline void clear_costinfos();
  static const int kCostInfosFieldNumber = 11;
  inline const ::ProtoNet::ItemInfo& costinfos(int index) const;
  inline ::ProtoNet::ItemInfo* mutable_costinfos(int index);
  inline ::ProtoNet::ItemInfo* add_costinfos();
  inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::ItemInfo >&
      costinfos() const;
  inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::ItemInfo >*
      mutable_costinfos();

  // required string randId = 12;
  inline bool has_randid() const;
  inline void clear_randid();
  static const int kRandIdFieldNumber = 12;
  inline const ::std::string& randid() const;
  inline void set_randid(const ::std::string& value);
  inline void set_randid(const char* value);
  inline void set_randid(const char* value, size_t size);
  inline ::std::string* mutable_randid();
  inline ::std::string* release_randid();
  inline void set_allocated_randid(::std::string* randid);

  // optional int32 selfSignUp = 13;
  inline bool has_selfsignup() const;
  inline void clear_selfsignup();
  static const int kSelfSignUpFieldNumber = 13;
  inline ::google::protobuf::int32 selfsignup() const;
  inline void set_selfsignup(::google::protobuf::int32 value);

  // required int32 times = 14;
  inline bool has_times() const;
  inline void clear_times();
  static const int kTimesFieldNumber = 14;
  inline ::google::protobuf::int32 times() const;
  inline void set_times(::google::protobuf::int32 value);

  // required string from = 15;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 15;
  inline const ::std::string& from() const;
  inline void set_from(const ::std::string& value);
  inline void set_from(const char* value);
  inline void set_from(const char* value, size_t size);
  inline ::std::string* mutable_from();
  inline ::std::string* release_from();
  inline void set_allocated_from(::std::string* from);

  // required string to = 16;
  inline bool has_to() const;
  inline void clear_to();
  static const int kToFieldNumber = 16;
  inline const ::std::string& to() const;
  inline void set_to(const ::std::string& value);
  inline void set_to(const char* value);
  inline void set_to(const char* value, size_t size);
  inline ::std::string* mutable_to();
  inline ::std::string* release_to();
  inline void set_allocated_to(::std::string* to);

  // required int32 isStar = 17;
  inline bool has_isstar() const;
  inline void clear_isstar();
  static const int kIsStarFieldNumber = 17;
  inline ::google::protobuf::int32 isstar() const;
  inline void set_isstar(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ProtoNet.MatchSignInfo)
 private:
  inline void set_has_matchconfigid();
  inline void clear_has_matchconfigid();
  inline void set_has_matchname();
  inline void clear_has_matchname();
  inline void set_has_matchbigname();
  inline void clear_has_matchbigname();
  inline void set_has_matchdesc();
  inline void clear_has_matchdesc();
  inline void set_has_maxplayer();
  inline void clear_has_maxplayer();
  inline void set_has_currentplayernum();
  inline void clear_has_currentplayernum();
  inline void set_has_signbegintime();
  inline void clear_has_signbegintime();
  inline void set_has_duringtime();
  inline void clear_has_duringtime();
  inline void set_has_matchbegintime();
  inline void clear_has_matchbegintime();
  inline void set_has_randid();
  inline void clear_has_randid();
  inline void set_has_selfsignup();
  inline void clear_has_selfsignup();
  inline void set_has_times();
  inline void clear_has_times();
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_to();
  inline void clear_has_to();
  inline void set_has_isstar();
  inline void clear_has_isstar();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* matchname_;
  ::std::string* matchbigname_;
  ::google::protobuf::int32 matchconfigid_;
  ::google::protobuf::int32 maxplayer_;
  ::std::string* matchdesc_;
  ::google::protobuf::int64 signbegintime_;
  ::google::protobuf::int64 duringtime_;
  ::google::protobuf::int64 matchbegintime_;
  ::google::protobuf::int32 currentplayernum_;
  ::google::protobuf::int32 selfsignup_;
  ::google::protobuf::RepeatedPtrField< ::ProtoNet::ItemInfo > rewardinfos_;
  ::google::protobuf::RepeatedPtrField< ::ProtoNet::ItemInfo > costinfos_;
  ::std::string* randid_;
  ::std::string* from_;
  ::google::protobuf::int32 times_;
  ::google::protobuf::int32 isstar_;
  ::std::string* to_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];

  friend void  protobuf_AddDesc_MsgMatch_2eproto();
  friend void protobuf_AssignDesc_MsgMatch_2eproto();
  friend void protobuf_ShutdownFile_MsgMatch_2eproto();

  void InitAsDefaultInstance();
  static MatchSignInfo* default_instance_;
};
// -------------------------------------------------------------------

class ReqGetMatchList : public ::google::protobuf::Message {
 public:
  ReqGetMatchList();
  virtual ~ReqGetMatchList();

  ReqGetMatchList(const ReqGetMatchList& from);

  inline ReqGetMatchList& operator=(const ReqGetMatchList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqGetMatchList& default_instance();

  void Swap(ReqGetMatchList* other);

  // implements Message ----------------------------------------------

  ReqGetMatchList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqGetMatchList& from);
  void MergeFrom(const ReqGetMatchList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ProtoNet.ReqGetMatchList)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 gameid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MsgMatch_2eproto();
  friend void protobuf_AssignDesc_MsgMatch_2eproto();
  friend void protobuf_ShutdownFile_MsgMatch_2eproto();

  void InitAsDefaultInstance();
  static ReqGetMatchList* default_instance_;
};
// -------------------------------------------------------------------

class ResGetMatchList : public ::google::protobuf::Message {
 public:
  ResGetMatchList();
  virtual ~ResGetMatchList();

  ResGetMatchList(const ResGetMatchList& from);

  inline ResGetMatchList& operator=(const ResGetMatchList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResGetMatchList& default_instance();

  void Swap(ResGetMatchList* other);

  // implements Message ----------------------------------------------

  ResGetMatchList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResGetMatchList& from);
  void MergeFrom(const ResGetMatchList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoNet.ResponseResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::ProtoNet::ResponseResult& result() const;
  inline ::ProtoNet::ResponseResult* mutable_result();
  inline ::ProtoNet::ResponseResult* release_result();
  inline void set_allocated_result(::ProtoNet::ResponseResult* result);

  // repeated .ProtoNet.MatchSignInfo matchSignInfos = 2;
  inline int matchsigninfos_size() const;
  inline void clear_matchsigninfos();
  static const int kMatchSignInfosFieldNumber = 2;
  inline const ::ProtoNet::MatchSignInfo& matchsigninfos(int index) const;
  inline ::ProtoNet::MatchSignInfo* mutable_matchsigninfos(int index);
  inline ::ProtoNet::MatchSignInfo* add_matchsigninfos();
  inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::MatchSignInfo >&
      matchsigninfos() const;
  inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::MatchSignInfo >*
      mutable_matchsigninfos();

  // @@protoc_insertion_point(class_scope:ProtoNet.ResGetMatchList)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoNet::ResponseResult* result_;
  ::google::protobuf::RepeatedPtrField< ::ProtoNet::MatchSignInfo > matchsigninfos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MsgMatch_2eproto();
  friend void protobuf_AssignDesc_MsgMatch_2eproto();
  friend void protobuf_ShutdownFile_MsgMatch_2eproto();

  void InitAsDefaultInstance();
  static ResGetMatchList* default_instance_;
};
// -------------------------------------------------------------------

class ReqSignUpMatch : public ::google::protobuf::Message {
 public:
  ReqSignUpMatch();
  virtual ~ReqSignUpMatch();

  ReqSignUpMatch(const ReqSignUpMatch& from);

  inline ReqSignUpMatch& operator=(const ReqSignUpMatch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqSignUpMatch& default_instance();

  void Swap(ReqSignUpMatch* other);

  // implements Message ----------------------------------------------

  ReqSignUpMatch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqSignUpMatch& from);
  void MergeFrom(const ReqSignUpMatch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 matchId = 1;
  inline bool has_matchid() const;
  inline void clear_matchid();
  static const int kMatchIdFieldNumber = 1;
  inline ::google::protobuf::int32 matchid() const;
  inline void set_matchid(::google::protobuf::int32 value);

  // required string randId = 2;
  inline bool has_randid() const;
  inline void clear_randid();
  static const int kRandIdFieldNumber = 2;
  inline const ::std::string& randid() const;
  inline void set_randid(const ::std::string& value);
  inline void set_randid(const char* value);
  inline void set_randid(const char* value, size_t size);
  inline ::std::string* mutable_randid();
  inline ::std::string* release_randid();
  inline void set_allocated_randid(::std::string* randid);

  // @@protoc_insertion_point(class_scope:ProtoNet.ReqSignUpMatch)
 private:
  inline void set_has_matchid();
  inline void clear_has_matchid();
  inline void set_has_randid();
  inline void clear_has_randid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* randid_;
  ::google::protobuf::int32 matchid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MsgMatch_2eproto();
  friend void protobuf_AssignDesc_MsgMatch_2eproto();
  friend void protobuf_ShutdownFile_MsgMatch_2eproto();

  void InitAsDefaultInstance();
  static ReqSignUpMatch* default_instance_;
};
// -------------------------------------------------------------------

class ResSignUpMatch : public ::google::protobuf::Message {
 public:
  ResSignUpMatch();
  virtual ~ResSignUpMatch();

  ResSignUpMatch(const ResSignUpMatch& from);

  inline ResSignUpMatch& operator=(const ResSignUpMatch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResSignUpMatch& default_instance();

  void Swap(ResSignUpMatch* other);

  // implements Message ----------------------------------------------

  ResSignUpMatch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResSignUpMatch& from);
  void MergeFrom(const ResSignUpMatch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoNet.ResponseResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::ProtoNet::ResponseResult& result() const;
  inline ::ProtoNet::ResponseResult* mutable_result();
  inline ::ProtoNet::ResponseResult* release_result();
  inline void set_allocated_result(::ProtoNet::ResponseResult* result);

  // optional int32 matchConfigId = 2;
  inline bool has_matchconfigid() const;
  inline void clear_matchconfigid();
  static const int kMatchConfigIdFieldNumber = 2;
  inline ::google::protobuf::int32 matchconfigid() const;
  inline void set_matchconfigid(::google::protobuf::int32 value);

  // optional string randId = 3;
  inline bool has_randid() const;
  inline void clear_randid();
  static const int kRandIdFieldNumber = 3;
  inline const ::std::string& randid() const;
  inline void set_randid(const ::std::string& value);
  inline void set_randid(const char* value);
  inline void set_randid(const char* value, size_t size);
  inline ::std::string* mutable_randid();
  inline ::std::string* release_randid();
  inline void set_allocated_randid(::std::string* randid);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResSignUpMatch)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_matchconfigid();
  inline void clear_has_matchconfigid();
  inline void set_has_randid();
  inline void clear_has_randid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoNet::ResponseResult* result_;
  ::std::string* randid_;
  ::google::protobuf::int32 matchconfigid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_MsgMatch_2eproto();
  friend void protobuf_AssignDesc_MsgMatch_2eproto();
  friend void protobuf_ShutdownFile_MsgMatch_2eproto();

  void InitAsDefaultInstance();
  static ResSignUpMatch* default_instance_;
};
// -------------------------------------------------------------------

class ResNotifyEnterMatch : public ::google::protobuf::Message {
 public:
  ResNotifyEnterMatch();
  virtual ~ResNotifyEnterMatch();

  ResNotifyEnterMatch(const ResNotifyEnterMatch& from);

  inline ResNotifyEnterMatch& operator=(const ResNotifyEnterMatch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResNotifyEnterMatch& default_instance();

  void Swap(ResNotifyEnterMatch* other);

  // implements Message ----------------------------------------------

  ResNotifyEnterMatch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResNotifyEnterMatch& from);
  void MergeFrom(const ResNotifyEnterMatch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string roomId = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 1;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const char* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  inline void set_allocated_roomid(::std::string* roomid);

  // required string roomName = 2;
  inline bool has_roomname() const;
  inline void clear_roomname();
  static const int kRoomNameFieldNumber = 2;
  inline const ::std::string& roomname() const;
  inline void set_roomname(const ::std::string& value);
  inline void set_roomname(const char* value);
  inline void set_roomname(const char* value, size_t size);
  inline ::std::string* mutable_roomname();
  inline ::std::string* release_roomname();
  inline void set_allocated_roomname(::std::string* roomname);

  // required string roomerUniqueId = 3;
  inline bool has_roomeruniqueid() const;
  inline void clear_roomeruniqueid();
  static const int kRoomerUniqueIdFieldNumber = 3;
  inline const ::std::string& roomeruniqueid() const;
  inline void set_roomeruniqueid(const ::std::string& value);
  inline void set_roomeruniqueid(const char* value);
  inline void set_roomeruniqueid(const char* value, size_t size);
  inline ::std::string* mutable_roomeruniqueid();
  inline ::std::string* release_roomeruniqueid();
  inline void set_allocated_roomeruniqueid(::std::string* roomeruniqueid);

  // required string roomerNickName = 4;
  inline bool has_roomernickname() const;
  inline void clear_roomernickname();
  static const int kRoomerNickNameFieldNumber = 4;
  inline const ::std::string& roomernickname() const;
  inline void set_roomernickname(const ::std::string& value);
  inline void set_roomernickname(const char* value);
  inline void set_roomernickname(const char* value, size_t size);
  inline ::std::string* mutable_roomernickname();
  inline ::std::string* release_roomernickname();
  inline void set_allocated_roomernickname(::std::string* roomernickname);

  // required string roomerHeadImg = 5;
  inline bool has_roomerheadimg() const;
  inline void clear_roomerheadimg();
  static const int kRoomerHeadImgFieldNumber = 5;
  inline const ::std::string& roomerheadimg() const;
  inline void set_roomerheadimg(const ::std::string& value);
  inline void set_roomerheadimg(const char* value);
  inline void set_roomerheadimg(const char* value, size_t size);
  inline ::std::string* mutable_roomerheadimg();
  inline ::std::string* release_roomerheadimg();
  inline void set_allocated_roomerheadimg(::std::string* roomerheadimg);

  // required int32 roomerHeadType = 6;
  inline bool has_roomerheadtype() const;
  inline void clear_roomerheadtype();
  static const int kRoomerHeadTypeFieldNumber = 6;
  inline ::google::protobuf::int32 roomerheadtype() const;
  inline void set_roomerheadtype(::google::protobuf::int32 value);

  // required int32 roomType = 7;
  inline bool has_roomtype() const;
  inline void clear_roomtype();
  static const int kRoomTypeFieldNumber = 7;
  inline ::google::protobuf::int32 roomtype() const;
  inline void set_roomtype(::google::protobuf::int32 value);

  // required .ProtoNet.ServerInfoIpsSafeDetail serverInfo = 8;
  inline bool has_serverinfo() const;
  inline void clear_serverinfo();
  static const int kServerInfoFieldNumber = 8;
  inline const ::ProtoNet::ServerInfoIpsSafeDetail& serverinfo() const;
  inline ::ProtoNet::ServerInfoIpsSafeDetail* mutable_serverinfo();
  inline ::ProtoNet::ServerInfoIpsSafeDetail* release_serverinfo();
  inline void set_allocated_serverinfo(::ProtoNet::ServerInfoIpsSafeDetail* serverinfo);

  // required int32 times = 9;
  inline bool has_times() const;
  inline void clear_times();
  static const int kTimesFieldNumber = 9;
  inline ::google::protobuf::int32 times() const;
  inline void set_times(::google::protobuf::int32 value);

  // required int32 gameId = 10;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 10;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);

  // required int32 timesType = 11;
  inline bool has_timestype() const;
  inline void clear_timestype();
  static const int kTimesTypeFieldNumber = 11;
  inline ::google::protobuf::int32 timestype() const;
  inline void set_timestype(::google::protobuf::int32 value);

  // required string from = 12;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 12;
  inline const ::std::string& from() const;
  inline void set_from(const ::std::string& value);
  inline void set_from(const char* value);
  inline void set_from(const char* value, size_t size);
  inline ::std::string* mutable_from();
  inline ::std::string* release_from();
  inline void set_allocated_from(::std::string* from);

  // required string to = 13;
  inline bool has_to() const;
  inline void clear_to();
  static const int kToFieldNumber = 13;
  inline const ::std::string& to() const;
  inline void set_to(const ::std::string& value);
  inline void set_to(const char* value);
  inline void set_to(const char* value, size_t size);
  inline ::std::string* mutable_to();
  inline ::std::string* release_to();
  inline void set_allocated_to(::std::string* to);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResNotifyEnterMatch)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_roomname();
  inline void clear_has_roomname();
  inline void set_has_roomeruniqueid();
  inline void clear_has_roomeruniqueid();
  inline void set_has_roomernickname();
  inline void clear_has_roomernickname();
  inline void set_has_roomerheadimg();
  inline void clear_has_roomerheadimg();
  inline void set_has_roomerheadtype();
  inline void clear_has_roomerheadtype();
  inline void set_has_roomtype();
  inline void clear_has_roomtype();
  inline void set_has_serverinfo();
  inline void clear_has_serverinfo();
  inline void set_has_times();
  inline void clear_has_times();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_timestype();
  inline void clear_has_timestype();
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_to();
  inline void clear_has_to();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* roomid_;
  ::std::string* roomname_;
  ::std::string* roomeruniqueid_;
  ::std::string* roomernickname_;
  ::std::string* roomerheadimg_;
  ::google::protobuf::int32 roomerheadtype_;
  ::google::protobuf::int32 roomtype_;
  ::ProtoNet::ServerInfoIpsSafeDetail* serverinfo_;
  ::google::protobuf::int32 times_;
  ::google::protobuf::int32 gameid_;
  ::std::string* from_;
  ::std::string* to_;
  ::google::protobuf::int32 timestype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_MsgMatch_2eproto();
  friend void protobuf_AssignDesc_MsgMatch_2eproto();
  friend void protobuf_ShutdownFile_MsgMatch_2eproto();

  void InitAsDefaultInstance();
  static ResNotifyEnterMatch* default_instance_;
};
// -------------------------------------------------------------------

class ReqCanleSignMatch : public ::google::protobuf::Message {
 public:
  ReqCanleSignMatch();
  virtual ~ReqCanleSignMatch();

  ReqCanleSignMatch(const ReqCanleSignMatch& from);

  inline ReqCanleSignMatch& operator=(const ReqCanleSignMatch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqCanleSignMatch& default_instance();

  void Swap(ReqCanleSignMatch* other);

  // implements Message ----------------------------------------------

  ReqCanleSignMatch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqCanleSignMatch& from);
  void MergeFrom(const ReqCanleSignMatch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 matchId = 1;
  inline bool has_matchid() const;
  inline void clear_matchid();
  static const int kMatchIdFieldNumber = 1;
  inline ::google::protobuf::int32 matchid() const;
  inline void set_matchid(::google::protobuf::int32 value);

  // required string randId = 2;
  inline bool has_randid() const;
  inline void clear_randid();
  static const int kRandIdFieldNumber = 2;
  inline const ::std::string& randid() const;
  inline void set_randid(const ::std::string& value);
  inline void set_randid(const char* value);
  inline void set_randid(const char* value, size_t size);
  inline ::std::string* mutable_randid();
  inline ::std::string* release_randid();
  inline void set_allocated_randid(::std::string* randid);

  // @@protoc_insertion_point(class_scope:ProtoNet.ReqCanleSignMatch)
 private:
  inline void set_has_matchid();
  inline void clear_has_matchid();
  inline void set_has_randid();
  inline void clear_has_randid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* randid_;
  ::google::protobuf::int32 matchid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MsgMatch_2eproto();
  friend void protobuf_AssignDesc_MsgMatch_2eproto();
  friend void protobuf_ShutdownFile_MsgMatch_2eproto();

  void InitAsDefaultInstance();
  static ReqCanleSignMatch* default_instance_;
};
// -------------------------------------------------------------------

class ResCanleSignMatch : public ::google::protobuf::Message {
 public:
  ResCanleSignMatch();
  virtual ~ResCanleSignMatch();

  ResCanleSignMatch(const ResCanleSignMatch& from);

  inline ResCanleSignMatch& operator=(const ResCanleSignMatch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResCanleSignMatch& default_instance();

  void Swap(ResCanleSignMatch* other);

  // implements Message ----------------------------------------------

  ResCanleSignMatch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResCanleSignMatch& from);
  void MergeFrom(const ResCanleSignMatch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoNet.ResponseResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::ProtoNet::ResponseResult& result() const;
  inline ::ProtoNet::ResponseResult* mutable_result();
  inline ::ProtoNet::ResponseResult* release_result();
  inline void set_allocated_result(::ProtoNet::ResponseResult* result);

  // optional int32 matchConfigId = 2;
  inline bool has_matchconfigid() const;
  inline void clear_matchconfigid();
  static const int kMatchConfigIdFieldNumber = 2;
  inline ::google::protobuf::int32 matchconfigid() const;
  inline void set_matchconfigid(::google::protobuf::int32 value);

  // optional string randId = 3;
  inline bool has_randid() const;
  inline void clear_randid();
  static const int kRandIdFieldNumber = 3;
  inline const ::std::string& randid() const;
  inline void set_randid(const ::std::string& value);
  inline void set_randid(const char* value);
  inline void set_randid(const char* value, size_t size);
  inline ::std::string* mutable_randid();
  inline ::std::string* release_randid();
  inline void set_allocated_randid(::std::string* randid);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResCanleSignMatch)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_matchconfigid();
  inline void clear_has_matchconfigid();
  inline void set_has_randid();
  inline void clear_has_randid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoNet::ResponseResult* result_;
  ::std::string* randid_;
  ::google::protobuf::int32 matchconfigid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_MsgMatch_2eproto();
  friend void protobuf_AssignDesc_MsgMatch_2eproto();
  friend void protobuf_ShutdownFile_MsgMatch_2eproto();

  void InitAsDefaultInstance();
  static ResCanleSignMatch* default_instance_;
};
// -------------------------------------------------------------------

class ResNotifyMatchRoomWattingChange : public ::google::protobuf::Message {
 public:
  ResNotifyMatchRoomWattingChange();
  virtual ~ResNotifyMatchRoomWattingChange();

  ResNotifyMatchRoomWattingChange(const ResNotifyMatchRoomWattingChange& from);

  inline ResNotifyMatchRoomWattingChange& operator=(const ResNotifyMatchRoomWattingChange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResNotifyMatchRoomWattingChange& default_instance();

  void Swap(ResNotifyMatchRoomWattingChange* other);

  // implements Message ----------------------------------------------

  ResNotifyMatchRoomWattingChange* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResNotifyMatchRoomWattingChange& from);
  void MergeFrom(const ResNotifyMatchRoomWattingChange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string roomId = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 1;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const char* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  inline void set_allocated_roomid(::std::string* roomid);

  // required int32 gameId = 2;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 2;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);

  // required int32 roomType = 3;
  inline bool has_roomtype() const;
  inline void clear_roomtype();
  static const int kRoomTypeFieldNumber = 3;
  inline ::google::protobuf::int32 roomtype() const;
  inline void set_roomtype(::google::protobuf::int32 value);

  // required int32 timesType = 4;
  inline bool has_timestype() const;
  inline void clear_timestype();
  static const int kTimesTypeFieldNumber = 4;
  inline ::google::protobuf::int32 timestype() const;
  inline void set_timestype(::google::protobuf::int32 value);

  // required int32 waitting = 5;
  inline bool has_waitting() const;
  inline void clear_waitting();
  static const int kWaittingFieldNumber = 5;
  inline ::google::protobuf::int32 waitting() const;
  inline void set_waitting(::google::protobuf::int32 value);

  // required string randId = 6;
  inline bool has_randid() const;
  inline void clear_randid();
  static const int kRandIdFieldNumber = 6;
  inline const ::std::string& randid() const;
  inline void set_randid(const ::std::string& value);
  inline void set_randid(const char* value);
  inline void set_randid(const char* value, size_t size);
  inline ::std::string* mutable_randid();
  inline ::std::string* release_randid();
  inline void set_allocated_randid(::std::string* randid);

  // required int32 times = 7;
  inline bool has_times() const;
  inline void clear_times();
  static const int kTimesFieldNumber = 7;
  inline ::google::protobuf::int32 times() const;
  inline void set_times(::google::protobuf::int32 value);

  // required string from = 8;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 8;
  inline const ::std::string& from() const;
  inline void set_from(const ::std::string& value);
  inline void set_from(const char* value);
  inline void set_from(const char* value, size_t size);
  inline ::std::string* mutable_from();
  inline ::std::string* release_from();
  inline void set_allocated_from(::std::string* from);

  // required string to = 9;
  inline bool has_to() const;
  inline void clear_to();
  static const int kToFieldNumber = 9;
  inline const ::std::string& to() const;
  inline void set_to(const ::std::string& value);
  inline void set_to(const char* value);
  inline void set_to(const char* value, size_t size);
  inline ::std::string* mutable_to();
  inline ::std::string* release_to();
  inline void set_allocated_to(::std::string* to);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResNotifyMatchRoomWattingChange)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_roomtype();
  inline void clear_has_roomtype();
  inline void set_has_timestype();
  inline void clear_has_timestype();
  inline void set_has_waitting();
  inline void clear_has_waitting();
  inline void set_has_randid();
  inline void clear_has_randid();
  inline void set_has_times();
  inline void clear_has_times();
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_to();
  inline void clear_has_to();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* roomid_;
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 roomtype_;
  ::google::protobuf::int32 timestype_;
  ::google::protobuf::int32 waitting_;
  ::std::string* randid_;
  ::std::string* from_;
  ::std::string* to_;
  ::google::protobuf::int32 times_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_MsgMatch_2eproto();
  friend void protobuf_AssignDesc_MsgMatch_2eproto();
  friend void protobuf_ShutdownFile_MsgMatch_2eproto();

  void InitAsDefaultInstance();
  static ResNotifyMatchRoomWattingChange* default_instance_;
};
// -------------------------------------------------------------------

class ResNotifyTimesOver : public ::google::protobuf::Message {
 public:
  ResNotifyTimesOver();
  virtual ~ResNotifyTimesOver();

  ResNotifyTimesOver(const ResNotifyTimesOver& from);

  inline ResNotifyTimesOver& operator=(const ResNotifyTimesOver& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResNotifyTimesOver& default_instance();

  void Swap(ResNotifyTimesOver* other);

  // implements Message ----------------------------------------------

  ResNotifyTimesOver* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResNotifyTimesOver& from);
  void MergeFrom(const ResNotifyTimesOver& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 matchConfigId = 1;
  inline bool has_matchconfigid() const;
  inline void clear_matchconfigid();
  static const int kMatchConfigIdFieldNumber = 1;
  inline ::google::protobuf::int32 matchconfigid() const;
  inline void set_matchconfigid(::google::protobuf::int32 value);

  // required int32 gameId = 2;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 2;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);

  // required string randId = 3;
  inline bool has_randid() const;
  inline void clear_randid();
  static const int kRandIdFieldNumber = 3;
  inline const ::std::string& randid() const;
  inline void set_randid(const ::std::string& value);
  inline void set_randid(const char* value);
  inline void set_randid(const char* value, size_t size);
  inline ::std::string* mutable_randid();
  inline ::std::string* release_randid();
  inline void set_allocated_randid(::std::string* randid);

  // required int32 times = 4;
  inline bool has_times() const;
  inline void clear_times();
  static const int kTimesFieldNumber = 4;
  inline ::google::protobuf::int32 times() const;
  inline void set_times(::google::protobuf::int32 value);

  // required string from = 5;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 5;
  inline const ::std::string& from() const;
  inline void set_from(const ::std::string& value);
  inline void set_from(const char* value);
  inline void set_from(const char* value, size_t size);
  inline ::std::string* mutable_from();
  inline ::std::string* release_from();
  inline void set_allocated_from(::std::string* from);

  // required string to = 6;
  inline bool has_to() const;
  inline void clear_to();
  static const int kToFieldNumber = 6;
  inline const ::std::string& to() const;
  inline void set_to(const ::std::string& value);
  inline void set_to(const char* value);
  inline void set_to(const char* value, size_t size);
  inline ::std::string* mutable_to();
  inline ::std::string* release_to();
  inline void set_allocated_to(::std::string* to);

  // required int32 selfRank = 7;
  inline bool has_selfrank() const;
  inline void clear_selfrank();
  static const int kSelfRankFieldNumber = 7;
  inline ::google::protobuf::int32 selfrank() const;
  inline void set_selfrank(::google::protobuf::int32 value);

  // required int32 taotai = 8;
  inline bool has_taotai() const;
  inline void clear_taotai();
  static const int kTaotaiFieldNumber = 8;
  inline ::google::protobuf::int32 taotai() const;
  inline void set_taotai(::google::protobuf::int32 value);

  // required int32 matchOver = 9;
  inline bool has_matchover() const;
  inline void clear_matchover();
  static const int kMatchOverFieldNumber = 9;
  inline ::google::protobuf::int32 matchover() const;
  inline void set_matchover(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResNotifyTimesOver)
 private:
  inline void set_has_matchconfigid();
  inline void clear_has_matchconfigid();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_randid();
  inline void clear_has_randid();
  inline void set_has_times();
  inline void clear_has_times();
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_to();
  inline void clear_has_to();
  inline void set_has_selfrank();
  inline void clear_has_selfrank();
  inline void set_has_taotai();
  inline void clear_has_taotai();
  inline void set_has_matchover();
  inline void clear_has_matchover();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 matchconfigid_;
  ::google::protobuf::int32 gameid_;
  ::std::string* randid_;
  ::std::string* from_;
  ::google::protobuf::int32 times_;
  ::google::protobuf::int32 selfrank_;
  ::std::string* to_;
  ::google::protobuf::int32 taotai_;
  ::google::protobuf::int32 matchover_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_MsgMatch_2eproto();
  friend void protobuf_AssignDesc_MsgMatch_2eproto();
  friend void protobuf_ShutdownFile_MsgMatch_2eproto();

  void InitAsDefaultInstance();
  static ResNotifyTimesOver* default_instance_;
};
// -------------------------------------------------------------------

class ReqContinueMatch : public ::google::protobuf::Message {
 public:
  ReqContinueMatch();
  virtual ~ReqContinueMatch();

  ReqContinueMatch(const ReqContinueMatch& from);

  inline ReqContinueMatch& operator=(const ReqContinueMatch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqContinueMatch& default_instance();

  void Swap(ReqContinueMatch* other);

  // implements Message ----------------------------------------------

  ReqContinueMatch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqContinueMatch& from);
  void MergeFrom(const ReqContinueMatch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 matchConfigId = 1;
  inline bool has_matchconfigid() const;
  inline void clear_matchconfigid();
  static const int kMatchConfigIdFieldNumber = 1;
  inline ::google::protobuf::int32 matchconfigid() const;
  inline void set_matchconfigid(::google::protobuf::int32 value);

  // required int32 gameId = 2;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 2;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);

  // required string randId = 3;
  inline bool has_randid() const;
  inline void clear_randid();
  static const int kRandIdFieldNumber = 3;
  inline const ::std::string& randid() const;
  inline void set_randid(const ::std::string& value);
  inline void set_randid(const char* value);
  inline void set_randid(const char* value, size_t size);
  inline ::std::string* mutable_randid();
  inline ::std::string* release_randid();
  inline void set_allocated_randid(::std::string* randid);

  // @@protoc_insertion_point(class_scope:ProtoNet.ReqContinueMatch)
 private:
  inline void set_has_matchconfigid();
  inline void clear_has_matchconfigid();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_randid();
  inline void clear_has_randid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 matchconfigid_;
  ::google::protobuf::int32 gameid_;
  ::std::string* randid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_MsgMatch_2eproto();
  friend void protobuf_AssignDesc_MsgMatch_2eproto();
  friend void protobuf_ShutdownFile_MsgMatch_2eproto();

  void InitAsDefaultInstance();
  static ReqContinueMatch* default_instance_;
};
// -------------------------------------------------------------------

class ResContinueMatch : public ::google::protobuf::Message {
 public:
  ResContinueMatch();
  virtual ~ResContinueMatch();

  ResContinueMatch(const ResContinueMatch& from);

  inline ResContinueMatch& operator=(const ResContinueMatch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResContinueMatch& default_instance();

  void Swap(ResContinueMatch* other);

  // implements Message ----------------------------------------------

  ResContinueMatch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResContinueMatch& from);
  void MergeFrom(const ResContinueMatch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoNet.ResponseResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::ProtoNet::ResponseResult& result() const;
  inline ::ProtoNet::ResponseResult* mutable_result();
  inline ::ProtoNet::ResponseResult* release_result();
  inline void set_allocated_result(::ProtoNet::ResponseResult* result);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResContinueMatch)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoNet::ResponseResult* result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MsgMatch_2eproto();
  friend void protobuf_AssignDesc_MsgMatch_2eproto();
  friend void protobuf_ShutdownFile_MsgMatch_2eproto();

  void InitAsDefaultInstance();
  static ResContinueMatch* default_instance_;
};
// ===================================================================


// ===================================================================

// ItemInfo

// required int32 itemId = 1;
inline bool ItemInfo::has_itemid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ItemInfo::set_has_itemid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ItemInfo::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ItemInfo::clear_itemid() {
  itemid_ = 0;
  clear_has_itemid();
}
inline ::google::protobuf::int32 ItemInfo::itemid() const {
  return itemid_;
}
inline void ItemInfo::set_itemid(::google::protobuf::int32 value) {
  set_has_itemid();
  itemid_ = value;
}

// required int32 num = 2;
inline bool ItemInfo::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ItemInfo::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ItemInfo::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ItemInfo::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 ItemInfo::num() const {
  return num_;
}
inline void ItemInfo::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// -------------------------------------------------------------------

// MatchSignInfo

// required int32 matchConfigId = 1;
inline bool MatchSignInfo::has_matchconfigid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MatchSignInfo::set_has_matchconfigid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MatchSignInfo::clear_has_matchconfigid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MatchSignInfo::clear_matchconfigid() {
  matchconfigid_ = 0;
  clear_has_matchconfigid();
}
inline ::google::protobuf::int32 MatchSignInfo::matchconfigid() const {
  return matchconfigid_;
}
inline void MatchSignInfo::set_matchconfigid(::google::protobuf::int32 value) {
  set_has_matchconfigid();
  matchconfigid_ = value;
}

// required string matchName = 2;
inline bool MatchSignInfo::has_matchname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MatchSignInfo::set_has_matchname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MatchSignInfo::clear_has_matchname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MatchSignInfo::clear_matchname() {
  if (matchname_ != &::google::protobuf::internal::kEmptyString) {
    matchname_->clear();
  }
  clear_has_matchname();
}
inline const ::std::string& MatchSignInfo::matchname() const {
  return *matchname_;
}
inline void MatchSignInfo::set_matchname(const ::std::string& value) {
  set_has_matchname();
  if (matchname_ == &::google::protobuf::internal::kEmptyString) {
    matchname_ = new ::std::string;
  }
  matchname_->assign(value);
}
inline void MatchSignInfo::set_matchname(const char* value) {
  set_has_matchname();
  if (matchname_ == &::google::protobuf::internal::kEmptyString) {
    matchname_ = new ::std::string;
  }
  matchname_->assign(value);
}
inline void MatchSignInfo::set_matchname(const char* value, size_t size) {
  set_has_matchname();
  if (matchname_ == &::google::protobuf::internal::kEmptyString) {
    matchname_ = new ::std::string;
  }
  matchname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MatchSignInfo::mutable_matchname() {
  set_has_matchname();
  if (matchname_ == &::google::protobuf::internal::kEmptyString) {
    matchname_ = new ::std::string;
  }
  return matchname_;
}
inline ::std::string* MatchSignInfo::release_matchname() {
  clear_has_matchname();
  if (matchname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = matchname_;
    matchname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MatchSignInfo::set_allocated_matchname(::std::string* matchname) {
  if (matchname_ != &::google::protobuf::internal::kEmptyString) {
    delete matchname_;
  }
  if (matchname) {
    set_has_matchname();
    matchname_ = matchname;
  } else {
    clear_has_matchname();
    matchname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string matchBigName = 3;
inline bool MatchSignInfo::has_matchbigname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MatchSignInfo::set_has_matchbigname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MatchSignInfo::clear_has_matchbigname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MatchSignInfo::clear_matchbigname() {
  if (matchbigname_ != &::google::protobuf::internal::kEmptyString) {
    matchbigname_->clear();
  }
  clear_has_matchbigname();
}
inline const ::std::string& MatchSignInfo::matchbigname() const {
  return *matchbigname_;
}
inline void MatchSignInfo::set_matchbigname(const ::std::string& value) {
  set_has_matchbigname();
  if (matchbigname_ == &::google::protobuf::internal::kEmptyString) {
    matchbigname_ = new ::std::string;
  }
  matchbigname_->assign(value);
}
inline void MatchSignInfo::set_matchbigname(const char* value) {
  set_has_matchbigname();
  if (matchbigname_ == &::google::protobuf::internal::kEmptyString) {
    matchbigname_ = new ::std::string;
  }
  matchbigname_->assign(value);
}
inline void MatchSignInfo::set_matchbigname(const char* value, size_t size) {
  set_has_matchbigname();
  if (matchbigname_ == &::google::protobuf::internal::kEmptyString) {
    matchbigname_ = new ::std::string;
  }
  matchbigname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MatchSignInfo::mutable_matchbigname() {
  set_has_matchbigname();
  if (matchbigname_ == &::google::protobuf::internal::kEmptyString) {
    matchbigname_ = new ::std::string;
  }
  return matchbigname_;
}
inline ::std::string* MatchSignInfo::release_matchbigname() {
  clear_has_matchbigname();
  if (matchbigname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = matchbigname_;
    matchbigname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MatchSignInfo::set_allocated_matchbigname(::std::string* matchbigname) {
  if (matchbigname_ != &::google::protobuf::internal::kEmptyString) {
    delete matchbigname_;
  }
  if (matchbigname) {
    set_has_matchbigname();
    matchbigname_ = matchbigname;
  } else {
    clear_has_matchbigname();
    matchbigname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string matchDesc = 4;
inline bool MatchSignInfo::has_matchdesc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MatchSignInfo::set_has_matchdesc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MatchSignInfo::clear_has_matchdesc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MatchSignInfo::clear_matchdesc() {
  if (matchdesc_ != &::google::protobuf::internal::kEmptyString) {
    matchdesc_->clear();
  }
  clear_has_matchdesc();
}
inline const ::std::string& MatchSignInfo::matchdesc() const {
  return *matchdesc_;
}
inline void MatchSignInfo::set_matchdesc(const ::std::string& value) {
  set_has_matchdesc();
  if (matchdesc_ == &::google::protobuf::internal::kEmptyString) {
    matchdesc_ = new ::std::string;
  }
  matchdesc_->assign(value);
}
inline void MatchSignInfo::set_matchdesc(const char* value) {
  set_has_matchdesc();
  if (matchdesc_ == &::google::protobuf::internal::kEmptyString) {
    matchdesc_ = new ::std::string;
  }
  matchdesc_->assign(value);
}
inline void MatchSignInfo::set_matchdesc(const char* value, size_t size) {
  set_has_matchdesc();
  if (matchdesc_ == &::google::protobuf::internal::kEmptyString) {
    matchdesc_ = new ::std::string;
  }
  matchdesc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MatchSignInfo::mutable_matchdesc() {
  set_has_matchdesc();
  if (matchdesc_ == &::google::protobuf::internal::kEmptyString) {
    matchdesc_ = new ::std::string;
  }
  return matchdesc_;
}
inline ::std::string* MatchSignInfo::release_matchdesc() {
  clear_has_matchdesc();
  if (matchdesc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = matchdesc_;
    matchdesc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MatchSignInfo::set_allocated_matchdesc(::std::string* matchdesc) {
  if (matchdesc_ != &::google::protobuf::internal::kEmptyString) {
    delete matchdesc_;
  }
  if (matchdesc) {
    set_has_matchdesc();
    matchdesc_ = matchdesc;
  } else {
    clear_has_matchdesc();
    matchdesc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 maxPlayer = 5;
inline bool MatchSignInfo::has_maxplayer() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MatchSignInfo::set_has_maxplayer() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MatchSignInfo::clear_has_maxplayer() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MatchSignInfo::clear_maxplayer() {
  maxplayer_ = 0;
  clear_has_maxplayer();
}
inline ::google::protobuf::int32 MatchSignInfo::maxplayer() const {
  return maxplayer_;
}
inline void MatchSignInfo::set_maxplayer(::google::protobuf::int32 value) {
  set_has_maxplayer();
  maxplayer_ = value;
}

// required int32 currentPlayerNum = 6;
inline bool MatchSignInfo::has_currentplayernum() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MatchSignInfo::set_has_currentplayernum() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MatchSignInfo::clear_has_currentplayernum() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MatchSignInfo::clear_currentplayernum() {
  currentplayernum_ = 0;
  clear_has_currentplayernum();
}
inline ::google::protobuf::int32 MatchSignInfo::currentplayernum() const {
  return currentplayernum_;
}
inline void MatchSignInfo::set_currentplayernum(::google::protobuf::int32 value) {
  set_has_currentplayernum();
  currentplayernum_ = value;
}

// required int64 signBeginTime = 7;
inline bool MatchSignInfo::has_signbegintime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MatchSignInfo::set_has_signbegintime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MatchSignInfo::clear_has_signbegintime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MatchSignInfo::clear_signbegintime() {
  signbegintime_ = GOOGLE_LONGLONG(0);
  clear_has_signbegintime();
}
inline ::google::protobuf::int64 MatchSignInfo::signbegintime() const {
  return signbegintime_;
}
inline void MatchSignInfo::set_signbegintime(::google::protobuf::int64 value) {
  set_has_signbegintime();
  signbegintime_ = value;
}

// required int64 duringTime = 8;
inline bool MatchSignInfo::has_duringtime() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MatchSignInfo::set_has_duringtime() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MatchSignInfo::clear_has_duringtime() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MatchSignInfo::clear_duringtime() {
  duringtime_ = GOOGLE_LONGLONG(0);
  clear_has_duringtime();
}
inline ::google::protobuf::int64 MatchSignInfo::duringtime() const {
  return duringtime_;
}
inline void MatchSignInfo::set_duringtime(::google::protobuf::int64 value) {
  set_has_duringtime();
  duringtime_ = value;
}

// required int64 matchBeginTime = 9;
inline bool MatchSignInfo::has_matchbegintime() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MatchSignInfo::set_has_matchbegintime() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MatchSignInfo::clear_has_matchbegintime() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MatchSignInfo::clear_matchbegintime() {
  matchbegintime_ = GOOGLE_LONGLONG(0);
  clear_has_matchbegintime();
}
inline ::google::protobuf::int64 MatchSignInfo::matchbegintime() const {
  return matchbegintime_;
}
inline void MatchSignInfo::set_matchbegintime(::google::protobuf::int64 value) {
  set_has_matchbegintime();
  matchbegintime_ = value;
}

// repeated .ProtoNet.ItemInfo rewardInfos = 10;
inline int MatchSignInfo::rewardinfos_size() const {
  return rewardinfos_.size();
}
inline void MatchSignInfo::clear_rewardinfos() {
  rewardinfos_.Clear();
}
inline const ::ProtoNet::ItemInfo& MatchSignInfo::rewardinfos(int index) const {
  return rewardinfos_.Get(index);
}
inline ::ProtoNet::ItemInfo* MatchSignInfo::mutable_rewardinfos(int index) {
  return rewardinfos_.Mutable(index);
}
inline ::ProtoNet::ItemInfo* MatchSignInfo::add_rewardinfos() {
  return rewardinfos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::ItemInfo >&
MatchSignInfo::rewardinfos() const {
  return rewardinfos_;
}
inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::ItemInfo >*
MatchSignInfo::mutable_rewardinfos() {
  return &rewardinfos_;
}

// repeated .ProtoNet.ItemInfo costInfos = 11;
inline int MatchSignInfo::costinfos_size() const {
  return costinfos_.size();
}
inline void MatchSignInfo::clear_costinfos() {
  costinfos_.Clear();
}
inline const ::ProtoNet::ItemInfo& MatchSignInfo::costinfos(int index) const {
  return costinfos_.Get(index);
}
inline ::ProtoNet::ItemInfo* MatchSignInfo::mutable_costinfos(int index) {
  return costinfos_.Mutable(index);
}
inline ::ProtoNet::ItemInfo* MatchSignInfo::add_costinfos() {
  return costinfos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::ItemInfo >&
MatchSignInfo::costinfos() const {
  return costinfos_;
}
inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::ItemInfo >*
MatchSignInfo::mutable_costinfos() {
  return &costinfos_;
}

// required string randId = 12;
inline bool MatchSignInfo::has_randid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MatchSignInfo::set_has_randid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MatchSignInfo::clear_has_randid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MatchSignInfo::clear_randid() {
  if (randid_ != &::google::protobuf::internal::kEmptyString) {
    randid_->clear();
  }
  clear_has_randid();
}
inline const ::std::string& MatchSignInfo::randid() const {
  return *randid_;
}
inline void MatchSignInfo::set_randid(const ::std::string& value) {
  set_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    randid_ = new ::std::string;
  }
  randid_->assign(value);
}
inline void MatchSignInfo::set_randid(const char* value) {
  set_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    randid_ = new ::std::string;
  }
  randid_->assign(value);
}
inline void MatchSignInfo::set_randid(const char* value, size_t size) {
  set_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    randid_ = new ::std::string;
  }
  randid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MatchSignInfo::mutable_randid() {
  set_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    randid_ = new ::std::string;
  }
  return randid_;
}
inline ::std::string* MatchSignInfo::release_randid() {
  clear_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = randid_;
    randid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MatchSignInfo::set_allocated_randid(::std::string* randid) {
  if (randid_ != &::google::protobuf::internal::kEmptyString) {
    delete randid_;
  }
  if (randid) {
    set_has_randid();
    randid_ = randid;
  } else {
    clear_has_randid();
    randid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 selfSignUp = 13;
inline bool MatchSignInfo::has_selfsignup() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MatchSignInfo::set_has_selfsignup() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MatchSignInfo::clear_has_selfsignup() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MatchSignInfo::clear_selfsignup() {
  selfsignup_ = 0;
  clear_has_selfsignup();
}
inline ::google::protobuf::int32 MatchSignInfo::selfsignup() const {
  return selfsignup_;
}
inline void MatchSignInfo::set_selfsignup(::google::protobuf::int32 value) {
  set_has_selfsignup();
  selfsignup_ = value;
}

// required int32 times = 14;
inline bool MatchSignInfo::has_times() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MatchSignInfo::set_has_times() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MatchSignInfo::clear_has_times() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MatchSignInfo::clear_times() {
  times_ = 0;
  clear_has_times();
}
inline ::google::protobuf::int32 MatchSignInfo::times() const {
  return times_;
}
inline void MatchSignInfo::set_times(::google::protobuf::int32 value) {
  set_has_times();
  times_ = value;
}

// required string from = 15;
inline bool MatchSignInfo::has_from() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MatchSignInfo::set_has_from() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MatchSignInfo::clear_has_from() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MatchSignInfo::clear_from() {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    from_->clear();
  }
  clear_has_from();
}
inline const ::std::string& MatchSignInfo::from() const {
  return *from_;
}
inline void MatchSignInfo::set_from(const ::std::string& value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void MatchSignInfo::set_from(const char* value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void MatchSignInfo::set_from(const char* value, size_t size) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MatchSignInfo::mutable_from() {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  return from_;
}
inline ::std::string* MatchSignInfo::release_from() {
  clear_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_;
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MatchSignInfo::set_allocated_from(::std::string* from) {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    delete from_;
  }
  if (from) {
    set_has_from();
    from_ = from;
  } else {
    clear_has_from();
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string to = 16;
inline bool MatchSignInfo::has_to() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MatchSignInfo::set_has_to() {
  _has_bits_[0] |= 0x00008000u;
}
inline void MatchSignInfo::clear_has_to() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void MatchSignInfo::clear_to() {
  if (to_ != &::google::protobuf::internal::kEmptyString) {
    to_->clear();
  }
  clear_has_to();
}
inline const ::std::string& MatchSignInfo::to() const {
  return *to_;
}
inline void MatchSignInfo::set_to(const ::std::string& value) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  to_->assign(value);
}
inline void MatchSignInfo::set_to(const char* value) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  to_->assign(value);
}
inline void MatchSignInfo::set_to(const char* value, size_t size) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  to_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MatchSignInfo::mutable_to() {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  return to_;
}
inline ::std::string* MatchSignInfo::release_to() {
  clear_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = to_;
    to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MatchSignInfo::set_allocated_to(::std::string* to) {
  if (to_ != &::google::protobuf::internal::kEmptyString) {
    delete to_;
  }
  if (to) {
    set_has_to();
    to_ = to;
  } else {
    clear_has_to();
    to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 isStar = 17;
inline bool MatchSignInfo::has_isstar() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void MatchSignInfo::set_has_isstar() {
  _has_bits_[0] |= 0x00010000u;
}
inline void MatchSignInfo::clear_has_isstar() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void MatchSignInfo::clear_isstar() {
  isstar_ = 0;
  clear_has_isstar();
}
inline ::google::protobuf::int32 MatchSignInfo::isstar() const {
  return isstar_;
}
inline void MatchSignInfo::set_isstar(::google::protobuf::int32 value) {
  set_has_isstar();
  isstar_ = value;
}

// -------------------------------------------------------------------

// ReqGetMatchList

// required int32 gameId = 1;
inline bool ReqGetMatchList::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqGetMatchList::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqGetMatchList::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqGetMatchList::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 ReqGetMatchList::gameid() const {
  return gameid_;
}
inline void ReqGetMatchList::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// -------------------------------------------------------------------

// ResGetMatchList

// required .ProtoNet.ResponseResult result = 1;
inline bool ResGetMatchList::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResGetMatchList::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResGetMatchList::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResGetMatchList::clear_result() {
  if (result_ != NULL) result_->::ProtoNet::ResponseResult::Clear();
  clear_has_result();
}
inline const ::ProtoNet::ResponseResult& ResGetMatchList::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::ProtoNet::ResponseResult* ResGetMatchList::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::ProtoNet::ResponseResult;
  return result_;
}
inline ::ProtoNet::ResponseResult* ResGetMatchList::release_result() {
  clear_has_result();
  ::ProtoNet::ResponseResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline void ResGetMatchList::set_allocated_result(::ProtoNet::ResponseResult* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// repeated .ProtoNet.MatchSignInfo matchSignInfos = 2;
inline int ResGetMatchList::matchsigninfos_size() const {
  return matchsigninfos_.size();
}
inline void ResGetMatchList::clear_matchsigninfos() {
  matchsigninfos_.Clear();
}
inline const ::ProtoNet::MatchSignInfo& ResGetMatchList::matchsigninfos(int index) const {
  return matchsigninfos_.Get(index);
}
inline ::ProtoNet::MatchSignInfo* ResGetMatchList::mutable_matchsigninfos(int index) {
  return matchsigninfos_.Mutable(index);
}
inline ::ProtoNet::MatchSignInfo* ResGetMatchList::add_matchsigninfos() {
  return matchsigninfos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::MatchSignInfo >&
ResGetMatchList::matchsigninfos() const {
  return matchsigninfos_;
}
inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::MatchSignInfo >*
ResGetMatchList::mutable_matchsigninfos() {
  return &matchsigninfos_;
}

// -------------------------------------------------------------------

// ReqSignUpMatch

// required int32 matchId = 1;
inline bool ReqSignUpMatch::has_matchid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqSignUpMatch::set_has_matchid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqSignUpMatch::clear_has_matchid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqSignUpMatch::clear_matchid() {
  matchid_ = 0;
  clear_has_matchid();
}
inline ::google::protobuf::int32 ReqSignUpMatch::matchid() const {
  return matchid_;
}
inline void ReqSignUpMatch::set_matchid(::google::protobuf::int32 value) {
  set_has_matchid();
  matchid_ = value;
}

// required string randId = 2;
inline bool ReqSignUpMatch::has_randid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqSignUpMatch::set_has_randid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqSignUpMatch::clear_has_randid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqSignUpMatch::clear_randid() {
  if (randid_ != &::google::protobuf::internal::kEmptyString) {
    randid_->clear();
  }
  clear_has_randid();
}
inline const ::std::string& ReqSignUpMatch::randid() const {
  return *randid_;
}
inline void ReqSignUpMatch::set_randid(const ::std::string& value) {
  set_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    randid_ = new ::std::string;
  }
  randid_->assign(value);
}
inline void ReqSignUpMatch::set_randid(const char* value) {
  set_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    randid_ = new ::std::string;
  }
  randid_->assign(value);
}
inline void ReqSignUpMatch::set_randid(const char* value, size_t size) {
  set_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    randid_ = new ::std::string;
  }
  randid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqSignUpMatch::mutable_randid() {
  set_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    randid_ = new ::std::string;
  }
  return randid_;
}
inline ::std::string* ReqSignUpMatch::release_randid() {
  clear_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = randid_;
    randid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqSignUpMatch::set_allocated_randid(::std::string* randid) {
  if (randid_ != &::google::protobuf::internal::kEmptyString) {
    delete randid_;
  }
  if (randid) {
    set_has_randid();
    randid_ = randid;
  } else {
    clear_has_randid();
    randid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ResSignUpMatch

// required .ProtoNet.ResponseResult result = 1;
inline bool ResSignUpMatch::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResSignUpMatch::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResSignUpMatch::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResSignUpMatch::clear_result() {
  if (result_ != NULL) result_->::ProtoNet::ResponseResult::Clear();
  clear_has_result();
}
inline const ::ProtoNet::ResponseResult& ResSignUpMatch::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::ProtoNet::ResponseResult* ResSignUpMatch::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::ProtoNet::ResponseResult;
  return result_;
}
inline ::ProtoNet::ResponseResult* ResSignUpMatch::release_result() {
  clear_has_result();
  ::ProtoNet::ResponseResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline void ResSignUpMatch::set_allocated_result(::ProtoNet::ResponseResult* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// optional int32 matchConfigId = 2;
inline bool ResSignUpMatch::has_matchconfigid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResSignUpMatch::set_has_matchconfigid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResSignUpMatch::clear_has_matchconfigid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResSignUpMatch::clear_matchconfigid() {
  matchconfigid_ = 0;
  clear_has_matchconfigid();
}
inline ::google::protobuf::int32 ResSignUpMatch::matchconfigid() const {
  return matchconfigid_;
}
inline void ResSignUpMatch::set_matchconfigid(::google::protobuf::int32 value) {
  set_has_matchconfigid();
  matchconfigid_ = value;
}

// optional string randId = 3;
inline bool ResSignUpMatch::has_randid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResSignUpMatch::set_has_randid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResSignUpMatch::clear_has_randid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResSignUpMatch::clear_randid() {
  if (randid_ != &::google::protobuf::internal::kEmptyString) {
    randid_->clear();
  }
  clear_has_randid();
}
inline const ::std::string& ResSignUpMatch::randid() const {
  return *randid_;
}
inline void ResSignUpMatch::set_randid(const ::std::string& value) {
  set_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    randid_ = new ::std::string;
  }
  randid_->assign(value);
}
inline void ResSignUpMatch::set_randid(const char* value) {
  set_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    randid_ = new ::std::string;
  }
  randid_->assign(value);
}
inline void ResSignUpMatch::set_randid(const char* value, size_t size) {
  set_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    randid_ = new ::std::string;
  }
  randid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResSignUpMatch::mutable_randid() {
  set_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    randid_ = new ::std::string;
  }
  return randid_;
}
inline ::std::string* ResSignUpMatch::release_randid() {
  clear_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = randid_;
    randid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResSignUpMatch::set_allocated_randid(::std::string* randid) {
  if (randid_ != &::google::protobuf::internal::kEmptyString) {
    delete randid_;
  }
  if (randid) {
    set_has_randid();
    randid_ = randid;
  } else {
    clear_has_randid();
    randid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ResNotifyEnterMatch

// required string roomId = 1;
inline bool ResNotifyEnterMatch::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResNotifyEnterMatch::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResNotifyEnterMatch::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResNotifyEnterMatch::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& ResNotifyEnterMatch::roomid() const {
  return *roomid_;
}
inline void ResNotifyEnterMatch::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ResNotifyEnterMatch::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ResNotifyEnterMatch::set_roomid(const char* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResNotifyEnterMatch::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  return roomid_;
}
inline ::std::string* ResNotifyEnterMatch::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResNotifyEnterMatch::set_allocated_roomid(::std::string* roomid) {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomid_;
  }
  if (roomid) {
    set_has_roomid();
    roomid_ = roomid;
  } else {
    clear_has_roomid();
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string roomName = 2;
inline bool ResNotifyEnterMatch::has_roomname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResNotifyEnterMatch::set_has_roomname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResNotifyEnterMatch::clear_has_roomname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResNotifyEnterMatch::clear_roomname() {
  if (roomname_ != &::google::protobuf::internal::kEmptyString) {
    roomname_->clear();
  }
  clear_has_roomname();
}
inline const ::std::string& ResNotifyEnterMatch::roomname() const {
  return *roomname_;
}
inline void ResNotifyEnterMatch::set_roomname(const ::std::string& value) {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    roomname_ = new ::std::string;
  }
  roomname_->assign(value);
}
inline void ResNotifyEnterMatch::set_roomname(const char* value) {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    roomname_ = new ::std::string;
  }
  roomname_->assign(value);
}
inline void ResNotifyEnterMatch::set_roomname(const char* value, size_t size) {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    roomname_ = new ::std::string;
  }
  roomname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResNotifyEnterMatch::mutable_roomname() {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    roomname_ = new ::std::string;
  }
  return roomname_;
}
inline ::std::string* ResNotifyEnterMatch::release_roomname() {
  clear_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomname_;
    roomname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResNotifyEnterMatch::set_allocated_roomname(::std::string* roomname) {
  if (roomname_ != &::google::protobuf::internal::kEmptyString) {
    delete roomname_;
  }
  if (roomname) {
    set_has_roomname();
    roomname_ = roomname;
  } else {
    clear_has_roomname();
    roomname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string roomerUniqueId = 3;
inline bool ResNotifyEnterMatch::has_roomeruniqueid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResNotifyEnterMatch::set_has_roomeruniqueid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResNotifyEnterMatch::clear_has_roomeruniqueid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResNotifyEnterMatch::clear_roomeruniqueid() {
  if (roomeruniqueid_ != &::google::protobuf::internal::kEmptyString) {
    roomeruniqueid_->clear();
  }
  clear_has_roomeruniqueid();
}
inline const ::std::string& ResNotifyEnterMatch::roomeruniqueid() const {
  return *roomeruniqueid_;
}
inline void ResNotifyEnterMatch::set_roomeruniqueid(const ::std::string& value) {
  set_has_roomeruniqueid();
  if (roomeruniqueid_ == &::google::protobuf::internal::kEmptyString) {
    roomeruniqueid_ = new ::std::string;
  }
  roomeruniqueid_->assign(value);
}
inline void ResNotifyEnterMatch::set_roomeruniqueid(const char* value) {
  set_has_roomeruniqueid();
  if (roomeruniqueid_ == &::google::protobuf::internal::kEmptyString) {
    roomeruniqueid_ = new ::std::string;
  }
  roomeruniqueid_->assign(value);
}
inline void ResNotifyEnterMatch::set_roomeruniqueid(const char* value, size_t size) {
  set_has_roomeruniqueid();
  if (roomeruniqueid_ == &::google::protobuf::internal::kEmptyString) {
    roomeruniqueid_ = new ::std::string;
  }
  roomeruniqueid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResNotifyEnterMatch::mutable_roomeruniqueid() {
  set_has_roomeruniqueid();
  if (roomeruniqueid_ == &::google::protobuf::internal::kEmptyString) {
    roomeruniqueid_ = new ::std::string;
  }
  return roomeruniqueid_;
}
inline ::std::string* ResNotifyEnterMatch::release_roomeruniqueid() {
  clear_has_roomeruniqueid();
  if (roomeruniqueid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomeruniqueid_;
    roomeruniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResNotifyEnterMatch::set_allocated_roomeruniqueid(::std::string* roomeruniqueid) {
  if (roomeruniqueid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomeruniqueid_;
  }
  if (roomeruniqueid) {
    set_has_roomeruniqueid();
    roomeruniqueid_ = roomeruniqueid;
  } else {
    clear_has_roomeruniqueid();
    roomeruniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string roomerNickName = 4;
inline bool ResNotifyEnterMatch::has_roomernickname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResNotifyEnterMatch::set_has_roomernickname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResNotifyEnterMatch::clear_has_roomernickname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResNotifyEnterMatch::clear_roomernickname() {
  if (roomernickname_ != &::google::protobuf::internal::kEmptyString) {
    roomernickname_->clear();
  }
  clear_has_roomernickname();
}
inline const ::std::string& ResNotifyEnterMatch::roomernickname() const {
  return *roomernickname_;
}
inline void ResNotifyEnterMatch::set_roomernickname(const ::std::string& value) {
  set_has_roomernickname();
  if (roomernickname_ == &::google::protobuf::internal::kEmptyString) {
    roomernickname_ = new ::std::string;
  }
  roomernickname_->assign(value);
}
inline void ResNotifyEnterMatch::set_roomernickname(const char* value) {
  set_has_roomernickname();
  if (roomernickname_ == &::google::protobuf::internal::kEmptyString) {
    roomernickname_ = new ::std::string;
  }
  roomernickname_->assign(value);
}
inline void ResNotifyEnterMatch::set_roomernickname(const char* value, size_t size) {
  set_has_roomernickname();
  if (roomernickname_ == &::google::protobuf::internal::kEmptyString) {
    roomernickname_ = new ::std::string;
  }
  roomernickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResNotifyEnterMatch::mutable_roomernickname() {
  set_has_roomernickname();
  if (roomernickname_ == &::google::protobuf::internal::kEmptyString) {
    roomernickname_ = new ::std::string;
  }
  return roomernickname_;
}
inline ::std::string* ResNotifyEnterMatch::release_roomernickname() {
  clear_has_roomernickname();
  if (roomernickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomernickname_;
    roomernickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResNotifyEnterMatch::set_allocated_roomernickname(::std::string* roomernickname) {
  if (roomernickname_ != &::google::protobuf::internal::kEmptyString) {
    delete roomernickname_;
  }
  if (roomernickname) {
    set_has_roomernickname();
    roomernickname_ = roomernickname;
  } else {
    clear_has_roomernickname();
    roomernickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string roomerHeadImg = 5;
inline bool ResNotifyEnterMatch::has_roomerheadimg() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResNotifyEnterMatch::set_has_roomerheadimg() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResNotifyEnterMatch::clear_has_roomerheadimg() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResNotifyEnterMatch::clear_roomerheadimg() {
  if (roomerheadimg_ != &::google::protobuf::internal::kEmptyString) {
    roomerheadimg_->clear();
  }
  clear_has_roomerheadimg();
}
inline const ::std::string& ResNotifyEnterMatch::roomerheadimg() const {
  return *roomerheadimg_;
}
inline void ResNotifyEnterMatch::set_roomerheadimg(const ::std::string& value) {
  set_has_roomerheadimg();
  if (roomerheadimg_ == &::google::protobuf::internal::kEmptyString) {
    roomerheadimg_ = new ::std::string;
  }
  roomerheadimg_->assign(value);
}
inline void ResNotifyEnterMatch::set_roomerheadimg(const char* value) {
  set_has_roomerheadimg();
  if (roomerheadimg_ == &::google::protobuf::internal::kEmptyString) {
    roomerheadimg_ = new ::std::string;
  }
  roomerheadimg_->assign(value);
}
inline void ResNotifyEnterMatch::set_roomerheadimg(const char* value, size_t size) {
  set_has_roomerheadimg();
  if (roomerheadimg_ == &::google::protobuf::internal::kEmptyString) {
    roomerheadimg_ = new ::std::string;
  }
  roomerheadimg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResNotifyEnterMatch::mutable_roomerheadimg() {
  set_has_roomerheadimg();
  if (roomerheadimg_ == &::google::protobuf::internal::kEmptyString) {
    roomerheadimg_ = new ::std::string;
  }
  return roomerheadimg_;
}
inline ::std::string* ResNotifyEnterMatch::release_roomerheadimg() {
  clear_has_roomerheadimg();
  if (roomerheadimg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomerheadimg_;
    roomerheadimg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResNotifyEnterMatch::set_allocated_roomerheadimg(::std::string* roomerheadimg) {
  if (roomerheadimg_ != &::google::protobuf::internal::kEmptyString) {
    delete roomerheadimg_;
  }
  if (roomerheadimg) {
    set_has_roomerheadimg();
    roomerheadimg_ = roomerheadimg;
  } else {
    clear_has_roomerheadimg();
    roomerheadimg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 roomerHeadType = 6;
inline bool ResNotifyEnterMatch::has_roomerheadtype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResNotifyEnterMatch::set_has_roomerheadtype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResNotifyEnterMatch::clear_has_roomerheadtype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResNotifyEnterMatch::clear_roomerheadtype() {
  roomerheadtype_ = 0;
  clear_has_roomerheadtype();
}
inline ::google::protobuf::int32 ResNotifyEnterMatch::roomerheadtype() const {
  return roomerheadtype_;
}
inline void ResNotifyEnterMatch::set_roomerheadtype(::google::protobuf::int32 value) {
  set_has_roomerheadtype();
  roomerheadtype_ = value;
}

// required int32 roomType = 7;
inline bool ResNotifyEnterMatch::has_roomtype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ResNotifyEnterMatch::set_has_roomtype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ResNotifyEnterMatch::clear_has_roomtype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ResNotifyEnterMatch::clear_roomtype() {
  roomtype_ = 0;
  clear_has_roomtype();
}
inline ::google::protobuf::int32 ResNotifyEnterMatch::roomtype() const {
  return roomtype_;
}
inline void ResNotifyEnterMatch::set_roomtype(::google::protobuf::int32 value) {
  set_has_roomtype();
  roomtype_ = value;
}

// required .ProtoNet.ServerInfoIpsSafeDetail serverInfo = 8;
inline bool ResNotifyEnterMatch::has_serverinfo() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ResNotifyEnterMatch::set_has_serverinfo() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ResNotifyEnterMatch::clear_has_serverinfo() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ResNotifyEnterMatch::clear_serverinfo() {
  if (serverinfo_ != NULL) serverinfo_->::ProtoNet::ServerInfoIpsSafeDetail::Clear();
  clear_has_serverinfo();
}
inline const ::ProtoNet::ServerInfoIpsSafeDetail& ResNotifyEnterMatch::serverinfo() const {
  return serverinfo_ != NULL ? *serverinfo_ : *default_instance_->serverinfo_;
}
inline ::ProtoNet::ServerInfoIpsSafeDetail* ResNotifyEnterMatch::mutable_serverinfo() {
  set_has_serverinfo();
  if (serverinfo_ == NULL) serverinfo_ = new ::ProtoNet::ServerInfoIpsSafeDetail;
  return serverinfo_;
}
inline ::ProtoNet::ServerInfoIpsSafeDetail* ResNotifyEnterMatch::release_serverinfo() {
  clear_has_serverinfo();
  ::ProtoNet::ServerInfoIpsSafeDetail* temp = serverinfo_;
  serverinfo_ = NULL;
  return temp;
}
inline void ResNotifyEnterMatch::set_allocated_serverinfo(::ProtoNet::ServerInfoIpsSafeDetail* serverinfo) {
  delete serverinfo_;
  serverinfo_ = serverinfo;
  if (serverinfo) {
    set_has_serverinfo();
  } else {
    clear_has_serverinfo();
  }
}

// required int32 times = 9;
inline bool ResNotifyEnterMatch::has_times() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ResNotifyEnterMatch::set_has_times() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ResNotifyEnterMatch::clear_has_times() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ResNotifyEnterMatch::clear_times() {
  times_ = 0;
  clear_has_times();
}
inline ::google::protobuf::int32 ResNotifyEnterMatch::times() const {
  return times_;
}
inline void ResNotifyEnterMatch::set_times(::google::protobuf::int32 value) {
  set_has_times();
  times_ = value;
}

// required int32 gameId = 10;
inline bool ResNotifyEnterMatch::has_gameid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ResNotifyEnterMatch::set_has_gameid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ResNotifyEnterMatch::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ResNotifyEnterMatch::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 ResNotifyEnterMatch::gameid() const {
  return gameid_;
}
inline void ResNotifyEnterMatch::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 timesType = 11;
inline bool ResNotifyEnterMatch::has_timestype() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ResNotifyEnterMatch::set_has_timestype() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ResNotifyEnterMatch::clear_has_timestype() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ResNotifyEnterMatch::clear_timestype() {
  timestype_ = 0;
  clear_has_timestype();
}
inline ::google::protobuf::int32 ResNotifyEnterMatch::timestype() const {
  return timestype_;
}
inline void ResNotifyEnterMatch::set_timestype(::google::protobuf::int32 value) {
  set_has_timestype();
  timestype_ = value;
}

// required string from = 12;
inline bool ResNotifyEnterMatch::has_from() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ResNotifyEnterMatch::set_has_from() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ResNotifyEnterMatch::clear_has_from() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ResNotifyEnterMatch::clear_from() {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    from_->clear();
  }
  clear_has_from();
}
inline const ::std::string& ResNotifyEnterMatch::from() const {
  return *from_;
}
inline void ResNotifyEnterMatch::set_from(const ::std::string& value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void ResNotifyEnterMatch::set_from(const char* value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void ResNotifyEnterMatch::set_from(const char* value, size_t size) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResNotifyEnterMatch::mutable_from() {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  return from_;
}
inline ::std::string* ResNotifyEnterMatch::release_from() {
  clear_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_;
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResNotifyEnterMatch::set_allocated_from(::std::string* from) {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    delete from_;
  }
  if (from) {
    set_has_from();
    from_ = from;
  } else {
    clear_has_from();
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string to = 13;
inline bool ResNotifyEnterMatch::has_to() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ResNotifyEnterMatch::set_has_to() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ResNotifyEnterMatch::clear_has_to() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ResNotifyEnterMatch::clear_to() {
  if (to_ != &::google::protobuf::internal::kEmptyString) {
    to_->clear();
  }
  clear_has_to();
}
inline const ::std::string& ResNotifyEnterMatch::to() const {
  return *to_;
}
inline void ResNotifyEnterMatch::set_to(const ::std::string& value) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  to_->assign(value);
}
inline void ResNotifyEnterMatch::set_to(const char* value) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  to_->assign(value);
}
inline void ResNotifyEnterMatch::set_to(const char* value, size_t size) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  to_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResNotifyEnterMatch::mutable_to() {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  return to_;
}
inline ::std::string* ResNotifyEnterMatch::release_to() {
  clear_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = to_;
    to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResNotifyEnterMatch::set_allocated_to(::std::string* to) {
  if (to_ != &::google::protobuf::internal::kEmptyString) {
    delete to_;
  }
  if (to) {
    set_has_to();
    to_ = to;
  } else {
    clear_has_to();
    to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ReqCanleSignMatch

// required int32 matchId = 1;
inline bool ReqCanleSignMatch::has_matchid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqCanleSignMatch::set_has_matchid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqCanleSignMatch::clear_has_matchid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqCanleSignMatch::clear_matchid() {
  matchid_ = 0;
  clear_has_matchid();
}
inline ::google::protobuf::int32 ReqCanleSignMatch::matchid() const {
  return matchid_;
}
inline void ReqCanleSignMatch::set_matchid(::google::protobuf::int32 value) {
  set_has_matchid();
  matchid_ = value;
}

// required string randId = 2;
inline bool ReqCanleSignMatch::has_randid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqCanleSignMatch::set_has_randid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqCanleSignMatch::clear_has_randid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqCanleSignMatch::clear_randid() {
  if (randid_ != &::google::protobuf::internal::kEmptyString) {
    randid_->clear();
  }
  clear_has_randid();
}
inline const ::std::string& ReqCanleSignMatch::randid() const {
  return *randid_;
}
inline void ReqCanleSignMatch::set_randid(const ::std::string& value) {
  set_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    randid_ = new ::std::string;
  }
  randid_->assign(value);
}
inline void ReqCanleSignMatch::set_randid(const char* value) {
  set_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    randid_ = new ::std::string;
  }
  randid_->assign(value);
}
inline void ReqCanleSignMatch::set_randid(const char* value, size_t size) {
  set_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    randid_ = new ::std::string;
  }
  randid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqCanleSignMatch::mutable_randid() {
  set_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    randid_ = new ::std::string;
  }
  return randid_;
}
inline ::std::string* ReqCanleSignMatch::release_randid() {
  clear_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = randid_;
    randid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqCanleSignMatch::set_allocated_randid(::std::string* randid) {
  if (randid_ != &::google::protobuf::internal::kEmptyString) {
    delete randid_;
  }
  if (randid) {
    set_has_randid();
    randid_ = randid;
  } else {
    clear_has_randid();
    randid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ResCanleSignMatch

// required .ProtoNet.ResponseResult result = 1;
inline bool ResCanleSignMatch::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResCanleSignMatch::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResCanleSignMatch::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResCanleSignMatch::clear_result() {
  if (result_ != NULL) result_->::ProtoNet::ResponseResult::Clear();
  clear_has_result();
}
inline const ::ProtoNet::ResponseResult& ResCanleSignMatch::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::ProtoNet::ResponseResult* ResCanleSignMatch::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::ProtoNet::ResponseResult;
  return result_;
}
inline ::ProtoNet::ResponseResult* ResCanleSignMatch::release_result() {
  clear_has_result();
  ::ProtoNet::ResponseResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline void ResCanleSignMatch::set_allocated_result(::ProtoNet::ResponseResult* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// optional int32 matchConfigId = 2;
inline bool ResCanleSignMatch::has_matchconfigid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResCanleSignMatch::set_has_matchconfigid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResCanleSignMatch::clear_has_matchconfigid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResCanleSignMatch::clear_matchconfigid() {
  matchconfigid_ = 0;
  clear_has_matchconfigid();
}
inline ::google::protobuf::int32 ResCanleSignMatch::matchconfigid() const {
  return matchconfigid_;
}
inline void ResCanleSignMatch::set_matchconfigid(::google::protobuf::int32 value) {
  set_has_matchconfigid();
  matchconfigid_ = value;
}

// optional string randId = 3;
inline bool ResCanleSignMatch::has_randid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResCanleSignMatch::set_has_randid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResCanleSignMatch::clear_has_randid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResCanleSignMatch::clear_randid() {
  if (randid_ != &::google::protobuf::internal::kEmptyString) {
    randid_->clear();
  }
  clear_has_randid();
}
inline const ::std::string& ResCanleSignMatch::randid() const {
  return *randid_;
}
inline void ResCanleSignMatch::set_randid(const ::std::string& value) {
  set_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    randid_ = new ::std::string;
  }
  randid_->assign(value);
}
inline void ResCanleSignMatch::set_randid(const char* value) {
  set_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    randid_ = new ::std::string;
  }
  randid_->assign(value);
}
inline void ResCanleSignMatch::set_randid(const char* value, size_t size) {
  set_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    randid_ = new ::std::string;
  }
  randid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResCanleSignMatch::mutable_randid() {
  set_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    randid_ = new ::std::string;
  }
  return randid_;
}
inline ::std::string* ResCanleSignMatch::release_randid() {
  clear_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = randid_;
    randid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResCanleSignMatch::set_allocated_randid(::std::string* randid) {
  if (randid_ != &::google::protobuf::internal::kEmptyString) {
    delete randid_;
  }
  if (randid) {
    set_has_randid();
    randid_ = randid;
  } else {
    clear_has_randid();
    randid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ResNotifyMatchRoomWattingChange

// required string roomId = 1;
inline bool ResNotifyMatchRoomWattingChange::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResNotifyMatchRoomWattingChange::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResNotifyMatchRoomWattingChange::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResNotifyMatchRoomWattingChange::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& ResNotifyMatchRoomWattingChange::roomid() const {
  return *roomid_;
}
inline void ResNotifyMatchRoomWattingChange::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ResNotifyMatchRoomWattingChange::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ResNotifyMatchRoomWattingChange::set_roomid(const char* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResNotifyMatchRoomWattingChange::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  return roomid_;
}
inline ::std::string* ResNotifyMatchRoomWattingChange::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResNotifyMatchRoomWattingChange::set_allocated_roomid(::std::string* roomid) {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomid_;
  }
  if (roomid) {
    set_has_roomid();
    roomid_ = roomid;
  } else {
    clear_has_roomid();
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 gameId = 2;
inline bool ResNotifyMatchRoomWattingChange::has_gameid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResNotifyMatchRoomWattingChange::set_has_gameid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResNotifyMatchRoomWattingChange::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResNotifyMatchRoomWattingChange::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 ResNotifyMatchRoomWattingChange::gameid() const {
  return gameid_;
}
inline void ResNotifyMatchRoomWattingChange::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required int32 roomType = 3;
inline bool ResNotifyMatchRoomWattingChange::has_roomtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResNotifyMatchRoomWattingChange::set_has_roomtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResNotifyMatchRoomWattingChange::clear_has_roomtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResNotifyMatchRoomWattingChange::clear_roomtype() {
  roomtype_ = 0;
  clear_has_roomtype();
}
inline ::google::protobuf::int32 ResNotifyMatchRoomWattingChange::roomtype() const {
  return roomtype_;
}
inline void ResNotifyMatchRoomWattingChange::set_roomtype(::google::protobuf::int32 value) {
  set_has_roomtype();
  roomtype_ = value;
}

// required int32 timesType = 4;
inline bool ResNotifyMatchRoomWattingChange::has_timestype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResNotifyMatchRoomWattingChange::set_has_timestype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResNotifyMatchRoomWattingChange::clear_has_timestype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResNotifyMatchRoomWattingChange::clear_timestype() {
  timestype_ = 0;
  clear_has_timestype();
}
inline ::google::protobuf::int32 ResNotifyMatchRoomWattingChange::timestype() const {
  return timestype_;
}
inline void ResNotifyMatchRoomWattingChange::set_timestype(::google::protobuf::int32 value) {
  set_has_timestype();
  timestype_ = value;
}

// required int32 waitting = 5;
inline bool ResNotifyMatchRoomWattingChange::has_waitting() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResNotifyMatchRoomWattingChange::set_has_waitting() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResNotifyMatchRoomWattingChange::clear_has_waitting() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResNotifyMatchRoomWattingChange::clear_waitting() {
  waitting_ = 0;
  clear_has_waitting();
}
inline ::google::protobuf::int32 ResNotifyMatchRoomWattingChange::waitting() const {
  return waitting_;
}
inline void ResNotifyMatchRoomWattingChange::set_waitting(::google::protobuf::int32 value) {
  set_has_waitting();
  waitting_ = value;
}

// required string randId = 6;
inline bool ResNotifyMatchRoomWattingChange::has_randid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResNotifyMatchRoomWattingChange::set_has_randid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResNotifyMatchRoomWattingChange::clear_has_randid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResNotifyMatchRoomWattingChange::clear_randid() {
  if (randid_ != &::google::protobuf::internal::kEmptyString) {
    randid_->clear();
  }
  clear_has_randid();
}
inline const ::std::string& ResNotifyMatchRoomWattingChange::randid() const {
  return *randid_;
}
inline void ResNotifyMatchRoomWattingChange::set_randid(const ::std::string& value) {
  set_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    randid_ = new ::std::string;
  }
  randid_->assign(value);
}
inline void ResNotifyMatchRoomWattingChange::set_randid(const char* value) {
  set_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    randid_ = new ::std::string;
  }
  randid_->assign(value);
}
inline void ResNotifyMatchRoomWattingChange::set_randid(const char* value, size_t size) {
  set_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    randid_ = new ::std::string;
  }
  randid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResNotifyMatchRoomWattingChange::mutable_randid() {
  set_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    randid_ = new ::std::string;
  }
  return randid_;
}
inline ::std::string* ResNotifyMatchRoomWattingChange::release_randid() {
  clear_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = randid_;
    randid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResNotifyMatchRoomWattingChange::set_allocated_randid(::std::string* randid) {
  if (randid_ != &::google::protobuf::internal::kEmptyString) {
    delete randid_;
  }
  if (randid) {
    set_has_randid();
    randid_ = randid;
  } else {
    clear_has_randid();
    randid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 times = 7;
inline bool ResNotifyMatchRoomWattingChange::has_times() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ResNotifyMatchRoomWattingChange::set_has_times() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ResNotifyMatchRoomWattingChange::clear_has_times() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ResNotifyMatchRoomWattingChange::clear_times() {
  times_ = 0;
  clear_has_times();
}
inline ::google::protobuf::int32 ResNotifyMatchRoomWattingChange::times() const {
  return times_;
}
inline void ResNotifyMatchRoomWattingChange::set_times(::google::protobuf::int32 value) {
  set_has_times();
  times_ = value;
}

// required string from = 8;
inline bool ResNotifyMatchRoomWattingChange::has_from() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ResNotifyMatchRoomWattingChange::set_has_from() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ResNotifyMatchRoomWattingChange::clear_has_from() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ResNotifyMatchRoomWattingChange::clear_from() {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    from_->clear();
  }
  clear_has_from();
}
inline const ::std::string& ResNotifyMatchRoomWattingChange::from() const {
  return *from_;
}
inline void ResNotifyMatchRoomWattingChange::set_from(const ::std::string& value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void ResNotifyMatchRoomWattingChange::set_from(const char* value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void ResNotifyMatchRoomWattingChange::set_from(const char* value, size_t size) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResNotifyMatchRoomWattingChange::mutable_from() {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  return from_;
}
inline ::std::string* ResNotifyMatchRoomWattingChange::release_from() {
  clear_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_;
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResNotifyMatchRoomWattingChange::set_allocated_from(::std::string* from) {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    delete from_;
  }
  if (from) {
    set_has_from();
    from_ = from;
  } else {
    clear_has_from();
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string to = 9;
inline bool ResNotifyMatchRoomWattingChange::has_to() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ResNotifyMatchRoomWattingChange::set_has_to() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ResNotifyMatchRoomWattingChange::clear_has_to() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ResNotifyMatchRoomWattingChange::clear_to() {
  if (to_ != &::google::protobuf::internal::kEmptyString) {
    to_->clear();
  }
  clear_has_to();
}
inline const ::std::string& ResNotifyMatchRoomWattingChange::to() const {
  return *to_;
}
inline void ResNotifyMatchRoomWattingChange::set_to(const ::std::string& value) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  to_->assign(value);
}
inline void ResNotifyMatchRoomWattingChange::set_to(const char* value) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  to_->assign(value);
}
inline void ResNotifyMatchRoomWattingChange::set_to(const char* value, size_t size) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  to_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResNotifyMatchRoomWattingChange::mutable_to() {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  return to_;
}
inline ::std::string* ResNotifyMatchRoomWattingChange::release_to() {
  clear_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = to_;
    to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResNotifyMatchRoomWattingChange::set_allocated_to(::std::string* to) {
  if (to_ != &::google::protobuf::internal::kEmptyString) {
    delete to_;
  }
  if (to) {
    set_has_to();
    to_ = to;
  } else {
    clear_has_to();
    to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ResNotifyTimesOver

// required int32 matchConfigId = 1;
inline bool ResNotifyTimesOver::has_matchconfigid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResNotifyTimesOver::set_has_matchconfigid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResNotifyTimesOver::clear_has_matchconfigid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResNotifyTimesOver::clear_matchconfigid() {
  matchconfigid_ = 0;
  clear_has_matchconfigid();
}
inline ::google::protobuf::int32 ResNotifyTimesOver::matchconfigid() const {
  return matchconfigid_;
}
inline void ResNotifyTimesOver::set_matchconfigid(::google::protobuf::int32 value) {
  set_has_matchconfigid();
  matchconfigid_ = value;
}

// required int32 gameId = 2;
inline bool ResNotifyTimesOver::has_gameid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResNotifyTimesOver::set_has_gameid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResNotifyTimesOver::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResNotifyTimesOver::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 ResNotifyTimesOver::gameid() const {
  return gameid_;
}
inline void ResNotifyTimesOver::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required string randId = 3;
inline bool ResNotifyTimesOver::has_randid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResNotifyTimesOver::set_has_randid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResNotifyTimesOver::clear_has_randid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResNotifyTimesOver::clear_randid() {
  if (randid_ != &::google::protobuf::internal::kEmptyString) {
    randid_->clear();
  }
  clear_has_randid();
}
inline const ::std::string& ResNotifyTimesOver::randid() const {
  return *randid_;
}
inline void ResNotifyTimesOver::set_randid(const ::std::string& value) {
  set_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    randid_ = new ::std::string;
  }
  randid_->assign(value);
}
inline void ResNotifyTimesOver::set_randid(const char* value) {
  set_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    randid_ = new ::std::string;
  }
  randid_->assign(value);
}
inline void ResNotifyTimesOver::set_randid(const char* value, size_t size) {
  set_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    randid_ = new ::std::string;
  }
  randid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResNotifyTimesOver::mutable_randid() {
  set_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    randid_ = new ::std::string;
  }
  return randid_;
}
inline ::std::string* ResNotifyTimesOver::release_randid() {
  clear_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = randid_;
    randid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResNotifyTimesOver::set_allocated_randid(::std::string* randid) {
  if (randid_ != &::google::protobuf::internal::kEmptyString) {
    delete randid_;
  }
  if (randid) {
    set_has_randid();
    randid_ = randid;
  } else {
    clear_has_randid();
    randid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 times = 4;
inline bool ResNotifyTimesOver::has_times() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResNotifyTimesOver::set_has_times() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResNotifyTimesOver::clear_has_times() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResNotifyTimesOver::clear_times() {
  times_ = 0;
  clear_has_times();
}
inline ::google::protobuf::int32 ResNotifyTimesOver::times() const {
  return times_;
}
inline void ResNotifyTimesOver::set_times(::google::protobuf::int32 value) {
  set_has_times();
  times_ = value;
}

// required string from = 5;
inline bool ResNotifyTimesOver::has_from() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResNotifyTimesOver::set_has_from() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResNotifyTimesOver::clear_has_from() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResNotifyTimesOver::clear_from() {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    from_->clear();
  }
  clear_has_from();
}
inline const ::std::string& ResNotifyTimesOver::from() const {
  return *from_;
}
inline void ResNotifyTimesOver::set_from(const ::std::string& value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void ResNotifyTimesOver::set_from(const char* value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void ResNotifyTimesOver::set_from(const char* value, size_t size) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResNotifyTimesOver::mutable_from() {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  return from_;
}
inline ::std::string* ResNotifyTimesOver::release_from() {
  clear_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_;
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResNotifyTimesOver::set_allocated_from(::std::string* from) {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    delete from_;
  }
  if (from) {
    set_has_from();
    from_ = from;
  } else {
    clear_has_from();
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string to = 6;
inline bool ResNotifyTimesOver::has_to() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ResNotifyTimesOver::set_has_to() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ResNotifyTimesOver::clear_has_to() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ResNotifyTimesOver::clear_to() {
  if (to_ != &::google::protobuf::internal::kEmptyString) {
    to_->clear();
  }
  clear_has_to();
}
inline const ::std::string& ResNotifyTimesOver::to() const {
  return *to_;
}
inline void ResNotifyTimesOver::set_to(const ::std::string& value) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  to_->assign(value);
}
inline void ResNotifyTimesOver::set_to(const char* value) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  to_->assign(value);
}
inline void ResNotifyTimesOver::set_to(const char* value, size_t size) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  to_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResNotifyTimesOver::mutable_to() {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  return to_;
}
inline ::std::string* ResNotifyTimesOver::release_to() {
  clear_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = to_;
    to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResNotifyTimesOver::set_allocated_to(::std::string* to) {
  if (to_ != &::google::protobuf::internal::kEmptyString) {
    delete to_;
  }
  if (to) {
    set_has_to();
    to_ = to;
  } else {
    clear_has_to();
    to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 selfRank = 7;
inline bool ResNotifyTimesOver::has_selfrank() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ResNotifyTimesOver::set_has_selfrank() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ResNotifyTimesOver::clear_has_selfrank() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ResNotifyTimesOver::clear_selfrank() {
  selfrank_ = 0;
  clear_has_selfrank();
}
inline ::google::protobuf::int32 ResNotifyTimesOver::selfrank() const {
  return selfrank_;
}
inline void ResNotifyTimesOver::set_selfrank(::google::protobuf::int32 value) {
  set_has_selfrank();
  selfrank_ = value;
}

// required int32 taotai = 8;
inline bool ResNotifyTimesOver::has_taotai() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ResNotifyTimesOver::set_has_taotai() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ResNotifyTimesOver::clear_has_taotai() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ResNotifyTimesOver::clear_taotai() {
  taotai_ = 0;
  clear_has_taotai();
}
inline ::google::protobuf::int32 ResNotifyTimesOver::taotai() const {
  return taotai_;
}
inline void ResNotifyTimesOver::set_taotai(::google::protobuf::int32 value) {
  set_has_taotai();
  taotai_ = value;
}

// required int32 matchOver = 9;
inline bool ResNotifyTimesOver::has_matchover() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ResNotifyTimesOver::set_has_matchover() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ResNotifyTimesOver::clear_has_matchover() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ResNotifyTimesOver::clear_matchover() {
  matchover_ = 0;
  clear_has_matchover();
}
inline ::google::protobuf::int32 ResNotifyTimesOver::matchover() const {
  return matchover_;
}
inline void ResNotifyTimesOver::set_matchover(::google::protobuf::int32 value) {
  set_has_matchover();
  matchover_ = value;
}

// -------------------------------------------------------------------

// ReqContinueMatch

// required int32 matchConfigId = 1;
inline bool ReqContinueMatch::has_matchconfigid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqContinueMatch::set_has_matchconfigid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqContinueMatch::clear_has_matchconfigid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqContinueMatch::clear_matchconfigid() {
  matchconfigid_ = 0;
  clear_has_matchconfigid();
}
inline ::google::protobuf::int32 ReqContinueMatch::matchconfigid() const {
  return matchconfigid_;
}
inline void ReqContinueMatch::set_matchconfigid(::google::protobuf::int32 value) {
  set_has_matchconfigid();
  matchconfigid_ = value;
}

// required int32 gameId = 2;
inline bool ReqContinueMatch::has_gameid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqContinueMatch::set_has_gameid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqContinueMatch::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqContinueMatch::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 ReqContinueMatch::gameid() const {
  return gameid_;
}
inline void ReqContinueMatch::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// required string randId = 3;
inline bool ReqContinueMatch::has_randid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqContinueMatch::set_has_randid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqContinueMatch::clear_has_randid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqContinueMatch::clear_randid() {
  if (randid_ != &::google::protobuf::internal::kEmptyString) {
    randid_->clear();
  }
  clear_has_randid();
}
inline const ::std::string& ReqContinueMatch::randid() const {
  return *randid_;
}
inline void ReqContinueMatch::set_randid(const ::std::string& value) {
  set_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    randid_ = new ::std::string;
  }
  randid_->assign(value);
}
inline void ReqContinueMatch::set_randid(const char* value) {
  set_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    randid_ = new ::std::string;
  }
  randid_->assign(value);
}
inline void ReqContinueMatch::set_randid(const char* value, size_t size) {
  set_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    randid_ = new ::std::string;
  }
  randid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqContinueMatch::mutable_randid() {
  set_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    randid_ = new ::std::string;
  }
  return randid_;
}
inline ::std::string* ReqContinueMatch::release_randid() {
  clear_has_randid();
  if (randid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = randid_;
    randid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqContinueMatch::set_allocated_randid(::std::string* randid) {
  if (randid_ != &::google::protobuf::internal::kEmptyString) {
    delete randid_;
  }
  if (randid) {
    set_has_randid();
    randid_ = randid;
  } else {
    clear_has_randid();
    randid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ResContinueMatch

// required .ProtoNet.ResponseResult result = 1;
inline bool ResContinueMatch::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResContinueMatch::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResContinueMatch::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResContinueMatch::clear_result() {
  if (result_ != NULL) result_->::ProtoNet::ResponseResult::Clear();
  clear_has_result();
}
inline const ::ProtoNet::ResponseResult& ResContinueMatch::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::ProtoNet::ResponseResult* ResContinueMatch::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::ProtoNet::ResponseResult;
  return result_;
}
inline ::ProtoNet::ResponseResult* ResContinueMatch::release_result() {
  clear_has_result();
  ::ProtoNet::ResponseResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline void ResContinueMatch::set_allocated_result(::ProtoNet::ResponseResult* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ProtoNet

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_MsgMatch_2eproto__INCLUDED
