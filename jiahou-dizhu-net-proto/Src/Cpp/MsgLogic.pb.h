// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MsgLogic.proto

#ifndef PROTOBUF_MsgLogic_2eproto__INCLUDED
#define PROTOBUF_MsgLogic_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "MsgCode.pb.h"
#include "MsgGate.pb.h"
// @@protoc_insertion_point(includes)

namespace ProtoNet {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_MsgLogic_2eproto();
void protobuf_AssignDesc_MsgLogic_2eproto();
void protobuf_ShutdownFile_MsgLogic_2eproto();

class SdkController;
class PosBrife;
class RoomInfo;
class DissolutionStatus;
class DissolutionStatusDetail;
class ReqLogicLogin;
class ResLogicLogin;
class ReqCreateGameRoom;
class ResCreateGameRoom;
class ResNotifyGameRoomCreate;
class ReqJoinGameRoom;
class ResJoinGameRoom;
class ResNotifySomeOneJoinGameRoom;
class ReqExitGameRoom;
class ResExitGameRoom;
class ResNotifySomeOneExitGameRoom;
class ReqGameReady;
class ResGameReady;
class ReqDissolutionGameRoom;
class ResDissolutionGameRoom;
class ResNotifySomeOneReqDissolutionGameRoom;
class ReqAgreeDissolutionGameRoom;
class ResAgreeDissolutionGameRoom;
class ResNotifySomeOneAggreeDissolutionGameRoom;
class ResNotifyGameRoomDissolution;
class ResNotifyGameOver;
class ReqGetRoomInfo;
class ResGetRoomInfo;
class ResNotifySomeOneGameReady;
class ReqChangeOnlineStatus;
class ResChangeOnlineStatus;
class ResNotifySomeOneChangeOnlineStatus;
class ResNotifyBigCalculatePanel;
class ReqCorrectTimer;
class ResCorrectTimer;
class ReqQuickChangeRoom;
class ResQuickChangeRoom;
class ResNotifySomeOneChangeRobot;
class ResNotifyChangeToOldRoom;
class ReqSitDown;
class ResSitDown;
class ResNotifySomeOneSitDown;
class ReqStandUp;
class ResStandUp;
class ResNotifySomeOneStandUp;
class ResNotifySomeOneEnterCharge;
class ResNotifyAccountsChange;
class ResNotifyChargeOver;
class ReqWatherList;
class ResWatherList;
class ReqOnceMore;
class ResOnceMore;
class ResNotifyOnceMore;
class reqLogicServerTime;
class resLogicServerTime;

// ===================================================================

class SdkController : public ::google::protobuf::Message {
 public:
  SdkController();
  virtual ~SdkController();

  SdkController(const SdkController& from);

  inline SdkController& operator=(const SdkController& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SdkController& default_instance();

  void Swap(SdkController* other);

  // implements Message ----------------------------------------------

  SdkController* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SdkController& from);
  void MergeFrom(const SdkController& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string uniqueId = 1;
  inline bool has_uniqueid() const;
  inline void clear_uniqueid();
  static const int kUniqueIdFieldNumber = 1;
  inline const ::std::string& uniqueid() const;
  inline void set_uniqueid(const ::std::string& value);
  inline void set_uniqueid(const char* value);
  inline void set_uniqueid(const char* value, size_t size);
  inline ::std::string* mutable_uniqueid();
  inline ::std::string* release_uniqueid();
  inline void set_allocated_uniqueid(::std::string* uniqueid);

  // required string nickName = 2;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNickNameFieldNumber = 2;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // required string headImg = 3;
  inline bool has_headimg() const;
  inline void clear_headimg();
  static const int kHeadImgFieldNumber = 3;
  inline const ::std::string& headimg() const;
  inline void set_headimg(const ::std::string& value);
  inline void set_headimg(const char* value);
  inline void set_headimg(const char* value, size_t size);
  inline ::std::string* mutable_headimg();
  inline ::std::string* release_headimg();
  inline void set_allocated_headimg(::std::string* headimg);

  // required string ip = 4;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 4;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // required int32 headType = 5;
  inline bool has_headtype() const;
  inline void clear_headtype();
  static const int kHeadTypeFieldNumber = 5;
  inline ::google::protobuf::int32 headtype() const;
  inline void set_headtype(::google::protobuf::int32 value);

  // required double health = 6;
  inline bool has_health() const;
  inline void clear_health();
  static const int kHealthFieldNumber = 6;
  inline double health() const;
  inline void set_health(double value);

  // required int32 sex = 7;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 7;
  inline ::google::protobuf::int32 sex() const;
  inline void set_sex(::google::protobuf::int32 value);

  // optional int32 selfRank = 8;
  inline bool has_selfrank() const;
  inline void clear_selfrank();
  static const int kSelfRankFieldNumber = 8;
  inline ::google::protobuf::int32 selfrank() const;
  inline void set_selfrank(::google::protobuf::int32 value);

  // optional int32 robot = 9;
  inline bool has_robot() const;
  inline void clear_robot();
  static const int kRobotFieldNumber = 9;
  inline ::google::protobuf::int32 robot() const;
  inline void set_robot(::google::protobuf::int32 value);

  // optional int32 watcher = 10;
  inline bool has_watcher() const;
  inline void clear_watcher();
  static const int kWatcherFieldNumber = 10;
  inline ::google::protobuf::int32 watcher() const;
  inline void set_watcher(::google::protobuf::int32 value);

  // optional int32 lv = 11;
  inline bool has_lv() const;
  inline void clear_lv();
  static const int kLvFieldNumber = 11;
  inline ::google::protobuf::int32 lv() const;
  inline void set_lv(::google::protobuf::int32 value);

  // optional string extendStr = 12;
  inline bool has_extendstr() const;
  inline void clear_extendstr();
  static const int kExtendStrFieldNumber = 12;
  inline const ::std::string& extendstr() const;
  inline void set_extendstr(const ::std::string& value);
  inline void set_extendstr(const char* value);
  inline void set_extendstr(const char* value, size_t size);
  inline ::std::string* mutable_extendstr();
  inline ::std::string* release_extendstr();
  inline void set_allocated_extendstr(::std::string* extendstr);

  // @@protoc_insertion_point(class_scope:ProtoNet.SdkController)
 private:
  inline void set_has_uniqueid();
  inline void clear_has_uniqueid();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_headimg();
  inline void clear_has_headimg();
  inline void set_has_ip();
  inline void clear_has_ip();
  inline void set_has_headtype();
  inline void clear_has_headtype();
  inline void set_has_health();
  inline void clear_has_health();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_selfrank();
  inline void clear_has_selfrank();
  inline void set_has_robot();
  inline void clear_has_robot();
  inline void set_has_watcher();
  inline void clear_has_watcher();
  inline void set_has_lv();
  inline void clear_has_lv();
  inline void set_has_extendstr();
  inline void clear_has_extendstr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uniqueid_;
  ::std::string* nickname_;
  ::std::string* headimg_;
  ::std::string* ip_;
  double health_;
  ::google::protobuf::int32 headtype_;
  ::google::protobuf::int32 sex_;
  ::google::protobuf::int32 selfrank_;
  ::google::protobuf::int32 robot_;
  ::google::protobuf::int32 watcher_;
  ::google::protobuf::int32 lv_;
  ::std::string* extendstr_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static SdkController* default_instance_;
};
// -------------------------------------------------------------------

class PosBrife : public ::google::protobuf::Message {
 public:
  PosBrife();
  virtual ~PosBrife();

  PosBrife(const PosBrife& from);

  inline PosBrife& operator=(const PosBrife& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PosBrife& default_instance();

  void Swap(PosBrife* other);

  // implements Message ----------------------------------------------

  PosBrife* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PosBrife& from);
  void MergeFrom(const PosBrife& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 pos = 1;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 1;
  inline ::google::protobuf::int32 pos() const;
  inline void set_pos(::google::protobuf::int32 value);

  // optional string controllerUniqueId = 2;
  inline bool has_controlleruniqueid() const;
  inline void clear_controlleruniqueid();
  static const int kControllerUniqueIdFieldNumber = 2;
  inline const ::std::string& controlleruniqueid() const;
  inline void set_controlleruniqueid(const ::std::string& value);
  inline void set_controlleruniqueid(const char* value);
  inline void set_controlleruniqueid(const char* value, size_t size);
  inline ::std::string* mutable_controlleruniqueid();
  inline ::std::string* release_controlleruniqueid();
  inline void set_allocated_controlleruniqueid(::std::string* controlleruniqueid);

  // optional int32 online = 3;
  inline bool has_online() const;
  inline void clear_online();
  static const int kOnlineFieldNumber = 3;
  inline ::google::protobuf::int32 online() const;
  inline void set_online(::google::protobuf::int32 value);

  // optional int32 ready = 4;
  inline bool has_ready() const;
  inline void clear_ready();
  static const int kReadyFieldNumber = 4;
  inline ::google::protobuf::int32 ready() const;
  inline void set_ready(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ProtoNet.PosBrife)
 private:
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_controlleruniqueid();
  inline void clear_has_controlleruniqueid();
  inline void set_has_online();
  inline void clear_has_online();
  inline void set_has_ready();
  inline void clear_has_ready();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* controlleruniqueid_;
  ::google::protobuf::int32 pos_;
  ::google::protobuf::int32 online_;
  ::google::protobuf::int32 ready_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static PosBrife* default_instance_;
};
// -------------------------------------------------------------------

class RoomInfo : public ::google::protobuf::Message {
 public:
  RoomInfo();
  virtual ~RoomInfo();

  RoomInfo(const RoomInfo& from);

  inline RoomInfo& operator=(const RoomInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomInfo& default_instance();

  void Swap(RoomInfo* other);

  // implements Message ----------------------------------------------

  RoomInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomInfo& from);
  void MergeFrom(const RoomInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string roomId = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 1;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const char* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  inline void set_allocated_roomid(::std::string* roomid);

  // required string roomName = 2;
  inline bool has_roomname() const;
  inline void clear_roomname();
  static const int kRoomNameFieldNumber = 2;
  inline const ::std::string& roomname() const;
  inline void set_roomname(const ::std::string& value);
  inline void set_roomname(const char* value);
  inline void set_roomname(const char* value, size_t size);
  inline ::std::string* mutable_roomname();
  inline ::std::string* release_roomname();
  inline void set_allocated_roomname(::std::string* roomname);

  // required string roomerUniqueId = 3;
  inline bool has_roomeruniqueid() const;
  inline void clear_roomeruniqueid();
  static const int kRoomerUniqueIdFieldNumber = 3;
  inline const ::std::string& roomeruniqueid() const;
  inline void set_roomeruniqueid(const ::std::string& value);
  inline void set_roomeruniqueid(const char* value);
  inline void set_roomeruniqueid(const char* value, size_t size);
  inline ::std::string* mutable_roomeruniqueid();
  inline ::std::string* release_roomeruniqueid();
  inline void set_allocated_roomeruniqueid(::std::string* roomeruniqueid);

  // repeated .ProtoNet.SdkController controllers = 4;
  inline int controllers_size() const;
  inline void clear_controllers();
  static const int kControllersFieldNumber = 4;
  inline const ::ProtoNet::SdkController& controllers(int index) const;
  inline ::ProtoNet::SdkController* mutable_controllers(int index);
  inline ::ProtoNet::SdkController* add_controllers();
  inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::SdkController >&
      controllers() const;
  inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::SdkController >*
      mutable_controllers();

  // optional string extendStr = 5;
  inline bool has_extendstr() const;
  inline void clear_extendstr();
  static const int kExtendStrFieldNumber = 5;
  inline const ::std::string& extendstr() const;
  inline void set_extendstr(const ::std::string& value);
  inline void set_extendstr(const char* value);
  inline void set_extendstr(const char* value, size_t size);
  inline ::std::string* mutable_extendstr();
  inline ::std::string* release_extendstr();
  inline void set_allocated_extendstr(::std::string* extendstr);

  // required int32 roomStatus = 6;
  inline bool has_roomstatus() const;
  inline void clear_roomstatus();
  static const int kRoomStatusFieldNumber = 6;
  inline ::google::protobuf::int32 roomstatus() const;
  inline void set_roomstatus(::google::protobuf::int32 value);

  // repeated .ProtoNet.PosBrife posBrifes = 7;
  inline int posbrifes_size() const;
  inline void clear_posbrifes();
  static const int kPosBrifesFieldNumber = 7;
  inline const ::ProtoNet::PosBrife& posbrifes(int index) const;
  inline ::ProtoNet::PosBrife* mutable_posbrifes(int index);
  inline ::ProtoNet::PosBrife* add_posbrifes();
  inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::PosBrife >&
      posbrifes() const;
  inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::PosBrife >*
      mutable_posbrifes();

  // required int32 leftMatchCount = 8;
  inline bool has_leftmatchcount() const;
  inline void clear_leftmatchcount();
  static const int kLeftMatchCountFieldNumber = 8;
  inline ::google::protobuf::int32 leftmatchcount() const;
  inline void set_leftmatchcount(::google::protobuf::int32 value);

  // required int32 totalCount = 9;
  inline bool has_totalcount() const;
  inline void clear_totalcount();
  static const int kTotalCountFieldNumber = 9;
  inline ::google::protobuf::int32 totalcount() const;
  inline void set_totalcount(::google::protobuf::int32 value);

  // required .ProtoNet.DissolutionStatus dissolutionStatus = 10;
  inline bool has_dissolutionstatus() const;
  inline void clear_dissolutionstatus();
  static const int kDissolutionStatusFieldNumber = 10;
  inline const ::ProtoNet::DissolutionStatus& dissolutionstatus() const;
  inline ::ProtoNet::DissolutionStatus* mutable_dissolutionstatus();
  inline ::ProtoNet::DissolutionStatus* release_dissolutionstatus();
  inline void set_allocated_dissolutionstatus(::ProtoNet::DissolutionStatus* dissolutionstatus);

  // required int32 maxPlayerNum = 11;
  inline bool has_maxplayernum() const;
  inline void clear_maxplayernum();
  static const int kMaxPlayerNumFieldNumber = 11;
  inline ::google::protobuf::int32 maxplayernum() const;
  inline void set_maxplayernum(::google::protobuf::int32 value);

  // required int32 currentPlayerNum = 12;
  inline bool has_currentplayernum() const;
  inline void clear_currentplayernum();
  static const int kCurrentPlayerNumFieldNumber = 12;
  inline ::google::protobuf::int32 currentplayernum() const;
  inline void set_currentplayernum(::google::protobuf::int32 value);

  // optional int64 readyTimer = 13;
  inline bool has_readytimer() const;
  inline void clear_readytimer();
  static const int kReadyTimerFieldNumber = 13;
  inline ::google::protobuf::int64 readytimer() const;
  inline void set_readytimer(::google::protobuf::int64 value);

  // optional int32 gameId = 14;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 14;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);

  // optional int32 roomType = 15;
  inline bool has_roomtype() const;
  inline void clear_roomtype();
  static const int kRoomTypeFieldNumber = 15;
  inline ::google::protobuf::int32 roomtype() const;
  inline void set_roomtype(::google::protobuf::int32 value);

  // optional int32 timesType = 16;
  inline bool has_timestype() const;
  inline void clear_timestype();
  static const int kTimesTypeFieldNumber = 16;
  inline ::google::protobuf::int32 timestype() const;
  inline void set_timestype(::google::protobuf::int32 value);

  // optional double yazhu = 17;
  inline bool has_yazhu() const;
  inline void clear_yazhu();
  static const int kYazhuFieldNumber = 17;
  inline double yazhu() const;
  inline void set_yazhu(double value);

  // optional int32 watting = 18;
  inline bool has_watting() const;
  inline void clear_watting();
  static const int kWattingFieldNumber = 18;
  inline ::google::protobuf::int32 watting() const;
  inline void set_watting(::google::protobuf::int32 value);

  // optional int32 from = 19;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 19;
  inline ::google::protobuf::int32 from() const;
  inline void set_from(::google::protobuf::int32 value);

  // optional int32 to = 20;
  inline bool has_to() const;
  inline void clear_to();
  static const int kToFieldNumber = 20;
  inline ::google::protobuf::int32 to() const;
  inline void set_to(::google::protobuf::int32 value);

  // optional string serverExtend = 21;
  inline bool has_serverextend() const;
  inline void clear_serverextend();
  static const int kServerExtendFieldNumber = 21;
  inline const ::std::string& serverextend() const;
  inline void set_serverextend(const ::std::string& value);
  inline void set_serverextend(const char* value);
  inline void set_serverextend(const char* value, size_t size);
  inline ::std::string* mutable_serverextend();
  inline ::std::string* release_serverextend();
  inline void set_allocated_serverextend(::std::string* serverextend);

  // optional int32 fangkaJinbi = 22;
  inline bool has_fangkajinbi() const;
  inline void clear_fangkajinbi();
  static const int kFangkaJinbiFieldNumber = 22;
  inline ::google::protobuf::int32 fangkajinbi() const;
  inline void set_fangkajinbi(::google::protobuf::int32 value);

  // optional string chargeList = 23;
  inline bool has_chargelist() const;
  inline void clear_chargelist();
  static const int kChargeListFieldNumber = 23;
  inline const ::std::string& chargelist() const;
  inline void set_chargelist(const ::std::string& value);
  inline void set_chargelist(const char* value);
  inline void set_chargelist(const char* value, size_t size);
  inline ::std::string* mutable_chargelist();
  inline ::std::string* release_chargelist();
  inline void set_allocated_chargelist(::std::string* chargelist);

  // optional string ext = 24;
  inline bool has_ext() const;
  inline void clear_ext();
  static const int kExtFieldNumber = 24;
  inline const ::std::string& ext() const;
  inline void set_ext(const ::std::string& value);
  inline void set_ext(const char* value);
  inline void set_ext(const char* value, size_t size);
  inline ::std::string* mutable_ext();
  inline ::std::string* release_ext();
  inline void set_allocated_ext(::std::string* ext);

  // optional string clubId = 25;
  inline bool has_clubid() const;
  inline void clear_clubid();
  static const int kClubIdFieldNumber = 25;
  inline const ::std::string& clubid() const;
  inline void set_clubid(const ::std::string& value);
  inline void set_clubid(const char* value);
  inline void set_clubid(const char* value, size_t size);
  inline ::std::string* mutable_clubid();
  inline ::std::string* release_clubid();
  inline void set_allocated_clubid(::std::string* clubid);

  // optional string tableNum = 26;
  inline bool has_tablenum() const;
  inline void clear_tablenum();
  static const int kTableNumFieldNumber = 26;
  inline const ::std::string& tablenum() const;
  inline void set_tablenum(const ::std::string& value);
  inline void set_tablenum(const char* value);
  inline void set_tablenum(const char* value, size_t size);
  inline ::std::string* mutable_tablenum();
  inline ::std::string* release_tablenum();
  inline void set_allocated_tablenum(::std::string* tablenum);

  // optional string clubGameTypeId = 27;
  inline bool has_clubgametypeid() const;
  inline void clear_clubgametypeid();
  static const int kClubGameTypeIdFieldNumber = 27;
  inline const ::std::string& clubgametypeid() const;
  inline void set_clubgametypeid(const ::std::string& value);
  inline void set_clubgametypeid(const char* value);
  inline void set_clubgametypeid(const char* value, size_t size);
  inline ::std::string* mutable_clubgametypeid();
  inline ::std::string* release_clubgametypeid();
  inline void set_allocated_clubgametypeid(::std::string* clubgametypeid);

  // @@protoc_insertion_point(class_scope:ProtoNet.RoomInfo)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_roomname();
  inline void clear_has_roomname();
  inline void set_has_roomeruniqueid();
  inline void clear_has_roomeruniqueid();
  inline void set_has_extendstr();
  inline void clear_has_extendstr();
  inline void set_has_roomstatus();
  inline void clear_has_roomstatus();
  inline void set_has_leftmatchcount();
  inline void clear_has_leftmatchcount();
  inline void set_has_totalcount();
  inline void clear_has_totalcount();
  inline void set_has_dissolutionstatus();
  inline void clear_has_dissolutionstatus();
  inline void set_has_maxplayernum();
  inline void clear_has_maxplayernum();
  inline void set_has_currentplayernum();
  inline void clear_has_currentplayernum();
  inline void set_has_readytimer();
  inline void clear_has_readytimer();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_roomtype();
  inline void clear_has_roomtype();
  inline void set_has_timestype();
  inline void clear_has_timestype();
  inline void set_has_yazhu();
  inline void clear_has_yazhu();
  inline void set_has_watting();
  inline void clear_has_watting();
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_to();
  inline void clear_has_to();
  inline void set_has_serverextend();
  inline void clear_has_serverextend();
  inline void set_has_fangkajinbi();
  inline void clear_has_fangkajinbi();
  inline void set_has_chargelist();
  inline void clear_has_chargelist();
  inline void set_has_ext();
  inline void clear_has_ext();
  inline void set_has_clubid();
  inline void clear_has_clubid();
  inline void set_has_tablenum();
  inline void clear_has_tablenum();
  inline void set_has_clubgametypeid();
  inline void clear_has_clubgametypeid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* roomid_;
  ::std::string* roomname_;
  ::std::string* roomeruniqueid_;
  ::google::protobuf::RepeatedPtrField< ::ProtoNet::SdkController > controllers_;
  ::std::string* extendstr_;
  ::google::protobuf::RepeatedPtrField< ::ProtoNet::PosBrife > posbrifes_;
  ::google::protobuf::int32 roomstatus_;
  ::google::protobuf::int32 leftmatchcount_;
  ::ProtoNet::DissolutionStatus* dissolutionstatus_;
  ::google::protobuf::int32 totalcount_;
  ::google::protobuf::int32 maxplayernum_;
  ::google::protobuf::int64 readytimer_;
  ::google::protobuf::int32 currentplayernum_;
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 roomtype_;
  ::google::protobuf::int32 timestype_;
  double yazhu_;
  ::google::protobuf::int32 watting_;
  ::google::protobuf::int32 from_;
  ::google::protobuf::int32 to_;
  ::google::protobuf::int32 fangkajinbi_;
  ::std::string* serverextend_;
  ::std::string* chargelist_;
  ::std::string* ext_;
  ::std::string* clubid_;
  ::std::string* tablenum_;
  ::std::string* clubgametypeid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(27 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static RoomInfo* default_instance_;
};
// -------------------------------------------------------------------

class DissolutionStatus : public ::google::protobuf::Message {
 public:
  DissolutionStatus();
  virtual ~DissolutionStatus();

  DissolutionStatus(const DissolutionStatus& from);

  inline DissolutionStatus& operator=(const DissolutionStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DissolutionStatus& default_instance();

  void Swap(DissolutionStatus* other);

  // implements Message ----------------------------------------------

  DissolutionStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DissolutionStatus& from);
  void MergeFrom(const DissolutionStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 dissolutionStatus = 1;
  inline bool has_dissolutionstatus() const;
  inline void clear_dissolutionstatus();
  static const int kDissolutionStatusFieldNumber = 1;
  inline ::google::protobuf::int32 dissolutionstatus() const;
  inline void set_dissolutionstatus(::google::protobuf::int32 value);

  // optional string reqUniqueId = 2;
  inline bool has_requniqueid() const;
  inline void clear_requniqueid();
  static const int kReqUniqueIdFieldNumber = 2;
  inline const ::std::string& requniqueid() const;
  inline void set_requniqueid(const ::std::string& value);
  inline void set_requniqueid(const char* value);
  inline void set_requniqueid(const char* value, size_t size);
  inline ::std::string* mutable_requniqueid();
  inline ::std::string* release_requniqueid();
  inline void set_allocated_requniqueid(::std::string* requniqueid);

  // repeated .ProtoNet.DissolutionStatusDetail details = 3;
  inline int details_size() const;
  inline void clear_details();
  static const int kDetailsFieldNumber = 3;
  inline const ::ProtoNet::DissolutionStatusDetail& details(int index) const;
  inline ::ProtoNet::DissolutionStatusDetail* mutable_details(int index);
  inline ::ProtoNet::DissolutionStatusDetail* add_details();
  inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::DissolutionStatusDetail >&
      details() const;
  inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::DissolutionStatusDetail >*
      mutable_details();

  // optional int64 leftTimer = 4;
  inline bool has_lefttimer() const;
  inline void clear_lefttimer();
  static const int kLeftTimerFieldNumber = 4;
  inline ::google::protobuf::int64 lefttimer() const;
  inline void set_lefttimer(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ProtoNet.DissolutionStatus)
 private:
  inline void set_has_dissolutionstatus();
  inline void clear_has_dissolutionstatus();
  inline void set_has_requniqueid();
  inline void clear_has_requniqueid();
  inline void set_has_lefttimer();
  inline void clear_has_lefttimer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* requniqueid_;
  ::google::protobuf::RepeatedPtrField< ::ProtoNet::DissolutionStatusDetail > details_;
  ::google::protobuf::int64 lefttimer_;
  ::google::protobuf::int32 dissolutionstatus_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static DissolutionStatus* default_instance_;
};
// -------------------------------------------------------------------

class DissolutionStatusDetail : public ::google::protobuf::Message {
 public:
  DissolutionStatusDetail();
  virtual ~DissolutionStatusDetail();

  DissolutionStatusDetail(const DissolutionStatusDetail& from);

  inline DissolutionStatusDetail& operator=(const DissolutionStatusDetail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DissolutionStatusDetail& default_instance();

  void Swap(DissolutionStatusDetail* other);

  // implements Message ----------------------------------------------

  DissolutionStatusDetail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DissolutionStatusDetail& from);
  void MergeFrom(const DissolutionStatusDetail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string roomId = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 1;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const char* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  inline void set_allocated_roomid(::std::string* roomid);

  // required string controllerUniqueId = 2;
  inline bool has_controlleruniqueid() const;
  inline void clear_controlleruniqueid();
  static const int kControllerUniqueIdFieldNumber = 2;
  inline const ::std::string& controlleruniqueid() const;
  inline void set_controlleruniqueid(const ::std::string& value);
  inline void set_controlleruniqueid(const char* value);
  inline void set_controlleruniqueid(const char* value, size_t size);
  inline ::std::string* mutable_controlleruniqueid();
  inline ::std::string* release_controlleruniqueid();
  inline void set_allocated_controlleruniqueid(::std::string* controlleruniqueid);

  // required int32 agree = 3;
  inline bool has_agree() const;
  inline void clear_agree();
  static const int kAgreeFieldNumber = 3;
  inline ::google::protobuf::int32 agree() const;
  inline void set_agree(::google::protobuf::int32 value);

  // required int32 pos = 4;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 4;
  inline ::google::protobuf::int32 pos() const;
  inline void set_pos(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ProtoNet.DissolutionStatusDetail)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_controlleruniqueid();
  inline void clear_has_controlleruniqueid();
  inline void set_has_agree();
  inline void clear_has_agree();
  inline void set_has_pos();
  inline void clear_has_pos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* roomid_;
  ::std::string* controlleruniqueid_;
  ::google::protobuf::int32 agree_;
  ::google::protobuf::int32 pos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static DissolutionStatusDetail* default_instance_;
};
// -------------------------------------------------------------------

class ReqLogicLogin : public ::google::protobuf::Message {
 public:
  ReqLogicLogin();
  virtual ~ReqLogicLogin();

  ReqLogicLogin(const ReqLogicLogin& from);

  inline ReqLogicLogin& operator=(const ReqLogicLogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqLogicLogin& default_instance();

  void Swap(ReqLogicLogin* other);

  // implements Message ----------------------------------------------

  ReqLogicLogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqLogicLogin& from);
  void MergeFrom(const ReqLogicLogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string account = 1;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 1;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // required string ticket = 2;
  inline bool has_ticket() const;
  inline void clear_ticket();
  static const int kTicketFieldNumber = 2;
  inline const ::std::string& ticket() const;
  inline void set_ticket(const ::std::string& value);
  inline void set_ticket(const char* value);
  inline void set_ticket(const char* value, size_t size);
  inline ::std::string* mutable_ticket();
  inline ::std::string* release_ticket();
  inline void set_allocated_ticket(::std::string* ticket);

  // @@protoc_insertion_point(class_scope:ProtoNet.ReqLogicLogin)
 private:
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_ticket();
  inline void clear_has_ticket();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  ::std::string* ticket_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ReqLogicLogin* default_instance_;
};
// -------------------------------------------------------------------

class ResLogicLogin : public ::google::protobuf::Message {
 public:
  ResLogicLogin();
  virtual ~ResLogicLogin();

  ResLogicLogin(const ResLogicLogin& from);

  inline ResLogicLogin& operator=(const ResLogicLogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResLogicLogin& default_instance();

  void Swap(ResLogicLogin* other);

  // implements Message ----------------------------------------------

  ResLogicLogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResLogicLogin& from);
  void MergeFrom(const ResLogicLogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoNet.ResponseResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::ProtoNet::ResponseResult& result() const;
  inline ::ProtoNet::ResponseResult* mutable_result();
  inline ::ProtoNet::ResponseResult* release_result();
  inline void set_allocated_result(::ProtoNet::ResponseResult* result);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResLogicLogin)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoNet::ResponseResult* result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ResLogicLogin* default_instance_;
};
// -------------------------------------------------------------------

class ReqCreateGameRoom : public ::google::protobuf::Message {
 public:
  ReqCreateGameRoom();
  virtual ~ReqCreateGameRoom();

  ReqCreateGameRoom(const ReqCreateGameRoom& from);

  inline ReqCreateGameRoom& operator=(const ReqCreateGameRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqCreateGameRoom& default_instance();

  void Swap(ReqCreateGameRoom* other);

  // implements Message ----------------------------------------------

  ReqCreateGameRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqCreateGameRoom& from);
  void MergeFrom(const ReqCreateGameRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 roomType = 1;
  inline bool has_roomtype() const;
  inline void clear_roomtype();
  static const int kRoomTypeFieldNumber = 1;
  inline ::google::protobuf::int32 roomtype() const;
  inline void set_roomtype(::google::protobuf::int32 value);

  // required int32 times = 2;
  inline bool has_times() const;
  inline void clear_times();
  static const int kTimesFieldNumber = 2;
  inline ::google::protobuf::int32 times() const;
  inline void set_times(::google::protobuf::int32 value);

  // optional string paramString = 3;
  inline bool has_paramstring() const;
  inline void clear_paramstring();
  static const int kParamStringFieldNumber = 3;
  inline const ::std::string& paramstring() const;
  inline void set_paramstring(const ::std::string& value);
  inline void set_paramstring(const char* value);
  inline void set_paramstring(const char* value, size_t size);
  inline ::std::string* mutable_paramstring();
  inline ::std::string* release_paramstring();
  inline void set_allocated_paramstring(::std::string* paramstring);

  // required int32 timesType = 4;
  inline bool has_timestype() const;
  inline void clear_timestype();
  static const int kTimesTypeFieldNumber = 4;
  inline ::google::protobuf::int32 timestype() const;
  inline void set_timestype(::google::protobuf::int32 value);

  // optional int32 payType = 5;
  inline bool has_paytype() const;
  inline void clear_paytype();
  static const int kPayTypeFieldNumber = 5;
  inline ::google::protobuf::int32 paytype() const;
  inline void set_paytype(::google::protobuf::int32 value);

  // optional int32 halfWayJoin = 6;
  inline bool has_halfwayjoin() const;
  inline void clear_halfwayjoin();
  static const int kHalfWayJoinFieldNumber = 6;
  inline ::google::protobuf::int32 halfwayjoin() const;
  inline void set_halfwayjoin(::google::protobuf::int32 value);

  // optional int32 maxPlayerNum = 7;
  inline bool has_maxplayernum() const;
  inline void clear_maxplayernum();
  static const int kMaxPlayerNumFieldNumber = 7;
  inline ::google::protobuf::int32 maxplayernum() const;
  inline void set_maxplayernum(::google::protobuf::int32 value);

  // optional double yazhu = 8;
  inline bool has_yazhu() const;
  inline void clear_yazhu();
  static const int kYazhuFieldNumber = 8;
  inline double yazhu() const;
  inline void set_yazhu(double value);

  // optional int32 fangkaJinbi = 9;
  inline bool has_fangkajinbi() const;
  inline void clear_fangkajinbi();
  static const int kFangkaJinbiFieldNumber = 9;
  inline ::google::protobuf::int32 fangkajinbi() const;
  inline void set_fangkajinbi(::google::protobuf::int32 value);

  // optional double minNeed = 10;
  inline bool has_minneed() const;
  inline void clear_minneed();
  static const int kMinNeedFieldNumber = 10;
  inline double minneed() const;
  inline void set_minneed(double value);

  // optional string pipeiParam = 11;
  inline bool has_pipeiparam() const;
  inline void clear_pipeiparam();
  static const int kPipeiParamFieldNumber = 11;
  inline const ::std::string& pipeiparam() const;
  inline void set_pipeiparam(const ::std::string& value);
  inline void set_pipeiparam(const char* value);
  inline void set_pipeiparam(const char* value, size_t size);
  inline ::std::string* mutable_pipeiparam();
  inline ::std::string* release_pipeiparam();
  inline void set_allocated_pipeiparam(::std::string* pipeiparam);

  // optional string clubId = 12;
  inline bool has_clubid() const;
  inline void clear_clubid();
  static const int kClubIdFieldNumber = 12;
  inline const ::std::string& clubid() const;
  inline void set_clubid(const ::std::string& value);
  inline void set_clubid(const char* value);
  inline void set_clubid(const char* value, size_t size);
  inline ::std::string* mutable_clubid();
  inline ::std::string* release_clubid();
  inline void set_allocated_clubid(::std::string* clubid);

  // optional string clubTableNum = 13;
  inline bool has_clubtablenum() const;
  inline void clear_clubtablenum();
  static const int kClubTableNumFieldNumber = 13;
  inline const ::std::string& clubtablenum() const;
  inline void set_clubtablenum(const ::std::string& value);
  inline void set_clubtablenum(const char* value);
  inline void set_clubtablenum(const char* value, size_t size);
  inline ::std::string* mutable_clubtablenum();
  inline ::std::string* release_clubtablenum();
  inline void set_allocated_clubtablenum(::std::string* clubtablenum);

  // optional string clubGameTypeId = 14;
  inline bool has_clubgametypeid() const;
  inline void clear_clubgametypeid();
  static const int kClubGameTypeIdFieldNumber = 14;
  inline const ::std::string& clubgametypeid() const;
  inline void set_clubgametypeid(const ::std::string& value);
  inline void set_clubgametypeid(const char* value);
  inline void set_clubgametypeid(const char* value, size_t size);
  inline ::std::string* mutable_clubgametypeid();
  inline ::std::string* release_clubgametypeid();
  inline void set_allocated_clubgametypeid(::std::string* clubgametypeid);

  // @@protoc_insertion_point(class_scope:ProtoNet.ReqCreateGameRoom)
 private:
  inline void set_has_roomtype();
  inline void clear_has_roomtype();
  inline void set_has_times();
  inline void clear_has_times();
  inline void set_has_paramstring();
  inline void clear_has_paramstring();
  inline void set_has_timestype();
  inline void clear_has_timestype();
  inline void set_has_paytype();
  inline void clear_has_paytype();
  inline void set_has_halfwayjoin();
  inline void clear_has_halfwayjoin();
  inline void set_has_maxplayernum();
  inline void clear_has_maxplayernum();
  inline void set_has_yazhu();
  inline void clear_has_yazhu();
  inline void set_has_fangkajinbi();
  inline void clear_has_fangkajinbi();
  inline void set_has_minneed();
  inline void clear_has_minneed();
  inline void set_has_pipeiparam();
  inline void clear_has_pipeiparam();
  inline void set_has_clubid();
  inline void clear_has_clubid();
  inline void set_has_clubtablenum();
  inline void clear_has_clubtablenum();
  inline void set_has_clubgametypeid();
  inline void clear_has_clubgametypeid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 roomtype_;
  ::google::protobuf::int32 times_;
  ::std::string* paramstring_;
  ::google::protobuf::int32 timestype_;
  ::google::protobuf::int32 paytype_;
  ::google::protobuf::int32 halfwayjoin_;
  ::google::protobuf::int32 maxplayernum_;
  double yazhu_;
  double minneed_;
  ::std::string* pipeiparam_;
  ::std::string* clubid_;
  ::std::string* clubtablenum_;
  ::std::string* clubgametypeid_;
  ::google::protobuf::int32 fangkajinbi_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ReqCreateGameRoom* default_instance_;
};
// -------------------------------------------------------------------

class ResCreateGameRoom : public ::google::protobuf::Message {
 public:
  ResCreateGameRoom();
  virtual ~ResCreateGameRoom();

  ResCreateGameRoom(const ResCreateGameRoom& from);

  inline ResCreateGameRoom& operator=(const ResCreateGameRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResCreateGameRoom& default_instance();

  void Swap(ResCreateGameRoom* other);

  // implements Message ----------------------------------------------

  ResCreateGameRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResCreateGameRoom& from);
  void MergeFrom(const ResCreateGameRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoNet.ResponseResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::ProtoNet::ResponseResult& result() const;
  inline ::ProtoNet::ResponseResult* mutable_result();
  inline ::ProtoNet::ResponseResult* release_result();
  inline void set_allocated_result(::ProtoNet::ResponseResult* result);

  // optional int64 readyTimer = 2;
  inline bool has_readytimer() const;
  inline void clear_readytimer();
  static const int kReadyTimerFieldNumber = 2;
  inline ::google::protobuf::int64 readytimer() const;
  inline void set_readytimer(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResCreateGameRoom)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_readytimer();
  inline void clear_has_readytimer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoNet::ResponseResult* result_;
  ::google::protobuf::int64 readytimer_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ResCreateGameRoom* default_instance_;
};
// -------------------------------------------------------------------

class ResNotifyGameRoomCreate : public ::google::protobuf::Message {
 public:
  ResNotifyGameRoomCreate();
  virtual ~ResNotifyGameRoomCreate();

  ResNotifyGameRoomCreate(const ResNotifyGameRoomCreate& from);

  inline ResNotifyGameRoomCreate& operator=(const ResNotifyGameRoomCreate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResNotifyGameRoomCreate& default_instance();

  void Swap(ResNotifyGameRoomCreate* other);

  // implements Message ----------------------------------------------

  ResNotifyGameRoomCreate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResNotifyGameRoomCreate& from);
  void MergeFrom(const ResNotifyGameRoomCreate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string roomId = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 1;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const char* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  inline void set_allocated_roomid(::std::string* roomid);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResNotifyGameRoomCreate)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* roomid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ResNotifyGameRoomCreate* default_instance_;
};
// -------------------------------------------------------------------

class ReqJoinGameRoom : public ::google::protobuf::Message {
 public:
  ReqJoinGameRoom();
  virtual ~ReqJoinGameRoom();

  ReqJoinGameRoom(const ReqJoinGameRoom& from);

  inline ReqJoinGameRoom& operator=(const ReqJoinGameRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqJoinGameRoom& default_instance();

  void Swap(ReqJoinGameRoom* other);

  // implements Message ----------------------------------------------

  ReqJoinGameRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqJoinGameRoom& from);
  void MergeFrom(const ReqJoinGameRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string roomId = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 1;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const char* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  inline void set_allocated_roomid(::std::string* roomid);

  // @@protoc_insertion_point(class_scope:ProtoNet.ReqJoinGameRoom)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* roomid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ReqJoinGameRoom* default_instance_;
};
// -------------------------------------------------------------------

class ResJoinGameRoom : public ::google::protobuf::Message {
 public:
  ResJoinGameRoom();
  virtual ~ResJoinGameRoom();

  ResJoinGameRoom(const ResJoinGameRoom& from);

  inline ResJoinGameRoom& operator=(const ResJoinGameRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResJoinGameRoom& default_instance();

  void Swap(ResJoinGameRoom* other);

  // implements Message ----------------------------------------------

  ResJoinGameRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResJoinGameRoom& from);
  void MergeFrom(const ResJoinGameRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoNet.ResponseResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::ProtoNet::ResponseResult& result() const;
  inline ::ProtoNet::ResponseResult* mutable_result();
  inline ::ProtoNet::ResponseResult* release_result();
  inline void set_allocated_result(::ProtoNet::ResponseResult* result);

  // optional .ProtoNet.RoomInfo roomInfo = 2;
  inline bool has_roominfo() const;
  inline void clear_roominfo();
  static const int kRoomInfoFieldNumber = 2;
  inline const ::ProtoNet::RoomInfo& roominfo() const;
  inline ::ProtoNet::RoomInfo* mutable_roominfo();
  inline ::ProtoNet::RoomInfo* release_roominfo();
  inline void set_allocated_roominfo(::ProtoNet::RoomInfo* roominfo);

  // optional int64 readyTimer = 3;
  inline bool has_readytimer() const;
  inline void clear_readytimer();
  static const int kReadyTimerFieldNumber = 3;
  inline ::google::protobuf::int64 readytimer() const;
  inline void set_readytimer(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResJoinGameRoom)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_roominfo();
  inline void clear_has_roominfo();
  inline void set_has_readytimer();
  inline void clear_has_readytimer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoNet::ResponseResult* result_;
  ::ProtoNet::RoomInfo* roominfo_;
  ::google::protobuf::int64 readytimer_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ResJoinGameRoom* default_instance_;
};
// -------------------------------------------------------------------

class ResNotifySomeOneJoinGameRoom : public ::google::protobuf::Message {
 public:
  ResNotifySomeOneJoinGameRoom();
  virtual ~ResNotifySomeOneJoinGameRoom();

  ResNotifySomeOneJoinGameRoom(const ResNotifySomeOneJoinGameRoom& from);

  inline ResNotifySomeOneJoinGameRoom& operator=(const ResNotifySomeOneJoinGameRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResNotifySomeOneJoinGameRoom& default_instance();

  void Swap(ResNotifySomeOneJoinGameRoom* other);

  // implements Message ----------------------------------------------

  ResNotifySomeOneJoinGameRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResNotifySomeOneJoinGameRoom& from);
  void MergeFrom(const ResNotifySomeOneJoinGameRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string roomId = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 1;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const char* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  inline void set_allocated_roomid(::std::string* roomid);

  // required .ProtoNet.SdkController controller = 2;
  inline bool has_controller() const;
  inline void clear_controller();
  static const int kControllerFieldNumber = 2;
  inline const ::ProtoNet::SdkController& controller() const;
  inline ::ProtoNet::SdkController* mutable_controller();
  inline ::ProtoNet::SdkController* release_controller();
  inline void set_allocated_controller(::ProtoNet::SdkController* controller);

  // required .ProtoNet.PosBrife posBrife = 3;
  inline bool has_posbrife() const;
  inline void clear_posbrife();
  static const int kPosBrifeFieldNumber = 3;
  inline const ::ProtoNet::PosBrife& posbrife() const;
  inline ::ProtoNet::PosBrife* mutable_posbrife();
  inline ::ProtoNet::PosBrife* release_posbrife();
  inline void set_allocated_posbrife(::ProtoNet::PosBrife* posbrife);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResNotifySomeOneJoinGameRoom)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_controller();
  inline void clear_has_controller();
  inline void set_has_posbrife();
  inline void clear_has_posbrife();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* roomid_;
  ::ProtoNet::SdkController* controller_;
  ::ProtoNet::PosBrife* posbrife_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ResNotifySomeOneJoinGameRoom* default_instance_;
};
// -------------------------------------------------------------------

class ReqExitGameRoom : public ::google::protobuf::Message {
 public:
  ReqExitGameRoom();
  virtual ~ReqExitGameRoom();

  ReqExitGameRoom(const ReqExitGameRoom& from);

  inline ReqExitGameRoom& operator=(const ReqExitGameRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqExitGameRoom& default_instance();

  void Swap(ReqExitGameRoom* other);

  // implements Message ----------------------------------------------

  ReqExitGameRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqExitGameRoom& from);
  void MergeFrom(const ReqExitGameRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ProtoNet.ReqExitGameRoom)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ReqExitGameRoom* default_instance_;
};
// -------------------------------------------------------------------

class ResExitGameRoom : public ::google::protobuf::Message {
 public:
  ResExitGameRoom();
  virtual ~ResExitGameRoom();

  ResExitGameRoom(const ResExitGameRoom& from);

  inline ResExitGameRoom& operator=(const ResExitGameRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResExitGameRoom& default_instance();

  void Swap(ResExitGameRoom* other);

  // implements Message ----------------------------------------------

  ResExitGameRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResExitGameRoom& from);
  void MergeFrom(const ResExitGameRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoNet.ResponseResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::ProtoNet::ResponseResult& result() const;
  inline ::ProtoNet::ResponseResult* mutable_result();
  inline ::ProtoNet::ResponseResult* release_result();
  inline void set_allocated_result(::ProtoNet::ResponseResult* result);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResExitGameRoom)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoNet::ResponseResult* result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ResExitGameRoom* default_instance_;
};
// -------------------------------------------------------------------

class ResNotifySomeOneExitGameRoom : public ::google::protobuf::Message {
 public:
  ResNotifySomeOneExitGameRoom();
  virtual ~ResNotifySomeOneExitGameRoom();

  ResNotifySomeOneExitGameRoom(const ResNotifySomeOneExitGameRoom& from);

  inline ResNotifySomeOneExitGameRoom& operator=(const ResNotifySomeOneExitGameRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResNotifySomeOneExitGameRoom& default_instance();

  void Swap(ResNotifySomeOneExitGameRoom* other);

  // implements Message ----------------------------------------------

  ResNotifySomeOneExitGameRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResNotifySomeOneExitGameRoom& from);
  void MergeFrom(const ResNotifySomeOneExitGameRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string roomId = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 1;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const char* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  inline void set_allocated_roomid(::std::string* roomid);

  // required .ProtoNet.SdkController controller = 2;
  inline bool has_controller() const;
  inline void clear_controller();
  static const int kControllerFieldNumber = 2;
  inline const ::ProtoNet::SdkController& controller() const;
  inline ::ProtoNet::SdkController* mutable_controller();
  inline ::ProtoNet::SdkController* release_controller();
  inline void set_allocated_controller(::ProtoNet::SdkController* controller);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResNotifySomeOneExitGameRoom)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_controller();
  inline void clear_has_controller();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* roomid_;
  ::ProtoNet::SdkController* controller_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ResNotifySomeOneExitGameRoom* default_instance_;
};
// -------------------------------------------------------------------

class ReqGameReady : public ::google::protobuf::Message {
 public:
  ReqGameReady();
  virtual ~ReqGameReady();

  ReqGameReady(const ReqGameReady& from);

  inline ReqGameReady& operator=(const ReqGameReady& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqGameReady& default_instance();

  void Swap(ReqGameReady* other);

  // implements Message ----------------------------------------------

  ReqGameReady* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqGameReady& from);
  void MergeFrom(const ReqGameReady& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool ready = 1;
  inline bool has_ready() const;
  inline void clear_ready();
  static const int kReadyFieldNumber = 1;
  inline bool ready() const;
  inline void set_ready(bool value);

  // @@protoc_insertion_point(class_scope:ProtoNet.ReqGameReady)
 private:
  inline void set_has_ready();
  inline void clear_has_ready();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool ready_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ReqGameReady* default_instance_;
};
// -------------------------------------------------------------------

class ResGameReady : public ::google::protobuf::Message {
 public:
  ResGameReady();
  virtual ~ResGameReady();

  ResGameReady(const ResGameReady& from);

  inline ResGameReady& operator=(const ResGameReady& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResGameReady& default_instance();

  void Swap(ResGameReady* other);

  // implements Message ----------------------------------------------

  ResGameReady* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResGameReady& from);
  void MergeFrom(const ResGameReady& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoNet.ResponseResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::ProtoNet::ResponseResult& result() const;
  inline ::ProtoNet::ResponseResult* mutable_result();
  inline ::ProtoNet::ResponseResult* release_result();
  inline void set_allocated_result(::ProtoNet::ResponseResult* result);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResGameReady)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoNet::ResponseResult* result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ResGameReady* default_instance_;
};
// -------------------------------------------------------------------

class ReqDissolutionGameRoom : public ::google::protobuf::Message {
 public:
  ReqDissolutionGameRoom();
  virtual ~ReqDissolutionGameRoom();

  ReqDissolutionGameRoom(const ReqDissolutionGameRoom& from);

  inline ReqDissolutionGameRoom& operator=(const ReqDissolutionGameRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqDissolutionGameRoom& default_instance();

  void Swap(ReqDissolutionGameRoom* other);

  // implements Message ----------------------------------------------

  ReqDissolutionGameRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqDissolutionGameRoom& from);
  void MergeFrom(const ReqDissolutionGameRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ProtoNet.ReqDissolutionGameRoom)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ReqDissolutionGameRoom* default_instance_;
};
// -------------------------------------------------------------------

class ResDissolutionGameRoom : public ::google::protobuf::Message {
 public:
  ResDissolutionGameRoom();
  virtual ~ResDissolutionGameRoom();

  ResDissolutionGameRoom(const ResDissolutionGameRoom& from);

  inline ResDissolutionGameRoom& operator=(const ResDissolutionGameRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResDissolutionGameRoom& default_instance();

  void Swap(ResDissolutionGameRoom* other);

  // implements Message ----------------------------------------------

  ResDissolutionGameRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResDissolutionGameRoom& from);
  void MergeFrom(const ResDissolutionGameRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoNet.ResponseResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::ProtoNet::ResponseResult& result() const;
  inline ::ProtoNet::ResponseResult* mutable_result();
  inline ::ProtoNet::ResponseResult* release_result();
  inline void set_allocated_result(::ProtoNet::ResponseResult* result);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResDissolutionGameRoom)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoNet::ResponseResult* result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ResDissolutionGameRoom* default_instance_;
};
// -------------------------------------------------------------------

class ResNotifySomeOneReqDissolutionGameRoom : public ::google::protobuf::Message {
 public:
  ResNotifySomeOneReqDissolutionGameRoom();
  virtual ~ResNotifySomeOneReqDissolutionGameRoom();

  ResNotifySomeOneReqDissolutionGameRoom(const ResNotifySomeOneReqDissolutionGameRoom& from);

  inline ResNotifySomeOneReqDissolutionGameRoom& operator=(const ResNotifySomeOneReqDissolutionGameRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResNotifySomeOneReqDissolutionGameRoom& default_instance();

  void Swap(ResNotifySomeOneReqDissolutionGameRoom* other);

  // implements Message ----------------------------------------------

  ResNotifySomeOneReqDissolutionGameRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResNotifySomeOneReqDissolutionGameRoom& from);
  void MergeFrom(const ResNotifySomeOneReqDissolutionGameRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string roomId = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 1;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const char* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  inline void set_allocated_roomid(::std::string* roomid);

  // required .ProtoNet.SdkController controller = 2;
  inline bool has_controller() const;
  inline void clear_controller();
  static const int kControllerFieldNumber = 2;
  inline const ::ProtoNet::SdkController& controller() const;
  inline ::ProtoNet::SdkController* mutable_controller();
  inline ::ProtoNet::SdkController* release_controller();
  inline void set_allocated_controller(::ProtoNet::SdkController* controller);

  // required .ProtoNet.PosBrife posBrife = 3;
  inline bool has_posbrife() const;
  inline void clear_posbrife();
  static const int kPosBrifeFieldNumber = 3;
  inline const ::ProtoNet::PosBrife& posbrife() const;
  inline ::ProtoNet::PosBrife* mutable_posbrife();
  inline ::ProtoNet::PosBrife* release_posbrife();
  inline void set_allocated_posbrife(::ProtoNet::PosBrife* posbrife);

  // required int64 timer = 4;
  inline bool has_timer() const;
  inline void clear_timer();
  static const int kTimerFieldNumber = 4;
  inline ::google::protobuf::int64 timer() const;
  inline void set_timer(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResNotifySomeOneReqDissolutionGameRoom)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_controller();
  inline void clear_has_controller();
  inline void set_has_posbrife();
  inline void clear_has_posbrife();
  inline void set_has_timer();
  inline void clear_has_timer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* roomid_;
  ::ProtoNet::SdkController* controller_;
  ::ProtoNet::PosBrife* posbrife_;
  ::google::protobuf::int64 timer_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ResNotifySomeOneReqDissolutionGameRoom* default_instance_;
};
// -------------------------------------------------------------------

class ReqAgreeDissolutionGameRoom : public ::google::protobuf::Message {
 public:
  ReqAgreeDissolutionGameRoom();
  virtual ~ReqAgreeDissolutionGameRoom();

  ReqAgreeDissolutionGameRoom(const ReqAgreeDissolutionGameRoom& from);

  inline ReqAgreeDissolutionGameRoom& operator=(const ReqAgreeDissolutionGameRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqAgreeDissolutionGameRoom& default_instance();

  void Swap(ReqAgreeDissolutionGameRoom* other);

  // implements Message ----------------------------------------------

  ReqAgreeDissolutionGameRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqAgreeDissolutionGameRoom& from);
  void MergeFrom(const ReqAgreeDissolutionGameRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool agree = 1;
  inline bool has_agree() const;
  inline void clear_agree();
  static const int kAgreeFieldNumber = 1;
  inline bool agree() const;
  inline void set_agree(bool value);

  // @@protoc_insertion_point(class_scope:ProtoNet.ReqAgreeDissolutionGameRoom)
 private:
  inline void set_has_agree();
  inline void clear_has_agree();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool agree_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ReqAgreeDissolutionGameRoom* default_instance_;
};
// -------------------------------------------------------------------

class ResAgreeDissolutionGameRoom : public ::google::protobuf::Message {
 public:
  ResAgreeDissolutionGameRoom();
  virtual ~ResAgreeDissolutionGameRoom();

  ResAgreeDissolutionGameRoom(const ResAgreeDissolutionGameRoom& from);

  inline ResAgreeDissolutionGameRoom& operator=(const ResAgreeDissolutionGameRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResAgreeDissolutionGameRoom& default_instance();

  void Swap(ResAgreeDissolutionGameRoom* other);

  // implements Message ----------------------------------------------

  ResAgreeDissolutionGameRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResAgreeDissolutionGameRoom& from);
  void MergeFrom(const ResAgreeDissolutionGameRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoNet.ResponseResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::ProtoNet::ResponseResult& result() const;
  inline ::ProtoNet::ResponseResult* mutable_result();
  inline ::ProtoNet::ResponseResult* release_result();
  inline void set_allocated_result(::ProtoNet::ResponseResult* result);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResAgreeDissolutionGameRoom)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoNet::ResponseResult* result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ResAgreeDissolutionGameRoom* default_instance_;
};
// -------------------------------------------------------------------

class ResNotifySomeOneAggreeDissolutionGameRoom : public ::google::protobuf::Message {
 public:
  ResNotifySomeOneAggreeDissolutionGameRoom();
  virtual ~ResNotifySomeOneAggreeDissolutionGameRoom();

  ResNotifySomeOneAggreeDissolutionGameRoom(const ResNotifySomeOneAggreeDissolutionGameRoom& from);

  inline ResNotifySomeOneAggreeDissolutionGameRoom& operator=(const ResNotifySomeOneAggreeDissolutionGameRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResNotifySomeOneAggreeDissolutionGameRoom& default_instance();

  void Swap(ResNotifySomeOneAggreeDissolutionGameRoom* other);

  // implements Message ----------------------------------------------

  ResNotifySomeOneAggreeDissolutionGameRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResNotifySomeOneAggreeDissolutionGameRoom& from);
  void MergeFrom(const ResNotifySomeOneAggreeDissolutionGameRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string roomId = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 1;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const char* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  inline void set_allocated_roomid(::std::string* roomid);

  // required .ProtoNet.SdkController controller = 2;
  inline bool has_controller() const;
  inline void clear_controller();
  static const int kControllerFieldNumber = 2;
  inline const ::ProtoNet::SdkController& controller() const;
  inline ::ProtoNet::SdkController* mutable_controller();
  inline ::ProtoNet::SdkController* release_controller();
  inline void set_allocated_controller(::ProtoNet::SdkController* controller);

  // required .ProtoNet.PosBrife posBrife = 3;
  inline bool has_posbrife() const;
  inline void clear_posbrife();
  static const int kPosBrifeFieldNumber = 3;
  inline const ::ProtoNet::PosBrife& posbrife() const;
  inline ::ProtoNet::PosBrife* mutable_posbrife();
  inline ::ProtoNet::PosBrife* release_posbrife();
  inline void set_allocated_posbrife(::ProtoNet::PosBrife* posbrife);

  // required bool agree = 4;
  inline bool has_agree() const;
  inline void clear_agree();
  static const int kAgreeFieldNumber = 4;
  inline bool agree() const;
  inline void set_agree(bool value);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResNotifySomeOneAggreeDissolutionGameRoom)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_controller();
  inline void clear_has_controller();
  inline void set_has_posbrife();
  inline void clear_has_posbrife();
  inline void set_has_agree();
  inline void clear_has_agree();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* roomid_;
  ::ProtoNet::SdkController* controller_;
  ::ProtoNet::PosBrife* posbrife_;
  bool agree_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ResNotifySomeOneAggreeDissolutionGameRoom* default_instance_;
};
// -------------------------------------------------------------------

class ResNotifyGameRoomDissolution : public ::google::protobuf::Message {
 public:
  ResNotifyGameRoomDissolution();
  virtual ~ResNotifyGameRoomDissolution();

  ResNotifyGameRoomDissolution(const ResNotifyGameRoomDissolution& from);

  inline ResNotifyGameRoomDissolution& operator=(const ResNotifyGameRoomDissolution& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResNotifyGameRoomDissolution& default_instance();

  void Swap(ResNotifyGameRoomDissolution* other);

  // implements Message ----------------------------------------------

  ResNotifyGameRoomDissolution* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResNotifyGameRoomDissolution& from);
  void MergeFrom(const ResNotifyGameRoomDissolution& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ProtoNet.ResNotifyGameRoomDissolution)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ResNotifyGameRoomDissolution* default_instance_;
};
// -------------------------------------------------------------------

class ResNotifyGameOver : public ::google::protobuf::Message {
 public:
  ResNotifyGameOver();
  virtual ~ResNotifyGameOver();

  ResNotifyGameOver(const ResNotifyGameOver& from);

  inline ResNotifyGameOver& operator=(const ResNotifyGameOver& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResNotifyGameOver& default_instance();

  void Swap(ResNotifyGameOver* other);

  // implements Message ----------------------------------------------

  ResNotifyGameOver* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResNotifyGameOver& from);
  void MergeFrom(const ResNotifyGameOver& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ProtoNet.ResNotifyGameOver)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ResNotifyGameOver* default_instance_;
};
// -------------------------------------------------------------------

class ReqGetRoomInfo : public ::google::protobuf::Message {
 public:
  ReqGetRoomInfo();
  virtual ~ReqGetRoomInfo();

  ReqGetRoomInfo(const ReqGetRoomInfo& from);

  inline ReqGetRoomInfo& operator=(const ReqGetRoomInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqGetRoomInfo& default_instance();

  void Swap(ReqGetRoomInfo* other);

  // implements Message ----------------------------------------------

  ReqGetRoomInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqGetRoomInfo& from);
  void MergeFrom(const ReqGetRoomInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ProtoNet.ReqGetRoomInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ReqGetRoomInfo* default_instance_;
};
// -------------------------------------------------------------------

class ResGetRoomInfo : public ::google::protobuf::Message {
 public:
  ResGetRoomInfo();
  virtual ~ResGetRoomInfo();

  ResGetRoomInfo(const ResGetRoomInfo& from);

  inline ResGetRoomInfo& operator=(const ResGetRoomInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResGetRoomInfo& default_instance();

  void Swap(ResGetRoomInfo* other);

  // implements Message ----------------------------------------------

  ResGetRoomInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResGetRoomInfo& from);
  void MergeFrom(const ResGetRoomInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoNet.ResponseResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::ProtoNet::ResponseResult& result() const;
  inline ::ProtoNet::ResponseResult* mutable_result();
  inline ::ProtoNet::ResponseResult* release_result();
  inline void set_allocated_result(::ProtoNet::ResponseResult* result);

  // optional .ProtoNet.RoomInfo roomInfo = 2;
  inline bool has_roominfo() const;
  inline void clear_roominfo();
  static const int kRoomInfoFieldNumber = 2;
  inline const ::ProtoNet::RoomInfo& roominfo() const;
  inline ::ProtoNet::RoomInfo* mutable_roominfo();
  inline ::ProtoNet::RoomInfo* release_roominfo();
  inline void set_allocated_roominfo(::ProtoNet::RoomInfo* roominfo);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResGetRoomInfo)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_roominfo();
  inline void clear_has_roominfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoNet::ResponseResult* result_;
  ::ProtoNet::RoomInfo* roominfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ResGetRoomInfo* default_instance_;
};
// -------------------------------------------------------------------

class ResNotifySomeOneGameReady : public ::google::protobuf::Message {
 public:
  ResNotifySomeOneGameReady();
  virtual ~ResNotifySomeOneGameReady();

  ResNotifySomeOneGameReady(const ResNotifySomeOneGameReady& from);

  inline ResNotifySomeOneGameReady& operator=(const ResNotifySomeOneGameReady& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResNotifySomeOneGameReady& default_instance();

  void Swap(ResNotifySomeOneGameReady* other);

  // implements Message ----------------------------------------------

  ResNotifySomeOneGameReady* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResNotifySomeOneGameReady& from);
  void MergeFrom(const ResNotifySomeOneGameReady& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string roomId = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 1;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const char* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  inline void set_allocated_roomid(::std::string* roomid);

  // required .ProtoNet.SdkController controller = 2;
  inline bool has_controller() const;
  inline void clear_controller();
  static const int kControllerFieldNumber = 2;
  inline const ::ProtoNet::SdkController& controller() const;
  inline ::ProtoNet::SdkController* mutable_controller();
  inline ::ProtoNet::SdkController* release_controller();
  inline void set_allocated_controller(::ProtoNet::SdkController* controller);

  // required .ProtoNet.PosBrife posBrife = 3;
  inline bool has_posbrife() const;
  inline void clear_posbrife();
  static const int kPosBrifeFieldNumber = 3;
  inline const ::ProtoNet::PosBrife& posbrife() const;
  inline ::ProtoNet::PosBrife* mutable_posbrife();
  inline ::ProtoNet::PosBrife* release_posbrife();
  inline void set_allocated_posbrife(::ProtoNet::PosBrife* posbrife);

  // required bool ready = 4;
  inline bool has_ready() const;
  inline void clear_ready();
  static const int kReadyFieldNumber = 4;
  inline bool ready() const;
  inline void set_ready(bool value);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResNotifySomeOneGameReady)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_controller();
  inline void clear_has_controller();
  inline void set_has_posbrife();
  inline void clear_has_posbrife();
  inline void set_has_ready();
  inline void clear_has_ready();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* roomid_;
  ::ProtoNet::SdkController* controller_;
  ::ProtoNet::PosBrife* posbrife_;
  bool ready_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ResNotifySomeOneGameReady* default_instance_;
};
// -------------------------------------------------------------------

class ReqChangeOnlineStatus : public ::google::protobuf::Message {
 public:
  ReqChangeOnlineStatus();
  virtual ~ReqChangeOnlineStatus();

  ReqChangeOnlineStatus(const ReqChangeOnlineStatus& from);

  inline ReqChangeOnlineStatus& operator=(const ReqChangeOnlineStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqChangeOnlineStatus& default_instance();

  void Swap(ReqChangeOnlineStatus* other);

  // implements Message ----------------------------------------------

  ReqChangeOnlineStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqChangeOnlineStatus& from);
  void MergeFrom(const ReqChangeOnlineStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool online = 1;
  inline bool has_online() const;
  inline void clear_online();
  static const int kOnlineFieldNumber = 1;
  inline bool online() const;
  inline void set_online(bool value);

  // @@protoc_insertion_point(class_scope:ProtoNet.ReqChangeOnlineStatus)
 private:
  inline void set_has_online();
  inline void clear_has_online();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool online_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ReqChangeOnlineStatus* default_instance_;
};
// -------------------------------------------------------------------

class ResChangeOnlineStatus : public ::google::protobuf::Message {
 public:
  ResChangeOnlineStatus();
  virtual ~ResChangeOnlineStatus();

  ResChangeOnlineStatus(const ResChangeOnlineStatus& from);

  inline ResChangeOnlineStatus& operator=(const ResChangeOnlineStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResChangeOnlineStatus& default_instance();

  void Swap(ResChangeOnlineStatus* other);

  // implements Message ----------------------------------------------

  ResChangeOnlineStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResChangeOnlineStatus& from);
  void MergeFrom(const ResChangeOnlineStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoNet.ResponseResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::ProtoNet::ResponseResult& result() const;
  inline ::ProtoNet::ResponseResult* mutable_result();
  inline ::ProtoNet::ResponseResult* release_result();
  inline void set_allocated_result(::ProtoNet::ResponseResult* result);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResChangeOnlineStatus)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoNet::ResponseResult* result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ResChangeOnlineStatus* default_instance_;
};
// -------------------------------------------------------------------

class ResNotifySomeOneChangeOnlineStatus : public ::google::protobuf::Message {
 public:
  ResNotifySomeOneChangeOnlineStatus();
  virtual ~ResNotifySomeOneChangeOnlineStatus();

  ResNotifySomeOneChangeOnlineStatus(const ResNotifySomeOneChangeOnlineStatus& from);

  inline ResNotifySomeOneChangeOnlineStatus& operator=(const ResNotifySomeOneChangeOnlineStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResNotifySomeOneChangeOnlineStatus& default_instance();

  void Swap(ResNotifySomeOneChangeOnlineStatus* other);

  // implements Message ----------------------------------------------

  ResNotifySomeOneChangeOnlineStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResNotifySomeOneChangeOnlineStatus& from);
  void MergeFrom(const ResNotifySomeOneChangeOnlineStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string roomId = 1;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 1;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const char* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  inline void set_allocated_roomid(::std::string* roomid);

  // required .ProtoNet.SdkController controller = 2;
  inline bool has_controller() const;
  inline void clear_controller();
  static const int kControllerFieldNumber = 2;
  inline const ::ProtoNet::SdkController& controller() const;
  inline ::ProtoNet::SdkController* mutable_controller();
  inline ::ProtoNet::SdkController* release_controller();
  inline void set_allocated_controller(::ProtoNet::SdkController* controller);

  // required .ProtoNet.PosBrife posBrife = 3;
  inline bool has_posbrife() const;
  inline void clear_posbrife();
  static const int kPosBrifeFieldNumber = 3;
  inline const ::ProtoNet::PosBrife& posbrife() const;
  inline ::ProtoNet::PosBrife* mutable_posbrife();
  inline ::ProtoNet::PosBrife* release_posbrife();
  inline void set_allocated_posbrife(::ProtoNet::PosBrife* posbrife);

  // required bool online = 4;
  inline bool has_online() const;
  inline void clear_online();
  static const int kOnlineFieldNumber = 4;
  inline bool online() const;
  inline void set_online(bool value);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResNotifySomeOneChangeOnlineStatus)
 private:
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_controller();
  inline void clear_has_controller();
  inline void set_has_posbrife();
  inline void clear_has_posbrife();
  inline void set_has_online();
  inline void clear_has_online();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* roomid_;
  ::ProtoNet::SdkController* controller_;
  ::ProtoNet::PosBrife* posbrife_;
  bool online_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ResNotifySomeOneChangeOnlineStatus* default_instance_;
};
// -------------------------------------------------------------------

class ResNotifyBigCalculatePanel : public ::google::protobuf::Message {
 public:
  ResNotifyBigCalculatePanel();
  virtual ~ResNotifyBigCalculatePanel();

  ResNotifyBigCalculatePanel(const ResNotifyBigCalculatePanel& from);

  inline ResNotifyBigCalculatePanel& operator=(const ResNotifyBigCalculatePanel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResNotifyBigCalculatePanel& default_instance();

  void Swap(ResNotifyBigCalculatePanel* other);

  // implements Message ----------------------------------------------

  ResNotifyBigCalculatePanel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResNotifyBigCalculatePanel& from);
  void MergeFrom(const ResNotifyBigCalculatePanel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ProtoNet.ResNotifyBigCalculatePanel)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ResNotifyBigCalculatePanel* default_instance_;
};
// -------------------------------------------------------------------

class ReqCorrectTimer : public ::google::protobuf::Message {
 public:
  ReqCorrectTimer();
  virtual ~ReqCorrectTimer();

  ReqCorrectTimer(const ReqCorrectTimer& from);

  inline ReqCorrectTimer& operator=(const ReqCorrectTimer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqCorrectTimer& default_instance();

  void Swap(ReqCorrectTimer* other);

  // implements Message ----------------------------------------------

  ReqCorrectTimer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqCorrectTimer& from);
  void MergeFrom(const ReqCorrectTimer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ProtoNet.ReqCorrectTimer)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ReqCorrectTimer* default_instance_;
};
// -------------------------------------------------------------------

class ResCorrectTimer : public ::google::protobuf::Message {
 public:
  ResCorrectTimer();
  virtual ~ResCorrectTimer();

  ResCorrectTimer(const ResCorrectTimer& from);

  inline ResCorrectTimer& operator=(const ResCorrectTimer& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResCorrectTimer& default_instance();

  void Swap(ResCorrectTimer* other);

  // implements Message ----------------------------------------------

  ResCorrectTimer* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResCorrectTimer& from);
  void MergeFrom(const ResCorrectTimer& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoNet.ResponseResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::ProtoNet::ResponseResult& result() const;
  inline ::ProtoNet::ResponseResult* mutable_result();
  inline ::ProtoNet::ResponseResult* release_result();
  inline void set_allocated_result(::ProtoNet::ResponseResult* result);

  // optional int64 leftDissolutionTimer = 2;
  inline bool has_leftdissolutiontimer() const;
  inline void clear_leftdissolutiontimer();
  static const int kLeftDissolutionTimerFieldNumber = 2;
  inline ::google::protobuf::int64 leftdissolutiontimer() const;
  inline void set_leftdissolutiontimer(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResCorrectTimer)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_leftdissolutiontimer();
  inline void clear_has_leftdissolutiontimer();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoNet::ResponseResult* result_;
  ::google::protobuf::int64 leftdissolutiontimer_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ResCorrectTimer* default_instance_;
};
// -------------------------------------------------------------------

class ReqQuickChangeRoom : public ::google::protobuf::Message {
 public:
  ReqQuickChangeRoom();
  virtual ~ReqQuickChangeRoom();

  ReqQuickChangeRoom(const ReqQuickChangeRoom& from);

  inline ReqQuickChangeRoom& operator=(const ReqQuickChangeRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqQuickChangeRoom& default_instance();

  void Swap(ReqQuickChangeRoom* other);

  // implements Message ----------------------------------------------

  ReqQuickChangeRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqQuickChangeRoom& from);
  void MergeFrom(const ReqQuickChangeRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string pipeiParam = 1;
  inline bool has_pipeiparam() const;
  inline void clear_pipeiparam();
  static const int kPipeiParamFieldNumber = 1;
  inline const ::std::string& pipeiparam() const;
  inline void set_pipeiparam(const ::std::string& value);
  inline void set_pipeiparam(const char* value);
  inline void set_pipeiparam(const char* value, size_t size);
  inline ::std::string* mutable_pipeiparam();
  inline ::std::string* release_pipeiparam();
  inline void set_allocated_pipeiparam(::std::string* pipeiparam);

  // @@protoc_insertion_point(class_scope:ProtoNet.ReqQuickChangeRoom)
 private:
  inline void set_has_pipeiparam();
  inline void clear_has_pipeiparam();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* pipeiparam_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ReqQuickChangeRoom* default_instance_;
};
// -------------------------------------------------------------------

class ResQuickChangeRoom : public ::google::protobuf::Message {
 public:
  ResQuickChangeRoom();
  virtual ~ResQuickChangeRoom();

  ResQuickChangeRoom(const ResQuickChangeRoom& from);

  inline ResQuickChangeRoom& operator=(const ResQuickChangeRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResQuickChangeRoom& default_instance();

  void Swap(ResQuickChangeRoom* other);

  // implements Message ----------------------------------------------

  ResQuickChangeRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResQuickChangeRoom& from);
  void MergeFrom(const ResQuickChangeRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoNet.ResponseResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::ProtoNet::ResponseResult& result() const;
  inline ::ProtoNet::ResponseResult* mutable_result();
  inline ::ProtoNet::ResponseResult* release_result();
  inline void set_allocated_result(::ProtoNet::ResponseResult* result);

  // optional int32 operate = 2;
  inline bool has_operate() const;
  inline void clear_operate();
  static const int kOperateFieldNumber = 2;
  inline ::google::protobuf::int32 operate() const;
  inline void set_operate(::google::protobuf::int32 value);

  // optional int32 roomType = 3;
  inline bool has_roomtype() const;
  inline void clear_roomtype();
  static const int kRoomTypeFieldNumber = 3;
  inline ::google::protobuf::int32 roomtype() const;
  inline void set_roomtype(::google::protobuf::int32 value);

  // optional .ProtoNet.ServerInfoIpsSafeDetail bestServerInfo = 4;
  inline bool has_bestserverinfo() const;
  inline void clear_bestserverinfo();
  static const int kBestServerInfoFieldNumber = 4;
  inline const ::ProtoNet::ServerInfoIpsSafeDetail& bestserverinfo() const;
  inline ::ProtoNet::ServerInfoIpsSafeDetail* mutable_bestserverinfo();
  inline ::ProtoNet::ServerInfoIpsSafeDetail* release_bestserverinfo();
  inline void set_allocated_bestserverinfo(::ProtoNet::ServerInfoIpsSafeDetail* bestserverinfo);

  // optional string roomId = 5;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 5;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const char* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  inline void set_allocated_roomid(::std::string* roomid);

  // repeated .ProtoNet.ServerInfoIpsSafeDetail logicDetails = 6;
  inline int logicdetails_size() const;
  inline void clear_logicdetails();
  static const int kLogicDetailsFieldNumber = 6;
  inline const ::ProtoNet::ServerInfoIpsSafeDetail& logicdetails(int index) const;
  inline ::ProtoNet::ServerInfoIpsSafeDetail* mutable_logicdetails(int index);
  inline ::ProtoNet::ServerInfoIpsSafeDetail* add_logicdetails();
  inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::ServerInfoIpsSafeDetail >&
      logicdetails() const;
  inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::ServerInfoIpsSafeDetail >*
      mutable_logicdetails();

  // optional int32 gameId = 7;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 7;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);

  // optional int32 timesType = 8;
  inline bool has_timestype() const;
  inline void clear_timestype();
  static const int kTimesTypeFieldNumber = 8;
  inline ::google::protobuf::int32 timestype() const;
  inline void set_timestype(::google::protobuf::int32 value);

  // required int32 changeServer = 9;
  inline bool has_changeserver() const;
  inline void clear_changeserver();
  static const int kChangeServerFieldNumber = 9;
  inline ::google::protobuf::int32 changeserver() const;
  inline void set_changeserver(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResQuickChangeRoom)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_operate();
  inline void clear_has_operate();
  inline void set_has_roomtype();
  inline void clear_has_roomtype();
  inline void set_has_bestserverinfo();
  inline void clear_has_bestserverinfo();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_timestype();
  inline void clear_has_timestype();
  inline void set_has_changeserver();
  inline void clear_has_changeserver();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoNet::ResponseResult* result_;
  ::google::protobuf::int32 operate_;
  ::google::protobuf::int32 roomtype_;
  ::ProtoNet::ServerInfoIpsSafeDetail* bestserverinfo_;
  ::std::string* roomid_;
  ::google::protobuf::RepeatedPtrField< ::ProtoNet::ServerInfoIpsSafeDetail > logicdetails_;
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 timestype_;
  ::google::protobuf::int32 changeserver_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ResQuickChangeRoom* default_instance_;
};
// -------------------------------------------------------------------

class ResNotifySomeOneChangeRobot : public ::google::protobuf::Message {
 public:
  ResNotifySomeOneChangeRobot();
  virtual ~ResNotifySomeOneChangeRobot();

  ResNotifySomeOneChangeRobot(const ResNotifySomeOneChangeRobot& from);

  inline ResNotifySomeOneChangeRobot& operator=(const ResNotifySomeOneChangeRobot& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResNotifySomeOneChangeRobot& default_instance();

  void Swap(ResNotifySomeOneChangeRobot* other);

  // implements Message ----------------------------------------------

  ResNotifySomeOneChangeRobot* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResNotifySomeOneChangeRobot& from);
  void MergeFrom(const ResNotifySomeOneChangeRobot& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 isRobot = 1;
  inline bool has_isrobot() const;
  inline void clear_isrobot();
  static const int kIsRobotFieldNumber = 1;
  inline ::google::protobuf::int32 isrobot() const;
  inline void set_isrobot(::google::protobuf::int32 value);

  // required string uniqueId = 2;
  inline bool has_uniqueid() const;
  inline void clear_uniqueid();
  static const int kUniqueIdFieldNumber = 2;
  inline const ::std::string& uniqueid() const;
  inline void set_uniqueid(const ::std::string& value);
  inline void set_uniqueid(const char* value);
  inline void set_uniqueid(const char* value, size_t size);
  inline ::std::string* mutable_uniqueid();
  inline ::std::string* release_uniqueid();
  inline void set_allocated_uniqueid(::std::string* uniqueid);

  // required int32 pos = 3;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 3;
  inline ::google::protobuf::int32 pos() const;
  inline void set_pos(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResNotifySomeOneChangeRobot)
 private:
  inline void set_has_isrobot();
  inline void clear_has_isrobot();
  inline void set_has_uniqueid();
  inline void clear_has_uniqueid();
  inline void set_has_pos();
  inline void clear_has_pos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uniqueid_;
  ::google::protobuf::int32 isrobot_;
  ::google::protobuf::int32 pos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ResNotifySomeOneChangeRobot* default_instance_;
};
// -------------------------------------------------------------------

class ResNotifyChangeToOldRoom : public ::google::protobuf::Message {
 public:
  ResNotifyChangeToOldRoom();
  virtual ~ResNotifyChangeToOldRoom();

  ResNotifyChangeToOldRoom(const ResNotifyChangeToOldRoom& from);

  inline ResNotifyChangeToOldRoom& operator=(const ResNotifyChangeToOldRoom& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResNotifyChangeToOldRoom& default_instance();

  void Swap(ResNotifyChangeToOldRoom* other);

  // implements Message ----------------------------------------------

  ResNotifyChangeToOldRoom* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResNotifyChangeToOldRoom& from);
  void MergeFrom(const ResNotifyChangeToOldRoom& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .ProtoNet.ServerInfoIpsSafeDetail bestServerInfo = 1;
  inline bool has_bestserverinfo() const;
  inline void clear_bestserverinfo();
  static const int kBestServerInfoFieldNumber = 1;
  inline const ::ProtoNet::ServerInfoIpsSafeDetail& bestserverinfo() const;
  inline ::ProtoNet::ServerInfoIpsSafeDetail* mutable_bestserverinfo();
  inline ::ProtoNet::ServerInfoIpsSafeDetail* release_bestserverinfo();
  inline void set_allocated_bestserverinfo(::ProtoNet::ServerInfoIpsSafeDetail* bestserverinfo);

  // optional string roomId = 2;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 2;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const char* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  inline void set_allocated_roomid(::std::string* roomid);

  // optional int32 gameId = 3;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 3;
  inline ::google::protobuf::int32 gameid() const;
  inline void set_gameid(::google::protobuf::int32 value);

  // optional int32 timesType = 4;
  inline bool has_timestype() const;
  inline void clear_timestype();
  static const int kTimesTypeFieldNumber = 4;
  inline ::google::protobuf::int32 timestype() const;
  inline void set_timestype(::google::protobuf::int32 value);

  // optional int32 roomType = 5;
  inline bool has_roomtype() const;
  inline void clear_roomtype();
  static const int kRoomTypeFieldNumber = 5;
  inline ::google::protobuf::int32 roomtype() const;
  inline void set_roomtype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResNotifyChangeToOldRoom)
 private:
  inline void set_has_bestserverinfo();
  inline void clear_has_bestserverinfo();
  inline void set_has_roomid();
  inline void clear_has_roomid();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_timestype();
  inline void clear_has_timestype();
  inline void set_has_roomtype();
  inline void clear_has_roomtype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoNet::ServerInfoIpsSafeDetail* bestserverinfo_;
  ::std::string* roomid_;
  ::google::protobuf::int32 gameid_;
  ::google::protobuf::int32 timestype_;
  ::google::protobuf::int32 roomtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ResNotifyChangeToOldRoom* default_instance_;
};
// -------------------------------------------------------------------

class ReqSitDown : public ::google::protobuf::Message {
 public:
  ReqSitDown();
  virtual ~ReqSitDown();

  ReqSitDown(const ReqSitDown& from);

  inline ReqSitDown& operator=(const ReqSitDown& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqSitDown& default_instance();

  void Swap(ReqSitDown* other);

  // implements Message ----------------------------------------------

  ReqSitDown* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqSitDown& from);
  void MergeFrom(const ReqSitDown& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 pos = 1;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 1;
  inline ::google::protobuf::int32 pos() const;
  inline void set_pos(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ProtoNet.ReqSitDown)
 private:
  inline void set_has_pos();
  inline void clear_has_pos();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 pos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ReqSitDown* default_instance_;
};
// -------------------------------------------------------------------

class ResSitDown : public ::google::protobuf::Message {
 public:
  ResSitDown();
  virtual ~ResSitDown();

  ResSitDown(const ResSitDown& from);

  inline ResSitDown& operator=(const ResSitDown& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResSitDown& default_instance();

  void Swap(ResSitDown* other);

  // implements Message ----------------------------------------------

  ResSitDown* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResSitDown& from);
  void MergeFrom(const ResSitDown& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoNet.ResponseResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::ProtoNet::ResponseResult& result() const;
  inline ::ProtoNet::ResponseResult* mutable_result();
  inline ::ProtoNet::ResponseResult* release_result();
  inline void set_allocated_result(::ProtoNet::ResponseResult* result);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResSitDown)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoNet::ResponseResult* result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ResSitDown* default_instance_;
};
// -------------------------------------------------------------------

class ResNotifySomeOneSitDown : public ::google::protobuf::Message {
 public:
  ResNotifySomeOneSitDown();
  virtual ~ResNotifySomeOneSitDown();

  ResNotifySomeOneSitDown(const ResNotifySomeOneSitDown& from);

  inline ResNotifySomeOneSitDown& operator=(const ResNotifySomeOneSitDown& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResNotifySomeOneSitDown& default_instance();

  void Swap(ResNotifySomeOneSitDown* other);

  // implements Message ----------------------------------------------

  ResNotifySomeOneSitDown* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResNotifySomeOneSitDown& from);
  void MergeFrom(const ResNotifySomeOneSitDown& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 pos = 1;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 1;
  inline ::google::protobuf::int32 pos() const;
  inline void set_pos(::google::protobuf::int32 value);

  // required .ProtoNet.SdkController controller = 2;
  inline bool has_controller() const;
  inline void clear_controller();
  static const int kControllerFieldNumber = 2;
  inline const ::ProtoNet::SdkController& controller() const;
  inline ::ProtoNet::SdkController* mutable_controller();
  inline ::ProtoNet::SdkController* release_controller();
  inline void set_allocated_controller(::ProtoNet::SdkController* controller);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResNotifySomeOneSitDown)
 private:
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_controller();
  inline void clear_has_controller();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoNet::SdkController* controller_;
  ::google::protobuf::int32 pos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ResNotifySomeOneSitDown* default_instance_;
};
// -------------------------------------------------------------------

class ReqStandUp : public ::google::protobuf::Message {
 public:
  ReqStandUp();
  virtual ~ReqStandUp();

  ReqStandUp(const ReqStandUp& from);

  inline ReqStandUp& operator=(const ReqStandUp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqStandUp& default_instance();

  void Swap(ReqStandUp* other);

  // implements Message ----------------------------------------------

  ReqStandUp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqStandUp& from);
  void MergeFrom(const ReqStandUp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ProtoNet.ReqStandUp)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ReqStandUp* default_instance_;
};
// -------------------------------------------------------------------

class ResStandUp : public ::google::protobuf::Message {
 public:
  ResStandUp();
  virtual ~ResStandUp();

  ResStandUp(const ResStandUp& from);

  inline ResStandUp& operator=(const ResStandUp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResStandUp& default_instance();

  void Swap(ResStandUp* other);

  // implements Message ----------------------------------------------

  ResStandUp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResStandUp& from);
  void MergeFrom(const ResStandUp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoNet.ResponseResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::ProtoNet::ResponseResult& result() const;
  inline ::ProtoNet::ResponseResult* mutable_result();
  inline ::ProtoNet::ResponseResult* release_result();
  inline void set_allocated_result(::ProtoNet::ResponseResult* result);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResStandUp)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoNet::ResponseResult* result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ResStandUp* default_instance_;
};
// -------------------------------------------------------------------

class ResNotifySomeOneStandUp : public ::google::protobuf::Message {
 public:
  ResNotifySomeOneStandUp();
  virtual ~ResNotifySomeOneStandUp();

  ResNotifySomeOneStandUp(const ResNotifySomeOneStandUp& from);

  inline ResNotifySomeOneStandUp& operator=(const ResNotifySomeOneStandUp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResNotifySomeOneStandUp& default_instance();

  void Swap(ResNotifySomeOneStandUp* other);

  // implements Message ----------------------------------------------

  ResNotifySomeOneStandUp* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResNotifySomeOneStandUp& from);
  void MergeFrom(const ResNotifySomeOneStandUp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 pos = 1;
  inline bool has_pos() const;
  inline void clear_pos();
  static const int kPosFieldNumber = 1;
  inline ::google::protobuf::int32 pos() const;
  inline void set_pos(::google::protobuf::int32 value);

  // required .ProtoNet.SdkController controller = 2;
  inline bool has_controller() const;
  inline void clear_controller();
  static const int kControllerFieldNumber = 2;
  inline const ::ProtoNet::SdkController& controller() const;
  inline ::ProtoNet::SdkController* mutable_controller();
  inline ::ProtoNet::SdkController* release_controller();
  inline void set_allocated_controller(::ProtoNet::SdkController* controller);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResNotifySomeOneStandUp)
 private:
  inline void set_has_pos();
  inline void clear_has_pos();
  inline void set_has_controller();
  inline void clear_has_controller();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoNet::SdkController* controller_;
  ::google::protobuf::int32 pos_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ResNotifySomeOneStandUp* default_instance_;
};
// -------------------------------------------------------------------

class ResNotifySomeOneEnterCharge : public ::google::protobuf::Message {
 public:
  ResNotifySomeOneEnterCharge();
  virtual ~ResNotifySomeOneEnterCharge();

  ResNotifySomeOneEnterCharge(const ResNotifySomeOneEnterCharge& from);

  inline ResNotifySomeOneEnterCharge& operator=(const ResNotifySomeOneEnterCharge& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResNotifySomeOneEnterCharge& default_instance();

  void Swap(ResNotifySomeOneEnterCharge* other);

  // implements Message ----------------------------------------------

  ResNotifySomeOneEnterCharge* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResNotifySomeOneEnterCharge& from);
  void MergeFrom(const ResNotifySomeOneEnterCharge& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string uniqueIds = 1;
  inline bool has_uniqueids() const;
  inline void clear_uniqueids();
  static const int kUniqueIdsFieldNumber = 1;
  inline const ::std::string& uniqueids() const;
  inline void set_uniqueids(const ::std::string& value);
  inline void set_uniqueids(const char* value);
  inline void set_uniqueids(const char* value, size_t size);
  inline ::std::string* mutable_uniqueids();
  inline ::std::string* release_uniqueids();
  inline void set_allocated_uniqueids(::std::string* uniqueids);

  // required int32 rechargeTime = 2;
  inline bool has_rechargetime() const;
  inline void clear_rechargetime();
  static const int kRechargeTimeFieldNumber = 2;
  inline ::google::protobuf::int32 rechargetime() const;
  inline void set_rechargetime(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResNotifySomeOneEnterCharge)
 private:
  inline void set_has_uniqueids();
  inline void clear_has_uniqueids();
  inline void set_has_rechargetime();
  inline void clear_has_rechargetime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uniqueids_;
  ::google::protobuf::int32 rechargetime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ResNotifySomeOneEnterCharge* default_instance_;
};
// -------------------------------------------------------------------

class ResNotifyAccountsChange : public ::google::protobuf::Message {
 public:
  ResNotifyAccountsChange();
  virtual ~ResNotifyAccountsChange();

  ResNotifyAccountsChange(const ResNotifyAccountsChange& from);

  inline ResNotifyAccountsChange& operator=(const ResNotifyAccountsChange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResNotifyAccountsChange& default_instance();

  void Swap(ResNotifyAccountsChange* other);

  // implements Message ----------------------------------------------

  ResNotifyAccountsChange* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResNotifyAccountsChange& from);
  void MergeFrom(const ResNotifyAccountsChange& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string uniqueId = 1;
  inline bool has_uniqueid() const;
  inline void clear_uniqueid();
  static const int kUniqueIdFieldNumber = 1;
  inline const ::std::string& uniqueid() const;
  inline void set_uniqueid(const ::std::string& value);
  inline void set_uniqueid(const char* value);
  inline void set_uniqueid(const char* value, size_t size);
  inline ::std::string* mutable_uniqueid();
  inline ::std::string* release_uniqueid();
  inline void set_allocated_uniqueid(::std::string* uniqueid);

  // repeated .ProtoNet.PlayerAccount counts = 2;
  inline int counts_size() const;
  inline void clear_counts();
  static const int kCountsFieldNumber = 2;
  inline const ::ProtoNet::PlayerAccount& counts(int index) const;
  inline ::ProtoNet::PlayerAccount* mutable_counts(int index);
  inline ::ProtoNet::PlayerAccount* add_counts();
  inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::PlayerAccount >&
      counts() const;
  inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::PlayerAccount >*
      mutable_counts();

  // optional string extendStr = 3;
  inline bool has_extendstr() const;
  inline void clear_extendstr();
  static const int kExtendStrFieldNumber = 3;
  inline const ::std::string& extendstr() const;
  inline void set_extendstr(const ::std::string& value);
  inline void set_extendstr(const char* value);
  inline void set_extendstr(const char* value, size_t size);
  inline ::std::string* mutable_extendstr();
  inline ::std::string* release_extendstr();
  inline void set_allocated_extendstr(::std::string* extendstr);

  // optional int32 charge = 4;
  inline bool has_charge() const;
  inline void clear_charge();
  static const int kChargeFieldNumber = 4;
  inline ::google::protobuf::int32 charge() const;
  inline void set_charge(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResNotifyAccountsChange)
 private:
  inline void set_has_uniqueid();
  inline void clear_has_uniqueid();
  inline void set_has_extendstr();
  inline void clear_has_extendstr();
  inline void set_has_charge();
  inline void clear_has_charge();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uniqueid_;
  ::google::protobuf::RepeatedPtrField< ::ProtoNet::PlayerAccount > counts_;
  ::std::string* extendstr_;
  ::google::protobuf::int32 charge_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ResNotifyAccountsChange* default_instance_;
};
// -------------------------------------------------------------------

class ResNotifyChargeOver : public ::google::protobuf::Message {
 public:
  ResNotifyChargeOver();
  virtual ~ResNotifyChargeOver();

  ResNotifyChargeOver(const ResNotifyChargeOver& from);

  inline ResNotifyChargeOver& operator=(const ResNotifyChargeOver& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResNotifyChargeOver& default_instance();

  void Swap(ResNotifyChargeOver* other);

  // implements Message ----------------------------------------------

  ResNotifyChargeOver* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResNotifyChargeOver& from);
  void MergeFrom(const ResNotifyChargeOver& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string uniqueId = 1;
  inline bool has_uniqueid() const;
  inline void clear_uniqueid();
  static const int kUniqueIdFieldNumber = 1;
  inline const ::std::string& uniqueid() const;
  inline void set_uniqueid(const ::std::string& value);
  inline void set_uniqueid(const char* value);
  inline void set_uniqueid(const char* value, size_t size);
  inline ::std::string* mutable_uniqueid();
  inline ::std::string* release_uniqueid();
  inline void set_allocated_uniqueid(::std::string* uniqueid);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResNotifyChargeOver)
 private:
  inline void set_has_uniqueid();
  inline void clear_has_uniqueid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* uniqueid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ResNotifyChargeOver* default_instance_;
};
// -------------------------------------------------------------------

class ReqWatherList : public ::google::protobuf::Message {
 public:
  ReqWatherList();
  virtual ~ReqWatherList();

  ReqWatherList(const ReqWatherList& from);

  inline ReqWatherList& operator=(const ReqWatherList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqWatherList& default_instance();

  void Swap(ReqWatherList* other);

  // implements Message ----------------------------------------------

  ReqWatherList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqWatherList& from);
  void MergeFrom(const ReqWatherList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 length = 1;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 1;
  inline ::google::protobuf::int32 length() const;
  inline void set_length(::google::protobuf::int32 value);

  // required int32 paixu = 2;
  inline bool has_paixu() const;
  inline void clear_paixu();
  static const int kPaixuFieldNumber = 2;
  inline ::google::protobuf::int32 paixu() const;
  inline void set_paixu(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ProtoNet.ReqWatherList)
 private:
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_paixu();
  inline void clear_has_paixu();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 length_;
  ::google::protobuf::int32 paixu_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ReqWatherList* default_instance_;
};
// -------------------------------------------------------------------

class ResWatherList : public ::google::protobuf::Message {
 public:
  ResWatherList();
  virtual ~ResWatherList();

  ResWatherList(const ResWatherList& from);

  inline ResWatherList& operator=(const ResWatherList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResWatherList& default_instance();

  void Swap(ResWatherList* other);

  // implements Message ----------------------------------------------

  ResWatherList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResWatherList& from);
  void MergeFrom(const ResWatherList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoNet.ResponseResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::ProtoNet::ResponseResult& result() const;
  inline ::ProtoNet::ResponseResult* mutable_result();
  inline ::ProtoNet::ResponseResult* release_result();
  inline void set_allocated_result(::ProtoNet::ResponseResult* result);

  // repeated .ProtoNet.SdkController sdkControllers = 2;
  inline int sdkcontrollers_size() const;
  inline void clear_sdkcontrollers();
  static const int kSdkControllersFieldNumber = 2;
  inline const ::ProtoNet::SdkController& sdkcontrollers(int index) const;
  inline ::ProtoNet::SdkController* mutable_sdkcontrollers(int index);
  inline ::ProtoNet::SdkController* add_sdkcontrollers();
  inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::SdkController >&
      sdkcontrollers() const;
  inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::SdkController >*
      mutable_sdkcontrollers();

  // @@protoc_insertion_point(class_scope:ProtoNet.ResWatherList)
 private:
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoNet::ResponseResult* result_;
  ::google::protobuf::RepeatedPtrField< ::ProtoNet::SdkController > sdkcontrollers_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ResWatherList* default_instance_;
};
// -------------------------------------------------------------------

class ReqOnceMore : public ::google::protobuf::Message {
 public:
  ReqOnceMore();
  virtual ~ReqOnceMore();

  ReqOnceMore(const ReqOnceMore& from);

  inline ReqOnceMore& operator=(const ReqOnceMore& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqOnceMore& default_instance();

  void Swap(ReqOnceMore* other);

  // implements Message ----------------------------------------------

  ReqOnceMore* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqOnceMore& from);
  void MergeFrom(const ReqOnceMore& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ProtoNet.ReqOnceMore)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ReqOnceMore* default_instance_;
};
// -------------------------------------------------------------------

class ResOnceMore : public ::google::protobuf::Message {
 public:
  ResOnceMore();
  virtual ~ResOnceMore();

  ResOnceMore(const ResOnceMore& from);

  inline ResOnceMore& operator=(const ResOnceMore& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResOnceMore& default_instance();

  void Swap(ResOnceMore* other);

  // implements Message ----------------------------------------------

  ResOnceMore* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResOnceMore& from);
  void MergeFrom(const ResOnceMore& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoNet.ResponseResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::ProtoNet::ResponseResult& result() const;
  inline ::ProtoNet::ResponseResult* mutable_result();
  inline ::ProtoNet::ResponseResult* release_result();
  inline void set_allocated_result(::ProtoNet::ResponseResult* result);

  // required int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required string roomId = 3;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 3;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const char* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  inline void set_allocated_roomid(::std::string* roomid);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResOnceMore)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_roomid();
  inline void clear_has_roomid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoNet::ResponseResult* result_;
  ::std::string* roomid_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ResOnceMore* default_instance_;
};
// -------------------------------------------------------------------

class ResNotifyOnceMore : public ::google::protobuf::Message {
 public:
  ResNotifyOnceMore();
  virtual ~ResNotifyOnceMore();

  ResNotifyOnceMore(const ResNotifyOnceMore& from);

  inline ResNotifyOnceMore& operator=(const ResNotifyOnceMore& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ResNotifyOnceMore& default_instance();

  void Swap(ResNotifyOnceMore* other);

  // implements Message ----------------------------------------------

  ResNotifyOnceMore* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResNotifyOnceMore& from);
  void MergeFrom(const ResNotifyOnceMore& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoNet.ResponseResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::ProtoNet::ResponseResult& result() const;
  inline ::ProtoNet::ResponseResult* mutable_result();
  inline ::ProtoNet::ResponseResult* release_result();
  inline void set_allocated_result(::ProtoNet::ResponseResult* result);

  // required int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required string roomId = 3;
  inline bool has_roomid() const;
  inline void clear_roomid();
  static const int kRoomIdFieldNumber = 3;
  inline const ::std::string& roomid() const;
  inline void set_roomid(const ::std::string& value);
  inline void set_roomid(const char* value);
  inline void set_roomid(const char* value, size_t size);
  inline ::std::string* mutable_roomid();
  inline ::std::string* release_roomid();
  inline void set_allocated_roomid(::std::string* roomid);

  // @@protoc_insertion_point(class_scope:ProtoNet.ResNotifyOnceMore)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_roomid();
  inline void clear_has_roomid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoNet::ResponseResult* result_;
  ::std::string* roomid_;
  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static ResNotifyOnceMore* default_instance_;
};
// -------------------------------------------------------------------

class reqLogicServerTime : public ::google::protobuf::Message {
 public:
  reqLogicServerTime();
  virtual ~reqLogicServerTime();

  reqLogicServerTime(const reqLogicServerTime& from);

  inline reqLogicServerTime& operator=(const reqLogicServerTime& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const reqLogicServerTime& default_instance();

  void Swap(reqLogicServerTime* other);

  // implements Message ----------------------------------------------

  reqLogicServerTime* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const reqLogicServerTime& from);
  void MergeFrom(const reqLogicServerTime& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:ProtoNet.reqLogicServerTime)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static reqLogicServerTime* default_instance_;
};
// -------------------------------------------------------------------

class resLogicServerTime : public ::google::protobuf::Message {
 public:
  resLogicServerTime();
  virtual ~resLogicServerTime();

  resLogicServerTime(const resLogicServerTime& from);

  inline resLogicServerTime& operator=(const resLogicServerTime& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const resLogicServerTime& default_instance();

  void Swap(resLogicServerTime* other);

  // implements Message ----------------------------------------------

  resLogicServerTime* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const resLogicServerTime& from);
  void MergeFrom(const resLogicServerTime& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .ProtoNet.ResponseResult result = 1;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 1;
  inline const ::ProtoNet::ResponseResult& result() const;
  inline ::ProtoNet::ResponseResult* mutable_result();
  inline ::ProtoNet::ResponseResult* release_result();
  inline void set_allocated_result(::ProtoNet::ResponseResult* result);

  // optional int64 serverTime = 2;
  inline bool has_servertime() const;
  inline void clear_servertime();
  static const int kServerTimeFieldNumber = 2;
  inline ::google::protobuf::int64 servertime() const;
  inline void set_servertime(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:ProtoNet.resLogicServerTime)
 private:
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_servertime();
  inline void clear_has_servertime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::ProtoNet::ResponseResult* result_;
  ::google::protobuf::int64 servertime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_MsgLogic_2eproto();
  friend void protobuf_AssignDesc_MsgLogic_2eproto();
  friend void protobuf_ShutdownFile_MsgLogic_2eproto();

  void InitAsDefaultInstance();
  static resLogicServerTime* default_instance_;
};
// ===================================================================


// ===================================================================

// SdkController

// required string uniqueId = 1;
inline bool SdkController::has_uniqueid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SdkController::set_has_uniqueid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SdkController::clear_has_uniqueid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SdkController::clear_uniqueid() {
  if (uniqueid_ != &::google::protobuf::internal::kEmptyString) {
    uniqueid_->clear();
  }
  clear_has_uniqueid();
}
inline const ::std::string& SdkController::uniqueid() const {
  return *uniqueid_;
}
inline void SdkController::set_uniqueid(const ::std::string& value) {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  uniqueid_->assign(value);
}
inline void SdkController::set_uniqueid(const char* value) {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  uniqueid_->assign(value);
}
inline void SdkController::set_uniqueid(const char* value, size_t size) {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  uniqueid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SdkController::mutable_uniqueid() {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  return uniqueid_;
}
inline ::std::string* SdkController::release_uniqueid() {
  clear_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uniqueid_;
    uniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SdkController::set_allocated_uniqueid(::std::string* uniqueid) {
  if (uniqueid_ != &::google::protobuf::internal::kEmptyString) {
    delete uniqueid_;
  }
  if (uniqueid) {
    set_has_uniqueid();
    uniqueid_ = uniqueid;
  } else {
    clear_has_uniqueid();
    uniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string nickName = 2;
inline bool SdkController::has_nickname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SdkController::set_has_nickname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SdkController::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SdkController::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& SdkController::nickname() const {
  return *nickname_;
}
inline void SdkController::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void SdkController::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void SdkController::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SdkController::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* SdkController::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SdkController::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string headImg = 3;
inline bool SdkController::has_headimg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SdkController::set_has_headimg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SdkController::clear_has_headimg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SdkController::clear_headimg() {
  if (headimg_ != &::google::protobuf::internal::kEmptyString) {
    headimg_->clear();
  }
  clear_has_headimg();
}
inline const ::std::string& SdkController::headimg() const {
  return *headimg_;
}
inline void SdkController::set_headimg(const ::std::string& value) {
  set_has_headimg();
  if (headimg_ == &::google::protobuf::internal::kEmptyString) {
    headimg_ = new ::std::string;
  }
  headimg_->assign(value);
}
inline void SdkController::set_headimg(const char* value) {
  set_has_headimg();
  if (headimg_ == &::google::protobuf::internal::kEmptyString) {
    headimg_ = new ::std::string;
  }
  headimg_->assign(value);
}
inline void SdkController::set_headimg(const char* value, size_t size) {
  set_has_headimg();
  if (headimg_ == &::google::protobuf::internal::kEmptyString) {
    headimg_ = new ::std::string;
  }
  headimg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SdkController::mutable_headimg() {
  set_has_headimg();
  if (headimg_ == &::google::protobuf::internal::kEmptyString) {
    headimg_ = new ::std::string;
  }
  return headimg_;
}
inline ::std::string* SdkController::release_headimg() {
  clear_has_headimg();
  if (headimg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = headimg_;
    headimg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SdkController::set_allocated_headimg(::std::string* headimg) {
  if (headimg_ != &::google::protobuf::internal::kEmptyString) {
    delete headimg_;
  }
  if (headimg) {
    set_has_headimg();
    headimg_ = headimg;
  } else {
    clear_has_headimg();
    headimg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string ip = 4;
inline bool SdkController::has_ip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SdkController::set_has_ip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SdkController::clear_has_ip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SdkController::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& SdkController::ip() const {
  return *ip_;
}
inline void SdkController::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void SdkController::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void SdkController::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SdkController::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* SdkController::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SdkController::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 headType = 5;
inline bool SdkController::has_headtype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SdkController::set_has_headtype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SdkController::clear_has_headtype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SdkController::clear_headtype() {
  headtype_ = 0;
  clear_has_headtype();
}
inline ::google::protobuf::int32 SdkController::headtype() const {
  return headtype_;
}
inline void SdkController::set_headtype(::google::protobuf::int32 value) {
  set_has_headtype();
  headtype_ = value;
}

// required double health = 6;
inline bool SdkController::has_health() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SdkController::set_has_health() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SdkController::clear_has_health() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SdkController::clear_health() {
  health_ = 0;
  clear_has_health();
}
inline double SdkController::health() const {
  return health_;
}
inline void SdkController::set_health(double value) {
  set_has_health();
  health_ = value;
}

// required int32 sex = 7;
inline bool SdkController::has_sex() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SdkController::set_has_sex() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SdkController::clear_has_sex() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SdkController::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::google::protobuf::int32 SdkController::sex() const {
  return sex_;
}
inline void SdkController::set_sex(::google::protobuf::int32 value) {
  set_has_sex();
  sex_ = value;
}

// optional int32 selfRank = 8;
inline bool SdkController::has_selfrank() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SdkController::set_has_selfrank() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SdkController::clear_has_selfrank() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SdkController::clear_selfrank() {
  selfrank_ = 0;
  clear_has_selfrank();
}
inline ::google::protobuf::int32 SdkController::selfrank() const {
  return selfrank_;
}
inline void SdkController::set_selfrank(::google::protobuf::int32 value) {
  set_has_selfrank();
  selfrank_ = value;
}

// optional int32 robot = 9;
inline bool SdkController::has_robot() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SdkController::set_has_robot() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SdkController::clear_has_robot() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SdkController::clear_robot() {
  robot_ = 0;
  clear_has_robot();
}
inline ::google::protobuf::int32 SdkController::robot() const {
  return robot_;
}
inline void SdkController::set_robot(::google::protobuf::int32 value) {
  set_has_robot();
  robot_ = value;
}

// optional int32 watcher = 10;
inline bool SdkController::has_watcher() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SdkController::set_has_watcher() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SdkController::clear_has_watcher() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SdkController::clear_watcher() {
  watcher_ = 0;
  clear_has_watcher();
}
inline ::google::protobuf::int32 SdkController::watcher() const {
  return watcher_;
}
inline void SdkController::set_watcher(::google::protobuf::int32 value) {
  set_has_watcher();
  watcher_ = value;
}

// optional int32 lv = 11;
inline bool SdkController::has_lv() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SdkController::set_has_lv() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SdkController::clear_has_lv() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SdkController::clear_lv() {
  lv_ = 0;
  clear_has_lv();
}
inline ::google::protobuf::int32 SdkController::lv() const {
  return lv_;
}
inline void SdkController::set_lv(::google::protobuf::int32 value) {
  set_has_lv();
  lv_ = value;
}

// optional string extendStr = 12;
inline bool SdkController::has_extendstr() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SdkController::set_has_extendstr() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SdkController::clear_has_extendstr() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SdkController::clear_extendstr() {
  if (extendstr_ != &::google::protobuf::internal::kEmptyString) {
    extendstr_->clear();
  }
  clear_has_extendstr();
}
inline const ::std::string& SdkController::extendstr() const {
  return *extendstr_;
}
inline void SdkController::set_extendstr(const ::std::string& value) {
  set_has_extendstr();
  if (extendstr_ == &::google::protobuf::internal::kEmptyString) {
    extendstr_ = new ::std::string;
  }
  extendstr_->assign(value);
}
inline void SdkController::set_extendstr(const char* value) {
  set_has_extendstr();
  if (extendstr_ == &::google::protobuf::internal::kEmptyString) {
    extendstr_ = new ::std::string;
  }
  extendstr_->assign(value);
}
inline void SdkController::set_extendstr(const char* value, size_t size) {
  set_has_extendstr();
  if (extendstr_ == &::google::protobuf::internal::kEmptyString) {
    extendstr_ = new ::std::string;
  }
  extendstr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SdkController::mutable_extendstr() {
  set_has_extendstr();
  if (extendstr_ == &::google::protobuf::internal::kEmptyString) {
    extendstr_ = new ::std::string;
  }
  return extendstr_;
}
inline ::std::string* SdkController::release_extendstr() {
  clear_has_extendstr();
  if (extendstr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extendstr_;
    extendstr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SdkController::set_allocated_extendstr(::std::string* extendstr) {
  if (extendstr_ != &::google::protobuf::internal::kEmptyString) {
    delete extendstr_;
  }
  if (extendstr) {
    set_has_extendstr();
    extendstr_ = extendstr;
  } else {
    clear_has_extendstr();
    extendstr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PosBrife

// required int32 pos = 1;
inline bool PosBrife::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PosBrife::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PosBrife::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PosBrife::clear_pos() {
  pos_ = 0;
  clear_has_pos();
}
inline ::google::protobuf::int32 PosBrife::pos() const {
  return pos_;
}
inline void PosBrife::set_pos(::google::protobuf::int32 value) {
  set_has_pos();
  pos_ = value;
}

// optional string controllerUniqueId = 2;
inline bool PosBrife::has_controlleruniqueid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PosBrife::set_has_controlleruniqueid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PosBrife::clear_has_controlleruniqueid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PosBrife::clear_controlleruniqueid() {
  if (controlleruniqueid_ != &::google::protobuf::internal::kEmptyString) {
    controlleruniqueid_->clear();
  }
  clear_has_controlleruniqueid();
}
inline const ::std::string& PosBrife::controlleruniqueid() const {
  return *controlleruniqueid_;
}
inline void PosBrife::set_controlleruniqueid(const ::std::string& value) {
  set_has_controlleruniqueid();
  if (controlleruniqueid_ == &::google::protobuf::internal::kEmptyString) {
    controlleruniqueid_ = new ::std::string;
  }
  controlleruniqueid_->assign(value);
}
inline void PosBrife::set_controlleruniqueid(const char* value) {
  set_has_controlleruniqueid();
  if (controlleruniqueid_ == &::google::protobuf::internal::kEmptyString) {
    controlleruniqueid_ = new ::std::string;
  }
  controlleruniqueid_->assign(value);
}
inline void PosBrife::set_controlleruniqueid(const char* value, size_t size) {
  set_has_controlleruniqueid();
  if (controlleruniqueid_ == &::google::protobuf::internal::kEmptyString) {
    controlleruniqueid_ = new ::std::string;
  }
  controlleruniqueid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PosBrife::mutable_controlleruniqueid() {
  set_has_controlleruniqueid();
  if (controlleruniqueid_ == &::google::protobuf::internal::kEmptyString) {
    controlleruniqueid_ = new ::std::string;
  }
  return controlleruniqueid_;
}
inline ::std::string* PosBrife::release_controlleruniqueid() {
  clear_has_controlleruniqueid();
  if (controlleruniqueid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = controlleruniqueid_;
    controlleruniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PosBrife::set_allocated_controlleruniqueid(::std::string* controlleruniqueid) {
  if (controlleruniqueid_ != &::google::protobuf::internal::kEmptyString) {
    delete controlleruniqueid_;
  }
  if (controlleruniqueid) {
    set_has_controlleruniqueid();
    controlleruniqueid_ = controlleruniqueid;
  } else {
    clear_has_controlleruniqueid();
    controlleruniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 online = 3;
inline bool PosBrife::has_online() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PosBrife::set_has_online() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PosBrife::clear_has_online() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PosBrife::clear_online() {
  online_ = 0;
  clear_has_online();
}
inline ::google::protobuf::int32 PosBrife::online() const {
  return online_;
}
inline void PosBrife::set_online(::google::protobuf::int32 value) {
  set_has_online();
  online_ = value;
}

// optional int32 ready = 4;
inline bool PosBrife::has_ready() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PosBrife::set_has_ready() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PosBrife::clear_has_ready() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PosBrife::clear_ready() {
  ready_ = 0;
  clear_has_ready();
}
inline ::google::protobuf::int32 PosBrife::ready() const {
  return ready_;
}
inline void PosBrife::set_ready(::google::protobuf::int32 value) {
  set_has_ready();
  ready_ = value;
}

// -------------------------------------------------------------------

// RoomInfo

// required string roomId = 1;
inline bool RoomInfo::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomInfo::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomInfo::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomInfo::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& RoomInfo::roomid() const {
  return *roomid_;
}
inline void RoomInfo::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void RoomInfo::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void RoomInfo::set_roomid(const char* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomInfo::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  return roomid_;
}
inline ::std::string* RoomInfo::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomInfo::set_allocated_roomid(::std::string* roomid) {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomid_;
  }
  if (roomid) {
    set_has_roomid();
    roomid_ = roomid;
  } else {
    clear_has_roomid();
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string roomName = 2;
inline bool RoomInfo::has_roomname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomInfo::set_has_roomname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomInfo::clear_has_roomname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomInfo::clear_roomname() {
  if (roomname_ != &::google::protobuf::internal::kEmptyString) {
    roomname_->clear();
  }
  clear_has_roomname();
}
inline const ::std::string& RoomInfo::roomname() const {
  return *roomname_;
}
inline void RoomInfo::set_roomname(const ::std::string& value) {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    roomname_ = new ::std::string;
  }
  roomname_->assign(value);
}
inline void RoomInfo::set_roomname(const char* value) {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    roomname_ = new ::std::string;
  }
  roomname_->assign(value);
}
inline void RoomInfo::set_roomname(const char* value, size_t size) {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    roomname_ = new ::std::string;
  }
  roomname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomInfo::mutable_roomname() {
  set_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    roomname_ = new ::std::string;
  }
  return roomname_;
}
inline ::std::string* RoomInfo::release_roomname() {
  clear_has_roomname();
  if (roomname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomname_;
    roomname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomInfo::set_allocated_roomname(::std::string* roomname) {
  if (roomname_ != &::google::protobuf::internal::kEmptyString) {
    delete roomname_;
  }
  if (roomname) {
    set_has_roomname();
    roomname_ = roomname;
  } else {
    clear_has_roomname();
    roomname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string roomerUniqueId = 3;
inline bool RoomInfo::has_roomeruniqueid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoomInfo::set_has_roomeruniqueid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoomInfo::clear_has_roomeruniqueid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoomInfo::clear_roomeruniqueid() {
  if (roomeruniqueid_ != &::google::protobuf::internal::kEmptyString) {
    roomeruniqueid_->clear();
  }
  clear_has_roomeruniqueid();
}
inline const ::std::string& RoomInfo::roomeruniqueid() const {
  return *roomeruniqueid_;
}
inline void RoomInfo::set_roomeruniqueid(const ::std::string& value) {
  set_has_roomeruniqueid();
  if (roomeruniqueid_ == &::google::protobuf::internal::kEmptyString) {
    roomeruniqueid_ = new ::std::string;
  }
  roomeruniqueid_->assign(value);
}
inline void RoomInfo::set_roomeruniqueid(const char* value) {
  set_has_roomeruniqueid();
  if (roomeruniqueid_ == &::google::protobuf::internal::kEmptyString) {
    roomeruniqueid_ = new ::std::string;
  }
  roomeruniqueid_->assign(value);
}
inline void RoomInfo::set_roomeruniqueid(const char* value, size_t size) {
  set_has_roomeruniqueid();
  if (roomeruniqueid_ == &::google::protobuf::internal::kEmptyString) {
    roomeruniqueid_ = new ::std::string;
  }
  roomeruniqueid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomInfo::mutable_roomeruniqueid() {
  set_has_roomeruniqueid();
  if (roomeruniqueid_ == &::google::protobuf::internal::kEmptyString) {
    roomeruniqueid_ = new ::std::string;
  }
  return roomeruniqueid_;
}
inline ::std::string* RoomInfo::release_roomeruniqueid() {
  clear_has_roomeruniqueid();
  if (roomeruniqueid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomeruniqueid_;
    roomeruniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomInfo::set_allocated_roomeruniqueid(::std::string* roomeruniqueid) {
  if (roomeruniqueid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomeruniqueid_;
  }
  if (roomeruniqueid) {
    set_has_roomeruniqueid();
    roomeruniqueid_ = roomeruniqueid;
  } else {
    clear_has_roomeruniqueid();
    roomeruniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .ProtoNet.SdkController controllers = 4;
inline int RoomInfo::controllers_size() const {
  return controllers_.size();
}
inline void RoomInfo::clear_controllers() {
  controllers_.Clear();
}
inline const ::ProtoNet::SdkController& RoomInfo::controllers(int index) const {
  return controllers_.Get(index);
}
inline ::ProtoNet::SdkController* RoomInfo::mutable_controllers(int index) {
  return controllers_.Mutable(index);
}
inline ::ProtoNet::SdkController* RoomInfo::add_controllers() {
  return controllers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::SdkController >&
RoomInfo::controllers() const {
  return controllers_;
}
inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::SdkController >*
RoomInfo::mutable_controllers() {
  return &controllers_;
}

// optional string extendStr = 5;
inline bool RoomInfo::has_extendstr() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RoomInfo::set_has_extendstr() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RoomInfo::clear_has_extendstr() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RoomInfo::clear_extendstr() {
  if (extendstr_ != &::google::protobuf::internal::kEmptyString) {
    extendstr_->clear();
  }
  clear_has_extendstr();
}
inline const ::std::string& RoomInfo::extendstr() const {
  return *extendstr_;
}
inline void RoomInfo::set_extendstr(const ::std::string& value) {
  set_has_extendstr();
  if (extendstr_ == &::google::protobuf::internal::kEmptyString) {
    extendstr_ = new ::std::string;
  }
  extendstr_->assign(value);
}
inline void RoomInfo::set_extendstr(const char* value) {
  set_has_extendstr();
  if (extendstr_ == &::google::protobuf::internal::kEmptyString) {
    extendstr_ = new ::std::string;
  }
  extendstr_->assign(value);
}
inline void RoomInfo::set_extendstr(const char* value, size_t size) {
  set_has_extendstr();
  if (extendstr_ == &::google::protobuf::internal::kEmptyString) {
    extendstr_ = new ::std::string;
  }
  extendstr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomInfo::mutable_extendstr() {
  set_has_extendstr();
  if (extendstr_ == &::google::protobuf::internal::kEmptyString) {
    extendstr_ = new ::std::string;
  }
  return extendstr_;
}
inline ::std::string* RoomInfo::release_extendstr() {
  clear_has_extendstr();
  if (extendstr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extendstr_;
    extendstr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomInfo::set_allocated_extendstr(::std::string* extendstr) {
  if (extendstr_ != &::google::protobuf::internal::kEmptyString) {
    delete extendstr_;
  }
  if (extendstr) {
    set_has_extendstr();
    extendstr_ = extendstr;
  } else {
    clear_has_extendstr();
    extendstr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 roomStatus = 6;
inline bool RoomInfo::has_roomstatus() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RoomInfo::set_has_roomstatus() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RoomInfo::clear_has_roomstatus() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RoomInfo::clear_roomstatus() {
  roomstatus_ = 0;
  clear_has_roomstatus();
}
inline ::google::protobuf::int32 RoomInfo::roomstatus() const {
  return roomstatus_;
}
inline void RoomInfo::set_roomstatus(::google::protobuf::int32 value) {
  set_has_roomstatus();
  roomstatus_ = value;
}

// repeated .ProtoNet.PosBrife posBrifes = 7;
inline int RoomInfo::posbrifes_size() const {
  return posbrifes_.size();
}
inline void RoomInfo::clear_posbrifes() {
  posbrifes_.Clear();
}
inline const ::ProtoNet::PosBrife& RoomInfo::posbrifes(int index) const {
  return posbrifes_.Get(index);
}
inline ::ProtoNet::PosBrife* RoomInfo::mutable_posbrifes(int index) {
  return posbrifes_.Mutable(index);
}
inline ::ProtoNet::PosBrife* RoomInfo::add_posbrifes() {
  return posbrifes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::PosBrife >&
RoomInfo::posbrifes() const {
  return posbrifes_;
}
inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::PosBrife >*
RoomInfo::mutable_posbrifes() {
  return &posbrifes_;
}

// required int32 leftMatchCount = 8;
inline bool RoomInfo::has_leftmatchcount() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RoomInfo::set_has_leftmatchcount() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RoomInfo::clear_has_leftmatchcount() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RoomInfo::clear_leftmatchcount() {
  leftmatchcount_ = 0;
  clear_has_leftmatchcount();
}
inline ::google::protobuf::int32 RoomInfo::leftmatchcount() const {
  return leftmatchcount_;
}
inline void RoomInfo::set_leftmatchcount(::google::protobuf::int32 value) {
  set_has_leftmatchcount();
  leftmatchcount_ = value;
}

// required int32 totalCount = 9;
inline bool RoomInfo::has_totalcount() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RoomInfo::set_has_totalcount() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RoomInfo::clear_has_totalcount() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RoomInfo::clear_totalcount() {
  totalcount_ = 0;
  clear_has_totalcount();
}
inline ::google::protobuf::int32 RoomInfo::totalcount() const {
  return totalcount_;
}
inline void RoomInfo::set_totalcount(::google::protobuf::int32 value) {
  set_has_totalcount();
  totalcount_ = value;
}

// required .ProtoNet.DissolutionStatus dissolutionStatus = 10;
inline bool RoomInfo::has_dissolutionstatus() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void RoomInfo::set_has_dissolutionstatus() {
  _has_bits_[0] |= 0x00000200u;
}
inline void RoomInfo::clear_has_dissolutionstatus() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void RoomInfo::clear_dissolutionstatus() {
  if (dissolutionstatus_ != NULL) dissolutionstatus_->::ProtoNet::DissolutionStatus::Clear();
  clear_has_dissolutionstatus();
}
inline const ::ProtoNet::DissolutionStatus& RoomInfo::dissolutionstatus() const {
  return dissolutionstatus_ != NULL ? *dissolutionstatus_ : *default_instance_->dissolutionstatus_;
}
inline ::ProtoNet::DissolutionStatus* RoomInfo::mutable_dissolutionstatus() {
  set_has_dissolutionstatus();
  if (dissolutionstatus_ == NULL) dissolutionstatus_ = new ::ProtoNet::DissolutionStatus;
  return dissolutionstatus_;
}
inline ::ProtoNet::DissolutionStatus* RoomInfo::release_dissolutionstatus() {
  clear_has_dissolutionstatus();
  ::ProtoNet::DissolutionStatus* temp = dissolutionstatus_;
  dissolutionstatus_ = NULL;
  return temp;
}
inline void RoomInfo::set_allocated_dissolutionstatus(::ProtoNet::DissolutionStatus* dissolutionstatus) {
  delete dissolutionstatus_;
  dissolutionstatus_ = dissolutionstatus;
  if (dissolutionstatus) {
    set_has_dissolutionstatus();
  } else {
    clear_has_dissolutionstatus();
  }
}

// required int32 maxPlayerNum = 11;
inline bool RoomInfo::has_maxplayernum() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void RoomInfo::set_has_maxplayernum() {
  _has_bits_[0] |= 0x00000400u;
}
inline void RoomInfo::clear_has_maxplayernum() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void RoomInfo::clear_maxplayernum() {
  maxplayernum_ = 0;
  clear_has_maxplayernum();
}
inline ::google::protobuf::int32 RoomInfo::maxplayernum() const {
  return maxplayernum_;
}
inline void RoomInfo::set_maxplayernum(::google::protobuf::int32 value) {
  set_has_maxplayernum();
  maxplayernum_ = value;
}

// required int32 currentPlayerNum = 12;
inline bool RoomInfo::has_currentplayernum() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void RoomInfo::set_has_currentplayernum() {
  _has_bits_[0] |= 0x00000800u;
}
inline void RoomInfo::clear_has_currentplayernum() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void RoomInfo::clear_currentplayernum() {
  currentplayernum_ = 0;
  clear_has_currentplayernum();
}
inline ::google::protobuf::int32 RoomInfo::currentplayernum() const {
  return currentplayernum_;
}
inline void RoomInfo::set_currentplayernum(::google::protobuf::int32 value) {
  set_has_currentplayernum();
  currentplayernum_ = value;
}

// optional int64 readyTimer = 13;
inline bool RoomInfo::has_readytimer() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void RoomInfo::set_has_readytimer() {
  _has_bits_[0] |= 0x00001000u;
}
inline void RoomInfo::clear_has_readytimer() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void RoomInfo::clear_readytimer() {
  readytimer_ = GOOGLE_LONGLONG(0);
  clear_has_readytimer();
}
inline ::google::protobuf::int64 RoomInfo::readytimer() const {
  return readytimer_;
}
inline void RoomInfo::set_readytimer(::google::protobuf::int64 value) {
  set_has_readytimer();
  readytimer_ = value;
}

// optional int32 gameId = 14;
inline bool RoomInfo::has_gameid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void RoomInfo::set_has_gameid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void RoomInfo::clear_has_gameid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void RoomInfo::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 RoomInfo::gameid() const {
  return gameid_;
}
inline void RoomInfo::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional int32 roomType = 15;
inline bool RoomInfo::has_roomtype() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void RoomInfo::set_has_roomtype() {
  _has_bits_[0] |= 0x00004000u;
}
inline void RoomInfo::clear_has_roomtype() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void RoomInfo::clear_roomtype() {
  roomtype_ = 0;
  clear_has_roomtype();
}
inline ::google::protobuf::int32 RoomInfo::roomtype() const {
  return roomtype_;
}
inline void RoomInfo::set_roomtype(::google::protobuf::int32 value) {
  set_has_roomtype();
  roomtype_ = value;
}

// optional int32 timesType = 16;
inline bool RoomInfo::has_timestype() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void RoomInfo::set_has_timestype() {
  _has_bits_[0] |= 0x00008000u;
}
inline void RoomInfo::clear_has_timestype() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void RoomInfo::clear_timestype() {
  timestype_ = 0;
  clear_has_timestype();
}
inline ::google::protobuf::int32 RoomInfo::timestype() const {
  return timestype_;
}
inline void RoomInfo::set_timestype(::google::protobuf::int32 value) {
  set_has_timestype();
  timestype_ = value;
}

// optional double yazhu = 17;
inline bool RoomInfo::has_yazhu() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void RoomInfo::set_has_yazhu() {
  _has_bits_[0] |= 0x00010000u;
}
inline void RoomInfo::clear_has_yazhu() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void RoomInfo::clear_yazhu() {
  yazhu_ = 0;
  clear_has_yazhu();
}
inline double RoomInfo::yazhu() const {
  return yazhu_;
}
inline void RoomInfo::set_yazhu(double value) {
  set_has_yazhu();
  yazhu_ = value;
}

// optional int32 watting = 18;
inline bool RoomInfo::has_watting() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void RoomInfo::set_has_watting() {
  _has_bits_[0] |= 0x00020000u;
}
inline void RoomInfo::clear_has_watting() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void RoomInfo::clear_watting() {
  watting_ = 0;
  clear_has_watting();
}
inline ::google::protobuf::int32 RoomInfo::watting() const {
  return watting_;
}
inline void RoomInfo::set_watting(::google::protobuf::int32 value) {
  set_has_watting();
  watting_ = value;
}

// optional int32 from = 19;
inline bool RoomInfo::has_from() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void RoomInfo::set_has_from() {
  _has_bits_[0] |= 0x00040000u;
}
inline void RoomInfo::clear_has_from() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void RoomInfo::clear_from() {
  from_ = 0;
  clear_has_from();
}
inline ::google::protobuf::int32 RoomInfo::from() const {
  return from_;
}
inline void RoomInfo::set_from(::google::protobuf::int32 value) {
  set_has_from();
  from_ = value;
}

// optional int32 to = 20;
inline bool RoomInfo::has_to() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void RoomInfo::set_has_to() {
  _has_bits_[0] |= 0x00080000u;
}
inline void RoomInfo::clear_has_to() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void RoomInfo::clear_to() {
  to_ = 0;
  clear_has_to();
}
inline ::google::protobuf::int32 RoomInfo::to() const {
  return to_;
}
inline void RoomInfo::set_to(::google::protobuf::int32 value) {
  set_has_to();
  to_ = value;
}

// optional string serverExtend = 21;
inline bool RoomInfo::has_serverextend() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void RoomInfo::set_has_serverextend() {
  _has_bits_[0] |= 0x00100000u;
}
inline void RoomInfo::clear_has_serverextend() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void RoomInfo::clear_serverextend() {
  if (serverextend_ != &::google::protobuf::internal::kEmptyString) {
    serverextend_->clear();
  }
  clear_has_serverextend();
}
inline const ::std::string& RoomInfo::serverextend() const {
  return *serverextend_;
}
inline void RoomInfo::set_serverextend(const ::std::string& value) {
  set_has_serverextend();
  if (serverextend_ == &::google::protobuf::internal::kEmptyString) {
    serverextend_ = new ::std::string;
  }
  serverextend_->assign(value);
}
inline void RoomInfo::set_serverextend(const char* value) {
  set_has_serverextend();
  if (serverextend_ == &::google::protobuf::internal::kEmptyString) {
    serverextend_ = new ::std::string;
  }
  serverextend_->assign(value);
}
inline void RoomInfo::set_serverextend(const char* value, size_t size) {
  set_has_serverextend();
  if (serverextend_ == &::google::protobuf::internal::kEmptyString) {
    serverextend_ = new ::std::string;
  }
  serverextend_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomInfo::mutable_serverextend() {
  set_has_serverextend();
  if (serverextend_ == &::google::protobuf::internal::kEmptyString) {
    serverextend_ = new ::std::string;
  }
  return serverextend_;
}
inline ::std::string* RoomInfo::release_serverextend() {
  clear_has_serverextend();
  if (serverextend_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = serverextend_;
    serverextend_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomInfo::set_allocated_serverextend(::std::string* serverextend) {
  if (serverextend_ != &::google::protobuf::internal::kEmptyString) {
    delete serverextend_;
  }
  if (serverextend) {
    set_has_serverextend();
    serverextend_ = serverextend;
  } else {
    clear_has_serverextend();
    serverextend_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 fangkaJinbi = 22;
inline bool RoomInfo::has_fangkajinbi() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void RoomInfo::set_has_fangkajinbi() {
  _has_bits_[0] |= 0x00200000u;
}
inline void RoomInfo::clear_has_fangkajinbi() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void RoomInfo::clear_fangkajinbi() {
  fangkajinbi_ = 0;
  clear_has_fangkajinbi();
}
inline ::google::protobuf::int32 RoomInfo::fangkajinbi() const {
  return fangkajinbi_;
}
inline void RoomInfo::set_fangkajinbi(::google::protobuf::int32 value) {
  set_has_fangkajinbi();
  fangkajinbi_ = value;
}

// optional string chargeList = 23;
inline bool RoomInfo::has_chargelist() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void RoomInfo::set_has_chargelist() {
  _has_bits_[0] |= 0x00400000u;
}
inline void RoomInfo::clear_has_chargelist() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void RoomInfo::clear_chargelist() {
  if (chargelist_ != &::google::protobuf::internal::kEmptyString) {
    chargelist_->clear();
  }
  clear_has_chargelist();
}
inline const ::std::string& RoomInfo::chargelist() const {
  return *chargelist_;
}
inline void RoomInfo::set_chargelist(const ::std::string& value) {
  set_has_chargelist();
  if (chargelist_ == &::google::protobuf::internal::kEmptyString) {
    chargelist_ = new ::std::string;
  }
  chargelist_->assign(value);
}
inline void RoomInfo::set_chargelist(const char* value) {
  set_has_chargelist();
  if (chargelist_ == &::google::protobuf::internal::kEmptyString) {
    chargelist_ = new ::std::string;
  }
  chargelist_->assign(value);
}
inline void RoomInfo::set_chargelist(const char* value, size_t size) {
  set_has_chargelist();
  if (chargelist_ == &::google::protobuf::internal::kEmptyString) {
    chargelist_ = new ::std::string;
  }
  chargelist_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomInfo::mutable_chargelist() {
  set_has_chargelist();
  if (chargelist_ == &::google::protobuf::internal::kEmptyString) {
    chargelist_ = new ::std::string;
  }
  return chargelist_;
}
inline ::std::string* RoomInfo::release_chargelist() {
  clear_has_chargelist();
  if (chargelist_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = chargelist_;
    chargelist_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomInfo::set_allocated_chargelist(::std::string* chargelist) {
  if (chargelist_ != &::google::protobuf::internal::kEmptyString) {
    delete chargelist_;
  }
  if (chargelist) {
    set_has_chargelist();
    chargelist_ = chargelist;
  } else {
    clear_has_chargelist();
    chargelist_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ext = 24;
inline bool RoomInfo::has_ext() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void RoomInfo::set_has_ext() {
  _has_bits_[0] |= 0x00800000u;
}
inline void RoomInfo::clear_has_ext() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void RoomInfo::clear_ext() {
  if (ext_ != &::google::protobuf::internal::kEmptyString) {
    ext_->clear();
  }
  clear_has_ext();
}
inline const ::std::string& RoomInfo::ext() const {
  return *ext_;
}
inline void RoomInfo::set_ext(const ::std::string& value) {
  set_has_ext();
  if (ext_ == &::google::protobuf::internal::kEmptyString) {
    ext_ = new ::std::string;
  }
  ext_->assign(value);
}
inline void RoomInfo::set_ext(const char* value) {
  set_has_ext();
  if (ext_ == &::google::protobuf::internal::kEmptyString) {
    ext_ = new ::std::string;
  }
  ext_->assign(value);
}
inline void RoomInfo::set_ext(const char* value, size_t size) {
  set_has_ext();
  if (ext_ == &::google::protobuf::internal::kEmptyString) {
    ext_ = new ::std::string;
  }
  ext_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomInfo::mutable_ext() {
  set_has_ext();
  if (ext_ == &::google::protobuf::internal::kEmptyString) {
    ext_ = new ::std::string;
  }
  return ext_;
}
inline ::std::string* RoomInfo::release_ext() {
  clear_has_ext();
  if (ext_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ext_;
    ext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomInfo::set_allocated_ext(::std::string* ext) {
  if (ext_ != &::google::protobuf::internal::kEmptyString) {
    delete ext_;
  }
  if (ext) {
    set_has_ext();
    ext_ = ext;
  } else {
    clear_has_ext();
    ext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string clubId = 25;
inline bool RoomInfo::has_clubid() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void RoomInfo::set_has_clubid() {
  _has_bits_[0] |= 0x01000000u;
}
inline void RoomInfo::clear_has_clubid() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void RoomInfo::clear_clubid() {
  if (clubid_ != &::google::protobuf::internal::kEmptyString) {
    clubid_->clear();
  }
  clear_has_clubid();
}
inline const ::std::string& RoomInfo::clubid() const {
  return *clubid_;
}
inline void RoomInfo::set_clubid(const ::std::string& value) {
  set_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    clubid_ = new ::std::string;
  }
  clubid_->assign(value);
}
inline void RoomInfo::set_clubid(const char* value) {
  set_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    clubid_ = new ::std::string;
  }
  clubid_->assign(value);
}
inline void RoomInfo::set_clubid(const char* value, size_t size) {
  set_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    clubid_ = new ::std::string;
  }
  clubid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomInfo::mutable_clubid() {
  set_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    clubid_ = new ::std::string;
  }
  return clubid_;
}
inline ::std::string* RoomInfo::release_clubid() {
  clear_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clubid_;
    clubid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomInfo::set_allocated_clubid(::std::string* clubid) {
  if (clubid_ != &::google::protobuf::internal::kEmptyString) {
    delete clubid_;
  }
  if (clubid) {
    set_has_clubid();
    clubid_ = clubid;
  } else {
    clear_has_clubid();
    clubid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string tableNum = 26;
inline bool RoomInfo::has_tablenum() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void RoomInfo::set_has_tablenum() {
  _has_bits_[0] |= 0x02000000u;
}
inline void RoomInfo::clear_has_tablenum() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void RoomInfo::clear_tablenum() {
  if (tablenum_ != &::google::protobuf::internal::kEmptyString) {
    tablenum_->clear();
  }
  clear_has_tablenum();
}
inline const ::std::string& RoomInfo::tablenum() const {
  return *tablenum_;
}
inline void RoomInfo::set_tablenum(const ::std::string& value) {
  set_has_tablenum();
  if (tablenum_ == &::google::protobuf::internal::kEmptyString) {
    tablenum_ = new ::std::string;
  }
  tablenum_->assign(value);
}
inline void RoomInfo::set_tablenum(const char* value) {
  set_has_tablenum();
  if (tablenum_ == &::google::protobuf::internal::kEmptyString) {
    tablenum_ = new ::std::string;
  }
  tablenum_->assign(value);
}
inline void RoomInfo::set_tablenum(const char* value, size_t size) {
  set_has_tablenum();
  if (tablenum_ == &::google::protobuf::internal::kEmptyString) {
    tablenum_ = new ::std::string;
  }
  tablenum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomInfo::mutable_tablenum() {
  set_has_tablenum();
  if (tablenum_ == &::google::protobuf::internal::kEmptyString) {
    tablenum_ = new ::std::string;
  }
  return tablenum_;
}
inline ::std::string* RoomInfo::release_tablenum() {
  clear_has_tablenum();
  if (tablenum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tablenum_;
    tablenum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomInfo::set_allocated_tablenum(::std::string* tablenum) {
  if (tablenum_ != &::google::protobuf::internal::kEmptyString) {
    delete tablenum_;
  }
  if (tablenum) {
    set_has_tablenum();
    tablenum_ = tablenum;
  } else {
    clear_has_tablenum();
    tablenum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string clubGameTypeId = 27;
inline bool RoomInfo::has_clubgametypeid() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void RoomInfo::set_has_clubgametypeid() {
  _has_bits_[0] |= 0x04000000u;
}
inline void RoomInfo::clear_has_clubgametypeid() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void RoomInfo::clear_clubgametypeid() {
  if (clubgametypeid_ != &::google::protobuf::internal::kEmptyString) {
    clubgametypeid_->clear();
  }
  clear_has_clubgametypeid();
}
inline const ::std::string& RoomInfo::clubgametypeid() const {
  return *clubgametypeid_;
}
inline void RoomInfo::set_clubgametypeid(const ::std::string& value) {
  set_has_clubgametypeid();
  if (clubgametypeid_ == &::google::protobuf::internal::kEmptyString) {
    clubgametypeid_ = new ::std::string;
  }
  clubgametypeid_->assign(value);
}
inline void RoomInfo::set_clubgametypeid(const char* value) {
  set_has_clubgametypeid();
  if (clubgametypeid_ == &::google::protobuf::internal::kEmptyString) {
    clubgametypeid_ = new ::std::string;
  }
  clubgametypeid_->assign(value);
}
inline void RoomInfo::set_clubgametypeid(const char* value, size_t size) {
  set_has_clubgametypeid();
  if (clubgametypeid_ == &::google::protobuf::internal::kEmptyString) {
    clubgametypeid_ = new ::std::string;
  }
  clubgametypeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomInfo::mutable_clubgametypeid() {
  set_has_clubgametypeid();
  if (clubgametypeid_ == &::google::protobuf::internal::kEmptyString) {
    clubgametypeid_ = new ::std::string;
  }
  return clubgametypeid_;
}
inline ::std::string* RoomInfo::release_clubgametypeid() {
  clear_has_clubgametypeid();
  if (clubgametypeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clubgametypeid_;
    clubgametypeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomInfo::set_allocated_clubgametypeid(::std::string* clubgametypeid) {
  if (clubgametypeid_ != &::google::protobuf::internal::kEmptyString) {
    delete clubgametypeid_;
  }
  if (clubgametypeid) {
    set_has_clubgametypeid();
    clubgametypeid_ = clubgametypeid;
  } else {
    clear_has_clubgametypeid();
    clubgametypeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// DissolutionStatus

// required int32 dissolutionStatus = 1;
inline bool DissolutionStatus::has_dissolutionstatus() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DissolutionStatus::set_has_dissolutionstatus() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DissolutionStatus::clear_has_dissolutionstatus() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DissolutionStatus::clear_dissolutionstatus() {
  dissolutionstatus_ = 0;
  clear_has_dissolutionstatus();
}
inline ::google::protobuf::int32 DissolutionStatus::dissolutionstatus() const {
  return dissolutionstatus_;
}
inline void DissolutionStatus::set_dissolutionstatus(::google::protobuf::int32 value) {
  set_has_dissolutionstatus();
  dissolutionstatus_ = value;
}

// optional string reqUniqueId = 2;
inline bool DissolutionStatus::has_requniqueid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DissolutionStatus::set_has_requniqueid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DissolutionStatus::clear_has_requniqueid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DissolutionStatus::clear_requniqueid() {
  if (requniqueid_ != &::google::protobuf::internal::kEmptyString) {
    requniqueid_->clear();
  }
  clear_has_requniqueid();
}
inline const ::std::string& DissolutionStatus::requniqueid() const {
  return *requniqueid_;
}
inline void DissolutionStatus::set_requniqueid(const ::std::string& value) {
  set_has_requniqueid();
  if (requniqueid_ == &::google::protobuf::internal::kEmptyString) {
    requniqueid_ = new ::std::string;
  }
  requniqueid_->assign(value);
}
inline void DissolutionStatus::set_requniqueid(const char* value) {
  set_has_requniqueid();
  if (requniqueid_ == &::google::protobuf::internal::kEmptyString) {
    requniqueid_ = new ::std::string;
  }
  requniqueid_->assign(value);
}
inline void DissolutionStatus::set_requniqueid(const char* value, size_t size) {
  set_has_requniqueid();
  if (requniqueid_ == &::google::protobuf::internal::kEmptyString) {
    requniqueid_ = new ::std::string;
  }
  requniqueid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DissolutionStatus::mutable_requniqueid() {
  set_has_requniqueid();
  if (requniqueid_ == &::google::protobuf::internal::kEmptyString) {
    requniqueid_ = new ::std::string;
  }
  return requniqueid_;
}
inline ::std::string* DissolutionStatus::release_requniqueid() {
  clear_has_requniqueid();
  if (requniqueid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = requniqueid_;
    requniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DissolutionStatus::set_allocated_requniqueid(::std::string* requniqueid) {
  if (requniqueid_ != &::google::protobuf::internal::kEmptyString) {
    delete requniqueid_;
  }
  if (requniqueid) {
    set_has_requniqueid();
    requniqueid_ = requniqueid;
  } else {
    clear_has_requniqueid();
    requniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .ProtoNet.DissolutionStatusDetail details = 3;
inline int DissolutionStatus::details_size() const {
  return details_.size();
}
inline void DissolutionStatus::clear_details() {
  details_.Clear();
}
inline const ::ProtoNet::DissolutionStatusDetail& DissolutionStatus::details(int index) const {
  return details_.Get(index);
}
inline ::ProtoNet::DissolutionStatusDetail* DissolutionStatus::mutable_details(int index) {
  return details_.Mutable(index);
}
inline ::ProtoNet::DissolutionStatusDetail* DissolutionStatus::add_details() {
  return details_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::DissolutionStatusDetail >&
DissolutionStatus::details() const {
  return details_;
}
inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::DissolutionStatusDetail >*
DissolutionStatus::mutable_details() {
  return &details_;
}

// optional int64 leftTimer = 4;
inline bool DissolutionStatus::has_lefttimer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DissolutionStatus::set_has_lefttimer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DissolutionStatus::clear_has_lefttimer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DissolutionStatus::clear_lefttimer() {
  lefttimer_ = GOOGLE_LONGLONG(0);
  clear_has_lefttimer();
}
inline ::google::protobuf::int64 DissolutionStatus::lefttimer() const {
  return lefttimer_;
}
inline void DissolutionStatus::set_lefttimer(::google::protobuf::int64 value) {
  set_has_lefttimer();
  lefttimer_ = value;
}

// -------------------------------------------------------------------

// DissolutionStatusDetail

// required string roomId = 1;
inline bool DissolutionStatusDetail::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DissolutionStatusDetail::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DissolutionStatusDetail::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DissolutionStatusDetail::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& DissolutionStatusDetail::roomid() const {
  return *roomid_;
}
inline void DissolutionStatusDetail::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void DissolutionStatusDetail::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void DissolutionStatusDetail::set_roomid(const char* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DissolutionStatusDetail::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  return roomid_;
}
inline ::std::string* DissolutionStatusDetail::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DissolutionStatusDetail::set_allocated_roomid(::std::string* roomid) {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomid_;
  }
  if (roomid) {
    set_has_roomid();
    roomid_ = roomid;
  } else {
    clear_has_roomid();
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string controllerUniqueId = 2;
inline bool DissolutionStatusDetail::has_controlleruniqueid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DissolutionStatusDetail::set_has_controlleruniqueid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DissolutionStatusDetail::clear_has_controlleruniqueid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DissolutionStatusDetail::clear_controlleruniqueid() {
  if (controlleruniqueid_ != &::google::protobuf::internal::kEmptyString) {
    controlleruniqueid_->clear();
  }
  clear_has_controlleruniqueid();
}
inline const ::std::string& DissolutionStatusDetail::controlleruniqueid() const {
  return *controlleruniqueid_;
}
inline void DissolutionStatusDetail::set_controlleruniqueid(const ::std::string& value) {
  set_has_controlleruniqueid();
  if (controlleruniqueid_ == &::google::protobuf::internal::kEmptyString) {
    controlleruniqueid_ = new ::std::string;
  }
  controlleruniqueid_->assign(value);
}
inline void DissolutionStatusDetail::set_controlleruniqueid(const char* value) {
  set_has_controlleruniqueid();
  if (controlleruniqueid_ == &::google::protobuf::internal::kEmptyString) {
    controlleruniqueid_ = new ::std::string;
  }
  controlleruniqueid_->assign(value);
}
inline void DissolutionStatusDetail::set_controlleruniqueid(const char* value, size_t size) {
  set_has_controlleruniqueid();
  if (controlleruniqueid_ == &::google::protobuf::internal::kEmptyString) {
    controlleruniqueid_ = new ::std::string;
  }
  controlleruniqueid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DissolutionStatusDetail::mutable_controlleruniqueid() {
  set_has_controlleruniqueid();
  if (controlleruniqueid_ == &::google::protobuf::internal::kEmptyString) {
    controlleruniqueid_ = new ::std::string;
  }
  return controlleruniqueid_;
}
inline ::std::string* DissolutionStatusDetail::release_controlleruniqueid() {
  clear_has_controlleruniqueid();
  if (controlleruniqueid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = controlleruniqueid_;
    controlleruniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DissolutionStatusDetail::set_allocated_controlleruniqueid(::std::string* controlleruniqueid) {
  if (controlleruniqueid_ != &::google::protobuf::internal::kEmptyString) {
    delete controlleruniqueid_;
  }
  if (controlleruniqueid) {
    set_has_controlleruniqueid();
    controlleruniqueid_ = controlleruniqueid;
  } else {
    clear_has_controlleruniqueid();
    controlleruniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 agree = 3;
inline bool DissolutionStatusDetail::has_agree() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DissolutionStatusDetail::set_has_agree() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DissolutionStatusDetail::clear_has_agree() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DissolutionStatusDetail::clear_agree() {
  agree_ = 0;
  clear_has_agree();
}
inline ::google::protobuf::int32 DissolutionStatusDetail::agree() const {
  return agree_;
}
inline void DissolutionStatusDetail::set_agree(::google::protobuf::int32 value) {
  set_has_agree();
  agree_ = value;
}

// required int32 pos = 4;
inline bool DissolutionStatusDetail::has_pos() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DissolutionStatusDetail::set_has_pos() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DissolutionStatusDetail::clear_has_pos() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DissolutionStatusDetail::clear_pos() {
  pos_ = 0;
  clear_has_pos();
}
inline ::google::protobuf::int32 DissolutionStatusDetail::pos() const {
  return pos_;
}
inline void DissolutionStatusDetail::set_pos(::google::protobuf::int32 value) {
  set_has_pos();
  pos_ = value;
}

// -------------------------------------------------------------------

// ReqLogicLogin

// required string account = 1;
inline bool ReqLogicLogin::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqLogicLogin::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqLogicLogin::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqLogicLogin::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& ReqLogicLogin::account() const {
  return *account_;
}
inline void ReqLogicLogin::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void ReqLogicLogin::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void ReqLogicLogin::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqLogicLogin::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* ReqLogicLogin::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqLogicLogin::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string ticket = 2;
inline bool ReqLogicLogin::has_ticket() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqLogicLogin::set_has_ticket() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqLogicLogin::clear_has_ticket() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqLogicLogin::clear_ticket() {
  if (ticket_ != &::google::protobuf::internal::kEmptyString) {
    ticket_->clear();
  }
  clear_has_ticket();
}
inline const ::std::string& ReqLogicLogin::ticket() const {
  return *ticket_;
}
inline void ReqLogicLogin::set_ticket(const ::std::string& value) {
  set_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    ticket_ = new ::std::string;
  }
  ticket_->assign(value);
}
inline void ReqLogicLogin::set_ticket(const char* value) {
  set_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    ticket_ = new ::std::string;
  }
  ticket_->assign(value);
}
inline void ReqLogicLogin::set_ticket(const char* value, size_t size) {
  set_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    ticket_ = new ::std::string;
  }
  ticket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqLogicLogin::mutable_ticket() {
  set_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    ticket_ = new ::std::string;
  }
  return ticket_;
}
inline ::std::string* ReqLogicLogin::release_ticket() {
  clear_has_ticket();
  if (ticket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ticket_;
    ticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqLogicLogin::set_allocated_ticket(::std::string* ticket) {
  if (ticket_ != &::google::protobuf::internal::kEmptyString) {
    delete ticket_;
  }
  if (ticket) {
    set_has_ticket();
    ticket_ = ticket;
  } else {
    clear_has_ticket();
    ticket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ResLogicLogin

// required .ProtoNet.ResponseResult result = 1;
inline bool ResLogicLogin::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResLogicLogin::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResLogicLogin::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResLogicLogin::clear_result() {
  if (result_ != NULL) result_->::ProtoNet::ResponseResult::Clear();
  clear_has_result();
}
inline const ::ProtoNet::ResponseResult& ResLogicLogin::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::ProtoNet::ResponseResult* ResLogicLogin::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::ProtoNet::ResponseResult;
  return result_;
}
inline ::ProtoNet::ResponseResult* ResLogicLogin::release_result() {
  clear_has_result();
  ::ProtoNet::ResponseResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline void ResLogicLogin::set_allocated_result(::ProtoNet::ResponseResult* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// -------------------------------------------------------------------

// ReqCreateGameRoom

// required int32 roomType = 1;
inline bool ReqCreateGameRoom::has_roomtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqCreateGameRoom::set_has_roomtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqCreateGameRoom::clear_has_roomtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqCreateGameRoom::clear_roomtype() {
  roomtype_ = 0;
  clear_has_roomtype();
}
inline ::google::protobuf::int32 ReqCreateGameRoom::roomtype() const {
  return roomtype_;
}
inline void ReqCreateGameRoom::set_roomtype(::google::protobuf::int32 value) {
  set_has_roomtype();
  roomtype_ = value;
}

// required int32 times = 2;
inline bool ReqCreateGameRoom::has_times() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqCreateGameRoom::set_has_times() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqCreateGameRoom::clear_has_times() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqCreateGameRoom::clear_times() {
  times_ = 0;
  clear_has_times();
}
inline ::google::protobuf::int32 ReqCreateGameRoom::times() const {
  return times_;
}
inline void ReqCreateGameRoom::set_times(::google::protobuf::int32 value) {
  set_has_times();
  times_ = value;
}

// optional string paramString = 3;
inline bool ReqCreateGameRoom::has_paramstring() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqCreateGameRoom::set_has_paramstring() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqCreateGameRoom::clear_has_paramstring() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqCreateGameRoom::clear_paramstring() {
  if (paramstring_ != &::google::protobuf::internal::kEmptyString) {
    paramstring_->clear();
  }
  clear_has_paramstring();
}
inline const ::std::string& ReqCreateGameRoom::paramstring() const {
  return *paramstring_;
}
inline void ReqCreateGameRoom::set_paramstring(const ::std::string& value) {
  set_has_paramstring();
  if (paramstring_ == &::google::protobuf::internal::kEmptyString) {
    paramstring_ = new ::std::string;
  }
  paramstring_->assign(value);
}
inline void ReqCreateGameRoom::set_paramstring(const char* value) {
  set_has_paramstring();
  if (paramstring_ == &::google::protobuf::internal::kEmptyString) {
    paramstring_ = new ::std::string;
  }
  paramstring_->assign(value);
}
inline void ReqCreateGameRoom::set_paramstring(const char* value, size_t size) {
  set_has_paramstring();
  if (paramstring_ == &::google::protobuf::internal::kEmptyString) {
    paramstring_ = new ::std::string;
  }
  paramstring_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqCreateGameRoom::mutable_paramstring() {
  set_has_paramstring();
  if (paramstring_ == &::google::protobuf::internal::kEmptyString) {
    paramstring_ = new ::std::string;
  }
  return paramstring_;
}
inline ::std::string* ReqCreateGameRoom::release_paramstring() {
  clear_has_paramstring();
  if (paramstring_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = paramstring_;
    paramstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqCreateGameRoom::set_allocated_paramstring(::std::string* paramstring) {
  if (paramstring_ != &::google::protobuf::internal::kEmptyString) {
    delete paramstring_;
  }
  if (paramstring) {
    set_has_paramstring();
    paramstring_ = paramstring;
  } else {
    clear_has_paramstring();
    paramstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 timesType = 4;
inline bool ReqCreateGameRoom::has_timestype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqCreateGameRoom::set_has_timestype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqCreateGameRoom::clear_has_timestype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqCreateGameRoom::clear_timestype() {
  timestype_ = 0;
  clear_has_timestype();
}
inline ::google::protobuf::int32 ReqCreateGameRoom::timestype() const {
  return timestype_;
}
inline void ReqCreateGameRoom::set_timestype(::google::protobuf::int32 value) {
  set_has_timestype();
  timestype_ = value;
}

// optional int32 payType = 5;
inline bool ReqCreateGameRoom::has_paytype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReqCreateGameRoom::set_has_paytype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReqCreateGameRoom::clear_has_paytype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReqCreateGameRoom::clear_paytype() {
  paytype_ = 0;
  clear_has_paytype();
}
inline ::google::protobuf::int32 ReqCreateGameRoom::paytype() const {
  return paytype_;
}
inline void ReqCreateGameRoom::set_paytype(::google::protobuf::int32 value) {
  set_has_paytype();
  paytype_ = value;
}

// optional int32 halfWayJoin = 6;
inline bool ReqCreateGameRoom::has_halfwayjoin() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReqCreateGameRoom::set_has_halfwayjoin() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReqCreateGameRoom::clear_has_halfwayjoin() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReqCreateGameRoom::clear_halfwayjoin() {
  halfwayjoin_ = 0;
  clear_has_halfwayjoin();
}
inline ::google::protobuf::int32 ReqCreateGameRoom::halfwayjoin() const {
  return halfwayjoin_;
}
inline void ReqCreateGameRoom::set_halfwayjoin(::google::protobuf::int32 value) {
  set_has_halfwayjoin();
  halfwayjoin_ = value;
}

// optional int32 maxPlayerNum = 7;
inline bool ReqCreateGameRoom::has_maxplayernum() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ReqCreateGameRoom::set_has_maxplayernum() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ReqCreateGameRoom::clear_has_maxplayernum() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ReqCreateGameRoom::clear_maxplayernum() {
  maxplayernum_ = 0;
  clear_has_maxplayernum();
}
inline ::google::protobuf::int32 ReqCreateGameRoom::maxplayernum() const {
  return maxplayernum_;
}
inline void ReqCreateGameRoom::set_maxplayernum(::google::protobuf::int32 value) {
  set_has_maxplayernum();
  maxplayernum_ = value;
}

// optional double yazhu = 8;
inline bool ReqCreateGameRoom::has_yazhu() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ReqCreateGameRoom::set_has_yazhu() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ReqCreateGameRoom::clear_has_yazhu() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ReqCreateGameRoom::clear_yazhu() {
  yazhu_ = 0;
  clear_has_yazhu();
}
inline double ReqCreateGameRoom::yazhu() const {
  return yazhu_;
}
inline void ReqCreateGameRoom::set_yazhu(double value) {
  set_has_yazhu();
  yazhu_ = value;
}

// optional int32 fangkaJinbi = 9;
inline bool ReqCreateGameRoom::has_fangkajinbi() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ReqCreateGameRoom::set_has_fangkajinbi() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ReqCreateGameRoom::clear_has_fangkajinbi() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ReqCreateGameRoom::clear_fangkajinbi() {
  fangkajinbi_ = 0;
  clear_has_fangkajinbi();
}
inline ::google::protobuf::int32 ReqCreateGameRoom::fangkajinbi() const {
  return fangkajinbi_;
}
inline void ReqCreateGameRoom::set_fangkajinbi(::google::protobuf::int32 value) {
  set_has_fangkajinbi();
  fangkajinbi_ = value;
}

// optional double minNeed = 10;
inline bool ReqCreateGameRoom::has_minneed() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ReqCreateGameRoom::set_has_minneed() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ReqCreateGameRoom::clear_has_minneed() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ReqCreateGameRoom::clear_minneed() {
  minneed_ = 0;
  clear_has_minneed();
}
inline double ReqCreateGameRoom::minneed() const {
  return minneed_;
}
inline void ReqCreateGameRoom::set_minneed(double value) {
  set_has_minneed();
  minneed_ = value;
}

// optional string pipeiParam = 11;
inline bool ReqCreateGameRoom::has_pipeiparam() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ReqCreateGameRoom::set_has_pipeiparam() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ReqCreateGameRoom::clear_has_pipeiparam() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ReqCreateGameRoom::clear_pipeiparam() {
  if (pipeiparam_ != &::google::protobuf::internal::kEmptyString) {
    pipeiparam_->clear();
  }
  clear_has_pipeiparam();
}
inline const ::std::string& ReqCreateGameRoom::pipeiparam() const {
  return *pipeiparam_;
}
inline void ReqCreateGameRoom::set_pipeiparam(const ::std::string& value) {
  set_has_pipeiparam();
  if (pipeiparam_ == &::google::protobuf::internal::kEmptyString) {
    pipeiparam_ = new ::std::string;
  }
  pipeiparam_->assign(value);
}
inline void ReqCreateGameRoom::set_pipeiparam(const char* value) {
  set_has_pipeiparam();
  if (pipeiparam_ == &::google::protobuf::internal::kEmptyString) {
    pipeiparam_ = new ::std::string;
  }
  pipeiparam_->assign(value);
}
inline void ReqCreateGameRoom::set_pipeiparam(const char* value, size_t size) {
  set_has_pipeiparam();
  if (pipeiparam_ == &::google::protobuf::internal::kEmptyString) {
    pipeiparam_ = new ::std::string;
  }
  pipeiparam_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqCreateGameRoom::mutable_pipeiparam() {
  set_has_pipeiparam();
  if (pipeiparam_ == &::google::protobuf::internal::kEmptyString) {
    pipeiparam_ = new ::std::string;
  }
  return pipeiparam_;
}
inline ::std::string* ReqCreateGameRoom::release_pipeiparam() {
  clear_has_pipeiparam();
  if (pipeiparam_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pipeiparam_;
    pipeiparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqCreateGameRoom::set_allocated_pipeiparam(::std::string* pipeiparam) {
  if (pipeiparam_ != &::google::protobuf::internal::kEmptyString) {
    delete pipeiparam_;
  }
  if (pipeiparam) {
    set_has_pipeiparam();
    pipeiparam_ = pipeiparam;
  } else {
    clear_has_pipeiparam();
    pipeiparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string clubId = 12;
inline bool ReqCreateGameRoom::has_clubid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ReqCreateGameRoom::set_has_clubid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ReqCreateGameRoom::clear_has_clubid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ReqCreateGameRoom::clear_clubid() {
  if (clubid_ != &::google::protobuf::internal::kEmptyString) {
    clubid_->clear();
  }
  clear_has_clubid();
}
inline const ::std::string& ReqCreateGameRoom::clubid() const {
  return *clubid_;
}
inline void ReqCreateGameRoom::set_clubid(const ::std::string& value) {
  set_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    clubid_ = new ::std::string;
  }
  clubid_->assign(value);
}
inline void ReqCreateGameRoom::set_clubid(const char* value) {
  set_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    clubid_ = new ::std::string;
  }
  clubid_->assign(value);
}
inline void ReqCreateGameRoom::set_clubid(const char* value, size_t size) {
  set_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    clubid_ = new ::std::string;
  }
  clubid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqCreateGameRoom::mutable_clubid() {
  set_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    clubid_ = new ::std::string;
  }
  return clubid_;
}
inline ::std::string* ReqCreateGameRoom::release_clubid() {
  clear_has_clubid();
  if (clubid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clubid_;
    clubid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqCreateGameRoom::set_allocated_clubid(::std::string* clubid) {
  if (clubid_ != &::google::protobuf::internal::kEmptyString) {
    delete clubid_;
  }
  if (clubid) {
    set_has_clubid();
    clubid_ = clubid;
  } else {
    clear_has_clubid();
    clubid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string clubTableNum = 13;
inline bool ReqCreateGameRoom::has_clubtablenum() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ReqCreateGameRoom::set_has_clubtablenum() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ReqCreateGameRoom::clear_has_clubtablenum() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ReqCreateGameRoom::clear_clubtablenum() {
  if (clubtablenum_ != &::google::protobuf::internal::kEmptyString) {
    clubtablenum_->clear();
  }
  clear_has_clubtablenum();
}
inline const ::std::string& ReqCreateGameRoom::clubtablenum() const {
  return *clubtablenum_;
}
inline void ReqCreateGameRoom::set_clubtablenum(const ::std::string& value) {
  set_has_clubtablenum();
  if (clubtablenum_ == &::google::protobuf::internal::kEmptyString) {
    clubtablenum_ = new ::std::string;
  }
  clubtablenum_->assign(value);
}
inline void ReqCreateGameRoom::set_clubtablenum(const char* value) {
  set_has_clubtablenum();
  if (clubtablenum_ == &::google::protobuf::internal::kEmptyString) {
    clubtablenum_ = new ::std::string;
  }
  clubtablenum_->assign(value);
}
inline void ReqCreateGameRoom::set_clubtablenum(const char* value, size_t size) {
  set_has_clubtablenum();
  if (clubtablenum_ == &::google::protobuf::internal::kEmptyString) {
    clubtablenum_ = new ::std::string;
  }
  clubtablenum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqCreateGameRoom::mutable_clubtablenum() {
  set_has_clubtablenum();
  if (clubtablenum_ == &::google::protobuf::internal::kEmptyString) {
    clubtablenum_ = new ::std::string;
  }
  return clubtablenum_;
}
inline ::std::string* ReqCreateGameRoom::release_clubtablenum() {
  clear_has_clubtablenum();
  if (clubtablenum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clubtablenum_;
    clubtablenum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqCreateGameRoom::set_allocated_clubtablenum(::std::string* clubtablenum) {
  if (clubtablenum_ != &::google::protobuf::internal::kEmptyString) {
    delete clubtablenum_;
  }
  if (clubtablenum) {
    set_has_clubtablenum();
    clubtablenum_ = clubtablenum;
  } else {
    clear_has_clubtablenum();
    clubtablenum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string clubGameTypeId = 14;
inline bool ReqCreateGameRoom::has_clubgametypeid() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ReqCreateGameRoom::set_has_clubgametypeid() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ReqCreateGameRoom::clear_has_clubgametypeid() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ReqCreateGameRoom::clear_clubgametypeid() {
  if (clubgametypeid_ != &::google::protobuf::internal::kEmptyString) {
    clubgametypeid_->clear();
  }
  clear_has_clubgametypeid();
}
inline const ::std::string& ReqCreateGameRoom::clubgametypeid() const {
  return *clubgametypeid_;
}
inline void ReqCreateGameRoom::set_clubgametypeid(const ::std::string& value) {
  set_has_clubgametypeid();
  if (clubgametypeid_ == &::google::protobuf::internal::kEmptyString) {
    clubgametypeid_ = new ::std::string;
  }
  clubgametypeid_->assign(value);
}
inline void ReqCreateGameRoom::set_clubgametypeid(const char* value) {
  set_has_clubgametypeid();
  if (clubgametypeid_ == &::google::protobuf::internal::kEmptyString) {
    clubgametypeid_ = new ::std::string;
  }
  clubgametypeid_->assign(value);
}
inline void ReqCreateGameRoom::set_clubgametypeid(const char* value, size_t size) {
  set_has_clubgametypeid();
  if (clubgametypeid_ == &::google::protobuf::internal::kEmptyString) {
    clubgametypeid_ = new ::std::string;
  }
  clubgametypeid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqCreateGameRoom::mutable_clubgametypeid() {
  set_has_clubgametypeid();
  if (clubgametypeid_ == &::google::protobuf::internal::kEmptyString) {
    clubgametypeid_ = new ::std::string;
  }
  return clubgametypeid_;
}
inline ::std::string* ReqCreateGameRoom::release_clubgametypeid() {
  clear_has_clubgametypeid();
  if (clubgametypeid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = clubgametypeid_;
    clubgametypeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqCreateGameRoom::set_allocated_clubgametypeid(::std::string* clubgametypeid) {
  if (clubgametypeid_ != &::google::protobuf::internal::kEmptyString) {
    delete clubgametypeid_;
  }
  if (clubgametypeid) {
    set_has_clubgametypeid();
    clubgametypeid_ = clubgametypeid;
  } else {
    clear_has_clubgametypeid();
    clubgametypeid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ResCreateGameRoom

// required .ProtoNet.ResponseResult result = 1;
inline bool ResCreateGameRoom::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResCreateGameRoom::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResCreateGameRoom::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResCreateGameRoom::clear_result() {
  if (result_ != NULL) result_->::ProtoNet::ResponseResult::Clear();
  clear_has_result();
}
inline const ::ProtoNet::ResponseResult& ResCreateGameRoom::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::ProtoNet::ResponseResult* ResCreateGameRoom::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::ProtoNet::ResponseResult;
  return result_;
}
inline ::ProtoNet::ResponseResult* ResCreateGameRoom::release_result() {
  clear_has_result();
  ::ProtoNet::ResponseResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline void ResCreateGameRoom::set_allocated_result(::ProtoNet::ResponseResult* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// optional int64 readyTimer = 2;
inline bool ResCreateGameRoom::has_readytimer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResCreateGameRoom::set_has_readytimer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResCreateGameRoom::clear_has_readytimer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResCreateGameRoom::clear_readytimer() {
  readytimer_ = GOOGLE_LONGLONG(0);
  clear_has_readytimer();
}
inline ::google::protobuf::int64 ResCreateGameRoom::readytimer() const {
  return readytimer_;
}
inline void ResCreateGameRoom::set_readytimer(::google::protobuf::int64 value) {
  set_has_readytimer();
  readytimer_ = value;
}

// -------------------------------------------------------------------

// ResNotifyGameRoomCreate

// required string roomId = 1;
inline bool ResNotifyGameRoomCreate::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResNotifyGameRoomCreate::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResNotifyGameRoomCreate::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResNotifyGameRoomCreate::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& ResNotifyGameRoomCreate::roomid() const {
  return *roomid_;
}
inline void ResNotifyGameRoomCreate::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ResNotifyGameRoomCreate::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ResNotifyGameRoomCreate::set_roomid(const char* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResNotifyGameRoomCreate::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  return roomid_;
}
inline ::std::string* ResNotifyGameRoomCreate::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResNotifyGameRoomCreate::set_allocated_roomid(::std::string* roomid) {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomid_;
  }
  if (roomid) {
    set_has_roomid();
    roomid_ = roomid;
  } else {
    clear_has_roomid();
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ReqJoinGameRoom

// required string roomId = 1;
inline bool ReqJoinGameRoom::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqJoinGameRoom::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqJoinGameRoom::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqJoinGameRoom::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& ReqJoinGameRoom::roomid() const {
  return *roomid_;
}
inline void ReqJoinGameRoom::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ReqJoinGameRoom::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ReqJoinGameRoom::set_roomid(const char* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqJoinGameRoom::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  return roomid_;
}
inline ::std::string* ReqJoinGameRoom::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqJoinGameRoom::set_allocated_roomid(::std::string* roomid) {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomid_;
  }
  if (roomid) {
    set_has_roomid();
    roomid_ = roomid;
  } else {
    clear_has_roomid();
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ResJoinGameRoom

// required .ProtoNet.ResponseResult result = 1;
inline bool ResJoinGameRoom::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResJoinGameRoom::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResJoinGameRoom::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResJoinGameRoom::clear_result() {
  if (result_ != NULL) result_->::ProtoNet::ResponseResult::Clear();
  clear_has_result();
}
inline const ::ProtoNet::ResponseResult& ResJoinGameRoom::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::ProtoNet::ResponseResult* ResJoinGameRoom::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::ProtoNet::ResponseResult;
  return result_;
}
inline ::ProtoNet::ResponseResult* ResJoinGameRoom::release_result() {
  clear_has_result();
  ::ProtoNet::ResponseResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline void ResJoinGameRoom::set_allocated_result(::ProtoNet::ResponseResult* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// optional .ProtoNet.RoomInfo roomInfo = 2;
inline bool ResJoinGameRoom::has_roominfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResJoinGameRoom::set_has_roominfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResJoinGameRoom::clear_has_roominfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResJoinGameRoom::clear_roominfo() {
  if (roominfo_ != NULL) roominfo_->::ProtoNet::RoomInfo::Clear();
  clear_has_roominfo();
}
inline const ::ProtoNet::RoomInfo& ResJoinGameRoom::roominfo() const {
  return roominfo_ != NULL ? *roominfo_ : *default_instance_->roominfo_;
}
inline ::ProtoNet::RoomInfo* ResJoinGameRoom::mutable_roominfo() {
  set_has_roominfo();
  if (roominfo_ == NULL) roominfo_ = new ::ProtoNet::RoomInfo;
  return roominfo_;
}
inline ::ProtoNet::RoomInfo* ResJoinGameRoom::release_roominfo() {
  clear_has_roominfo();
  ::ProtoNet::RoomInfo* temp = roominfo_;
  roominfo_ = NULL;
  return temp;
}
inline void ResJoinGameRoom::set_allocated_roominfo(::ProtoNet::RoomInfo* roominfo) {
  delete roominfo_;
  roominfo_ = roominfo;
  if (roominfo) {
    set_has_roominfo();
  } else {
    clear_has_roominfo();
  }
}

// optional int64 readyTimer = 3;
inline bool ResJoinGameRoom::has_readytimer() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResJoinGameRoom::set_has_readytimer() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResJoinGameRoom::clear_has_readytimer() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResJoinGameRoom::clear_readytimer() {
  readytimer_ = GOOGLE_LONGLONG(0);
  clear_has_readytimer();
}
inline ::google::protobuf::int64 ResJoinGameRoom::readytimer() const {
  return readytimer_;
}
inline void ResJoinGameRoom::set_readytimer(::google::protobuf::int64 value) {
  set_has_readytimer();
  readytimer_ = value;
}

// -------------------------------------------------------------------

// ResNotifySomeOneJoinGameRoom

// required string roomId = 1;
inline bool ResNotifySomeOneJoinGameRoom::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResNotifySomeOneJoinGameRoom::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResNotifySomeOneJoinGameRoom::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResNotifySomeOneJoinGameRoom::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& ResNotifySomeOneJoinGameRoom::roomid() const {
  return *roomid_;
}
inline void ResNotifySomeOneJoinGameRoom::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ResNotifySomeOneJoinGameRoom::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ResNotifySomeOneJoinGameRoom::set_roomid(const char* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResNotifySomeOneJoinGameRoom::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  return roomid_;
}
inline ::std::string* ResNotifySomeOneJoinGameRoom::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResNotifySomeOneJoinGameRoom::set_allocated_roomid(::std::string* roomid) {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomid_;
  }
  if (roomid) {
    set_has_roomid();
    roomid_ = roomid;
  } else {
    clear_has_roomid();
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .ProtoNet.SdkController controller = 2;
inline bool ResNotifySomeOneJoinGameRoom::has_controller() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResNotifySomeOneJoinGameRoom::set_has_controller() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResNotifySomeOneJoinGameRoom::clear_has_controller() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResNotifySomeOneJoinGameRoom::clear_controller() {
  if (controller_ != NULL) controller_->::ProtoNet::SdkController::Clear();
  clear_has_controller();
}
inline const ::ProtoNet::SdkController& ResNotifySomeOneJoinGameRoom::controller() const {
  return controller_ != NULL ? *controller_ : *default_instance_->controller_;
}
inline ::ProtoNet::SdkController* ResNotifySomeOneJoinGameRoom::mutable_controller() {
  set_has_controller();
  if (controller_ == NULL) controller_ = new ::ProtoNet::SdkController;
  return controller_;
}
inline ::ProtoNet::SdkController* ResNotifySomeOneJoinGameRoom::release_controller() {
  clear_has_controller();
  ::ProtoNet::SdkController* temp = controller_;
  controller_ = NULL;
  return temp;
}
inline void ResNotifySomeOneJoinGameRoom::set_allocated_controller(::ProtoNet::SdkController* controller) {
  delete controller_;
  controller_ = controller;
  if (controller) {
    set_has_controller();
  } else {
    clear_has_controller();
  }
}

// required .ProtoNet.PosBrife posBrife = 3;
inline bool ResNotifySomeOneJoinGameRoom::has_posbrife() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResNotifySomeOneJoinGameRoom::set_has_posbrife() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResNotifySomeOneJoinGameRoom::clear_has_posbrife() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResNotifySomeOneJoinGameRoom::clear_posbrife() {
  if (posbrife_ != NULL) posbrife_->::ProtoNet::PosBrife::Clear();
  clear_has_posbrife();
}
inline const ::ProtoNet::PosBrife& ResNotifySomeOneJoinGameRoom::posbrife() const {
  return posbrife_ != NULL ? *posbrife_ : *default_instance_->posbrife_;
}
inline ::ProtoNet::PosBrife* ResNotifySomeOneJoinGameRoom::mutable_posbrife() {
  set_has_posbrife();
  if (posbrife_ == NULL) posbrife_ = new ::ProtoNet::PosBrife;
  return posbrife_;
}
inline ::ProtoNet::PosBrife* ResNotifySomeOneJoinGameRoom::release_posbrife() {
  clear_has_posbrife();
  ::ProtoNet::PosBrife* temp = posbrife_;
  posbrife_ = NULL;
  return temp;
}
inline void ResNotifySomeOneJoinGameRoom::set_allocated_posbrife(::ProtoNet::PosBrife* posbrife) {
  delete posbrife_;
  posbrife_ = posbrife;
  if (posbrife) {
    set_has_posbrife();
  } else {
    clear_has_posbrife();
  }
}

// -------------------------------------------------------------------

// ReqExitGameRoom

// -------------------------------------------------------------------

// ResExitGameRoom

// required .ProtoNet.ResponseResult result = 1;
inline bool ResExitGameRoom::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResExitGameRoom::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResExitGameRoom::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResExitGameRoom::clear_result() {
  if (result_ != NULL) result_->::ProtoNet::ResponseResult::Clear();
  clear_has_result();
}
inline const ::ProtoNet::ResponseResult& ResExitGameRoom::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::ProtoNet::ResponseResult* ResExitGameRoom::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::ProtoNet::ResponseResult;
  return result_;
}
inline ::ProtoNet::ResponseResult* ResExitGameRoom::release_result() {
  clear_has_result();
  ::ProtoNet::ResponseResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline void ResExitGameRoom::set_allocated_result(::ProtoNet::ResponseResult* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// -------------------------------------------------------------------

// ResNotifySomeOneExitGameRoom

// required string roomId = 1;
inline bool ResNotifySomeOneExitGameRoom::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResNotifySomeOneExitGameRoom::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResNotifySomeOneExitGameRoom::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResNotifySomeOneExitGameRoom::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& ResNotifySomeOneExitGameRoom::roomid() const {
  return *roomid_;
}
inline void ResNotifySomeOneExitGameRoom::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ResNotifySomeOneExitGameRoom::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ResNotifySomeOneExitGameRoom::set_roomid(const char* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResNotifySomeOneExitGameRoom::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  return roomid_;
}
inline ::std::string* ResNotifySomeOneExitGameRoom::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResNotifySomeOneExitGameRoom::set_allocated_roomid(::std::string* roomid) {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomid_;
  }
  if (roomid) {
    set_has_roomid();
    roomid_ = roomid;
  } else {
    clear_has_roomid();
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .ProtoNet.SdkController controller = 2;
inline bool ResNotifySomeOneExitGameRoom::has_controller() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResNotifySomeOneExitGameRoom::set_has_controller() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResNotifySomeOneExitGameRoom::clear_has_controller() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResNotifySomeOneExitGameRoom::clear_controller() {
  if (controller_ != NULL) controller_->::ProtoNet::SdkController::Clear();
  clear_has_controller();
}
inline const ::ProtoNet::SdkController& ResNotifySomeOneExitGameRoom::controller() const {
  return controller_ != NULL ? *controller_ : *default_instance_->controller_;
}
inline ::ProtoNet::SdkController* ResNotifySomeOneExitGameRoom::mutable_controller() {
  set_has_controller();
  if (controller_ == NULL) controller_ = new ::ProtoNet::SdkController;
  return controller_;
}
inline ::ProtoNet::SdkController* ResNotifySomeOneExitGameRoom::release_controller() {
  clear_has_controller();
  ::ProtoNet::SdkController* temp = controller_;
  controller_ = NULL;
  return temp;
}
inline void ResNotifySomeOneExitGameRoom::set_allocated_controller(::ProtoNet::SdkController* controller) {
  delete controller_;
  controller_ = controller;
  if (controller) {
    set_has_controller();
  } else {
    clear_has_controller();
  }
}

// -------------------------------------------------------------------

// ReqGameReady

// required bool ready = 1;
inline bool ReqGameReady::has_ready() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqGameReady::set_has_ready() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqGameReady::clear_has_ready() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqGameReady::clear_ready() {
  ready_ = false;
  clear_has_ready();
}
inline bool ReqGameReady::ready() const {
  return ready_;
}
inline void ReqGameReady::set_ready(bool value) {
  set_has_ready();
  ready_ = value;
}

// -------------------------------------------------------------------

// ResGameReady

// required .ProtoNet.ResponseResult result = 1;
inline bool ResGameReady::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResGameReady::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResGameReady::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResGameReady::clear_result() {
  if (result_ != NULL) result_->::ProtoNet::ResponseResult::Clear();
  clear_has_result();
}
inline const ::ProtoNet::ResponseResult& ResGameReady::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::ProtoNet::ResponseResult* ResGameReady::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::ProtoNet::ResponseResult;
  return result_;
}
inline ::ProtoNet::ResponseResult* ResGameReady::release_result() {
  clear_has_result();
  ::ProtoNet::ResponseResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline void ResGameReady::set_allocated_result(::ProtoNet::ResponseResult* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// -------------------------------------------------------------------

// ReqDissolutionGameRoom

// -------------------------------------------------------------------

// ResDissolutionGameRoom

// required .ProtoNet.ResponseResult result = 1;
inline bool ResDissolutionGameRoom::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResDissolutionGameRoom::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResDissolutionGameRoom::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResDissolutionGameRoom::clear_result() {
  if (result_ != NULL) result_->::ProtoNet::ResponseResult::Clear();
  clear_has_result();
}
inline const ::ProtoNet::ResponseResult& ResDissolutionGameRoom::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::ProtoNet::ResponseResult* ResDissolutionGameRoom::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::ProtoNet::ResponseResult;
  return result_;
}
inline ::ProtoNet::ResponseResult* ResDissolutionGameRoom::release_result() {
  clear_has_result();
  ::ProtoNet::ResponseResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline void ResDissolutionGameRoom::set_allocated_result(::ProtoNet::ResponseResult* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// -------------------------------------------------------------------

// ResNotifySomeOneReqDissolutionGameRoom

// required string roomId = 1;
inline bool ResNotifySomeOneReqDissolutionGameRoom::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResNotifySomeOneReqDissolutionGameRoom::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResNotifySomeOneReqDissolutionGameRoom::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResNotifySomeOneReqDissolutionGameRoom::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& ResNotifySomeOneReqDissolutionGameRoom::roomid() const {
  return *roomid_;
}
inline void ResNotifySomeOneReqDissolutionGameRoom::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ResNotifySomeOneReqDissolutionGameRoom::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ResNotifySomeOneReqDissolutionGameRoom::set_roomid(const char* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResNotifySomeOneReqDissolutionGameRoom::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  return roomid_;
}
inline ::std::string* ResNotifySomeOneReqDissolutionGameRoom::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResNotifySomeOneReqDissolutionGameRoom::set_allocated_roomid(::std::string* roomid) {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomid_;
  }
  if (roomid) {
    set_has_roomid();
    roomid_ = roomid;
  } else {
    clear_has_roomid();
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .ProtoNet.SdkController controller = 2;
inline bool ResNotifySomeOneReqDissolutionGameRoom::has_controller() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResNotifySomeOneReqDissolutionGameRoom::set_has_controller() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResNotifySomeOneReqDissolutionGameRoom::clear_has_controller() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResNotifySomeOneReqDissolutionGameRoom::clear_controller() {
  if (controller_ != NULL) controller_->::ProtoNet::SdkController::Clear();
  clear_has_controller();
}
inline const ::ProtoNet::SdkController& ResNotifySomeOneReqDissolutionGameRoom::controller() const {
  return controller_ != NULL ? *controller_ : *default_instance_->controller_;
}
inline ::ProtoNet::SdkController* ResNotifySomeOneReqDissolutionGameRoom::mutable_controller() {
  set_has_controller();
  if (controller_ == NULL) controller_ = new ::ProtoNet::SdkController;
  return controller_;
}
inline ::ProtoNet::SdkController* ResNotifySomeOneReqDissolutionGameRoom::release_controller() {
  clear_has_controller();
  ::ProtoNet::SdkController* temp = controller_;
  controller_ = NULL;
  return temp;
}
inline void ResNotifySomeOneReqDissolutionGameRoom::set_allocated_controller(::ProtoNet::SdkController* controller) {
  delete controller_;
  controller_ = controller;
  if (controller) {
    set_has_controller();
  } else {
    clear_has_controller();
  }
}

// required .ProtoNet.PosBrife posBrife = 3;
inline bool ResNotifySomeOneReqDissolutionGameRoom::has_posbrife() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResNotifySomeOneReqDissolutionGameRoom::set_has_posbrife() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResNotifySomeOneReqDissolutionGameRoom::clear_has_posbrife() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResNotifySomeOneReqDissolutionGameRoom::clear_posbrife() {
  if (posbrife_ != NULL) posbrife_->::ProtoNet::PosBrife::Clear();
  clear_has_posbrife();
}
inline const ::ProtoNet::PosBrife& ResNotifySomeOneReqDissolutionGameRoom::posbrife() const {
  return posbrife_ != NULL ? *posbrife_ : *default_instance_->posbrife_;
}
inline ::ProtoNet::PosBrife* ResNotifySomeOneReqDissolutionGameRoom::mutable_posbrife() {
  set_has_posbrife();
  if (posbrife_ == NULL) posbrife_ = new ::ProtoNet::PosBrife;
  return posbrife_;
}
inline ::ProtoNet::PosBrife* ResNotifySomeOneReqDissolutionGameRoom::release_posbrife() {
  clear_has_posbrife();
  ::ProtoNet::PosBrife* temp = posbrife_;
  posbrife_ = NULL;
  return temp;
}
inline void ResNotifySomeOneReqDissolutionGameRoom::set_allocated_posbrife(::ProtoNet::PosBrife* posbrife) {
  delete posbrife_;
  posbrife_ = posbrife;
  if (posbrife) {
    set_has_posbrife();
  } else {
    clear_has_posbrife();
  }
}

// required int64 timer = 4;
inline bool ResNotifySomeOneReqDissolutionGameRoom::has_timer() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResNotifySomeOneReqDissolutionGameRoom::set_has_timer() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResNotifySomeOneReqDissolutionGameRoom::clear_has_timer() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResNotifySomeOneReqDissolutionGameRoom::clear_timer() {
  timer_ = GOOGLE_LONGLONG(0);
  clear_has_timer();
}
inline ::google::protobuf::int64 ResNotifySomeOneReqDissolutionGameRoom::timer() const {
  return timer_;
}
inline void ResNotifySomeOneReqDissolutionGameRoom::set_timer(::google::protobuf::int64 value) {
  set_has_timer();
  timer_ = value;
}

// -------------------------------------------------------------------

// ReqAgreeDissolutionGameRoom

// required bool agree = 1;
inline bool ReqAgreeDissolutionGameRoom::has_agree() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqAgreeDissolutionGameRoom::set_has_agree() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqAgreeDissolutionGameRoom::clear_has_agree() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqAgreeDissolutionGameRoom::clear_agree() {
  agree_ = false;
  clear_has_agree();
}
inline bool ReqAgreeDissolutionGameRoom::agree() const {
  return agree_;
}
inline void ReqAgreeDissolutionGameRoom::set_agree(bool value) {
  set_has_agree();
  agree_ = value;
}

// -------------------------------------------------------------------

// ResAgreeDissolutionGameRoom

// required .ProtoNet.ResponseResult result = 1;
inline bool ResAgreeDissolutionGameRoom::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResAgreeDissolutionGameRoom::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResAgreeDissolutionGameRoom::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResAgreeDissolutionGameRoom::clear_result() {
  if (result_ != NULL) result_->::ProtoNet::ResponseResult::Clear();
  clear_has_result();
}
inline const ::ProtoNet::ResponseResult& ResAgreeDissolutionGameRoom::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::ProtoNet::ResponseResult* ResAgreeDissolutionGameRoom::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::ProtoNet::ResponseResult;
  return result_;
}
inline ::ProtoNet::ResponseResult* ResAgreeDissolutionGameRoom::release_result() {
  clear_has_result();
  ::ProtoNet::ResponseResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline void ResAgreeDissolutionGameRoom::set_allocated_result(::ProtoNet::ResponseResult* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// -------------------------------------------------------------------

// ResNotifySomeOneAggreeDissolutionGameRoom

// required string roomId = 1;
inline bool ResNotifySomeOneAggreeDissolutionGameRoom::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResNotifySomeOneAggreeDissolutionGameRoom::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResNotifySomeOneAggreeDissolutionGameRoom::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResNotifySomeOneAggreeDissolutionGameRoom::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& ResNotifySomeOneAggreeDissolutionGameRoom::roomid() const {
  return *roomid_;
}
inline void ResNotifySomeOneAggreeDissolutionGameRoom::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ResNotifySomeOneAggreeDissolutionGameRoom::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ResNotifySomeOneAggreeDissolutionGameRoom::set_roomid(const char* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResNotifySomeOneAggreeDissolutionGameRoom::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  return roomid_;
}
inline ::std::string* ResNotifySomeOneAggreeDissolutionGameRoom::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResNotifySomeOneAggreeDissolutionGameRoom::set_allocated_roomid(::std::string* roomid) {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomid_;
  }
  if (roomid) {
    set_has_roomid();
    roomid_ = roomid;
  } else {
    clear_has_roomid();
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .ProtoNet.SdkController controller = 2;
inline bool ResNotifySomeOneAggreeDissolutionGameRoom::has_controller() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResNotifySomeOneAggreeDissolutionGameRoom::set_has_controller() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResNotifySomeOneAggreeDissolutionGameRoom::clear_has_controller() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResNotifySomeOneAggreeDissolutionGameRoom::clear_controller() {
  if (controller_ != NULL) controller_->::ProtoNet::SdkController::Clear();
  clear_has_controller();
}
inline const ::ProtoNet::SdkController& ResNotifySomeOneAggreeDissolutionGameRoom::controller() const {
  return controller_ != NULL ? *controller_ : *default_instance_->controller_;
}
inline ::ProtoNet::SdkController* ResNotifySomeOneAggreeDissolutionGameRoom::mutable_controller() {
  set_has_controller();
  if (controller_ == NULL) controller_ = new ::ProtoNet::SdkController;
  return controller_;
}
inline ::ProtoNet::SdkController* ResNotifySomeOneAggreeDissolutionGameRoom::release_controller() {
  clear_has_controller();
  ::ProtoNet::SdkController* temp = controller_;
  controller_ = NULL;
  return temp;
}
inline void ResNotifySomeOneAggreeDissolutionGameRoom::set_allocated_controller(::ProtoNet::SdkController* controller) {
  delete controller_;
  controller_ = controller;
  if (controller) {
    set_has_controller();
  } else {
    clear_has_controller();
  }
}

// required .ProtoNet.PosBrife posBrife = 3;
inline bool ResNotifySomeOneAggreeDissolutionGameRoom::has_posbrife() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResNotifySomeOneAggreeDissolutionGameRoom::set_has_posbrife() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResNotifySomeOneAggreeDissolutionGameRoom::clear_has_posbrife() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResNotifySomeOneAggreeDissolutionGameRoom::clear_posbrife() {
  if (posbrife_ != NULL) posbrife_->::ProtoNet::PosBrife::Clear();
  clear_has_posbrife();
}
inline const ::ProtoNet::PosBrife& ResNotifySomeOneAggreeDissolutionGameRoom::posbrife() const {
  return posbrife_ != NULL ? *posbrife_ : *default_instance_->posbrife_;
}
inline ::ProtoNet::PosBrife* ResNotifySomeOneAggreeDissolutionGameRoom::mutable_posbrife() {
  set_has_posbrife();
  if (posbrife_ == NULL) posbrife_ = new ::ProtoNet::PosBrife;
  return posbrife_;
}
inline ::ProtoNet::PosBrife* ResNotifySomeOneAggreeDissolutionGameRoom::release_posbrife() {
  clear_has_posbrife();
  ::ProtoNet::PosBrife* temp = posbrife_;
  posbrife_ = NULL;
  return temp;
}
inline void ResNotifySomeOneAggreeDissolutionGameRoom::set_allocated_posbrife(::ProtoNet::PosBrife* posbrife) {
  delete posbrife_;
  posbrife_ = posbrife;
  if (posbrife) {
    set_has_posbrife();
  } else {
    clear_has_posbrife();
  }
}

// required bool agree = 4;
inline bool ResNotifySomeOneAggreeDissolutionGameRoom::has_agree() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResNotifySomeOneAggreeDissolutionGameRoom::set_has_agree() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResNotifySomeOneAggreeDissolutionGameRoom::clear_has_agree() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResNotifySomeOneAggreeDissolutionGameRoom::clear_agree() {
  agree_ = false;
  clear_has_agree();
}
inline bool ResNotifySomeOneAggreeDissolutionGameRoom::agree() const {
  return agree_;
}
inline void ResNotifySomeOneAggreeDissolutionGameRoom::set_agree(bool value) {
  set_has_agree();
  agree_ = value;
}

// -------------------------------------------------------------------

// ResNotifyGameRoomDissolution

// -------------------------------------------------------------------

// ResNotifyGameOver

// -------------------------------------------------------------------

// ReqGetRoomInfo

// -------------------------------------------------------------------

// ResGetRoomInfo

// required .ProtoNet.ResponseResult result = 1;
inline bool ResGetRoomInfo::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResGetRoomInfo::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResGetRoomInfo::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResGetRoomInfo::clear_result() {
  if (result_ != NULL) result_->::ProtoNet::ResponseResult::Clear();
  clear_has_result();
}
inline const ::ProtoNet::ResponseResult& ResGetRoomInfo::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::ProtoNet::ResponseResult* ResGetRoomInfo::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::ProtoNet::ResponseResult;
  return result_;
}
inline ::ProtoNet::ResponseResult* ResGetRoomInfo::release_result() {
  clear_has_result();
  ::ProtoNet::ResponseResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline void ResGetRoomInfo::set_allocated_result(::ProtoNet::ResponseResult* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// optional .ProtoNet.RoomInfo roomInfo = 2;
inline bool ResGetRoomInfo::has_roominfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResGetRoomInfo::set_has_roominfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResGetRoomInfo::clear_has_roominfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResGetRoomInfo::clear_roominfo() {
  if (roominfo_ != NULL) roominfo_->::ProtoNet::RoomInfo::Clear();
  clear_has_roominfo();
}
inline const ::ProtoNet::RoomInfo& ResGetRoomInfo::roominfo() const {
  return roominfo_ != NULL ? *roominfo_ : *default_instance_->roominfo_;
}
inline ::ProtoNet::RoomInfo* ResGetRoomInfo::mutable_roominfo() {
  set_has_roominfo();
  if (roominfo_ == NULL) roominfo_ = new ::ProtoNet::RoomInfo;
  return roominfo_;
}
inline ::ProtoNet::RoomInfo* ResGetRoomInfo::release_roominfo() {
  clear_has_roominfo();
  ::ProtoNet::RoomInfo* temp = roominfo_;
  roominfo_ = NULL;
  return temp;
}
inline void ResGetRoomInfo::set_allocated_roominfo(::ProtoNet::RoomInfo* roominfo) {
  delete roominfo_;
  roominfo_ = roominfo;
  if (roominfo) {
    set_has_roominfo();
  } else {
    clear_has_roominfo();
  }
}

// -------------------------------------------------------------------

// ResNotifySomeOneGameReady

// required string roomId = 1;
inline bool ResNotifySomeOneGameReady::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResNotifySomeOneGameReady::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResNotifySomeOneGameReady::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResNotifySomeOneGameReady::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& ResNotifySomeOneGameReady::roomid() const {
  return *roomid_;
}
inline void ResNotifySomeOneGameReady::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ResNotifySomeOneGameReady::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ResNotifySomeOneGameReady::set_roomid(const char* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResNotifySomeOneGameReady::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  return roomid_;
}
inline ::std::string* ResNotifySomeOneGameReady::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResNotifySomeOneGameReady::set_allocated_roomid(::std::string* roomid) {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomid_;
  }
  if (roomid) {
    set_has_roomid();
    roomid_ = roomid;
  } else {
    clear_has_roomid();
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .ProtoNet.SdkController controller = 2;
inline bool ResNotifySomeOneGameReady::has_controller() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResNotifySomeOneGameReady::set_has_controller() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResNotifySomeOneGameReady::clear_has_controller() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResNotifySomeOneGameReady::clear_controller() {
  if (controller_ != NULL) controller_->::ProtoNet::SdkController::Clear();
  clear_has_controller();
}
inline const ::ProtoNet::SdkController& ResNotifySomeOneGameReady::controller() const {
  return controller_ != NULL ? *controller_ : *default_instance_->controller_;
}
inline ::ProtoNet::SdkController* ResNotifySomeOneGameReady::mutable_controller() {
  set_has_controller();
  if (controller_ == NULL) controller_ = new ::ProtoNet::SdkController;
  return controller_;
}
inline ::ProtoNet::SdkController* ResNotifySomeOneGameReady::release_controller() {
  clear_has_controller();
  ::ProtoNet::SdkController* temp = controller_;
  controller_ = NULL;
  return temp;
}
inline void ResNotifySomeOneGameReady::set_allocated_controller(::ProtoNet::SdkController* controller) {
  delete controller_;
  controller_ = controller;
  if (controller) {
    set_has_controller();
  } else {
    clear_has_controller();
  }
}

// required .ProtoNet.PosBrife posBrife = 3;
inline bool ResNotifySomeOneGameReady::has_posbrife() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResNotifySomeOneGameReady::set_has_posbrife() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResNotifySomeOneGameReady::clear_has_posbrife() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResNotifySomeOneGameReady::clear_posbrife() {
  if (posbrife_ != NULL) posbrife_->::ProtoNet::PosBrife::Clear();
  clear_has_posbrife();
}
inline const ::ProtoNet::PosBrife& ResNotifySomeOneGameReady::posbrife() const {
  return posbrife_ != NULL ? *posbrife_ : *default_instance_->posbrife_;
}
inline ::ProtoNet::PosBrife* ResNotifySomeOneGameReady::mutable_posbrife() {
  set_has_posbrife();
  if (posbrife_ == NULL) posbrife_ = new ::ProtoNet::PosBrife;
  return posbrife_;
}
inline ::ProtoNet::PosBrife* ResNotifySomeOneGameReady::release_posbrife() {
  clear_has_posbrife();
  ::ProtoNet::PosBrife* temp = posbrife_;
  posbrife_ = NULL;
  return temp;
}
inline void ResNotifySomeOneGameReady::set_allocated_posbrife(::ProtoNet::PosBrife* posbrife) {
  delete posbrife_;
  posbrife_ = posbrife;
  if (posbrife) {
    set_has_posbrife();
  } else {
    clear_has_posbrife();
  }
}

// required bool ready = 4;
inline bool ResNotifySomeOneGameReady::has_ready() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResNotifySomeOneGameReady::set_has_ready() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResNotifySomeOneGameReady::clear_has_ready() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResNotifySomeOneGameReady::clear_ready() {
  ready_ = false;
  clear_has_ready();
}
inline bool ResNotifySomeOneGameReady::ready() const {
  return ready_;
}
inline void ResNotifySomeOneGameReady::set_ready(bool value) {
  set_has_ready();
  ready_ = value;
}

// -------------------------------------------------------------------

// ReqChangeOnlineStatus

// required bool online = 1;
inline bool ReqChangeOnlineStatus::has_online() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqChangeOnlineStatus::set_has_online() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqChangeOnlineStatus::clear_has_online() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqChangeOnlineStatus::clear_online() {
  online_ = false;
  clear_has_online();
}
inline bool ReqChangeOnlineStatus::online() const {
  return online_;
}
inline void ReqChangeOnlineStatus::set_online(bool value) {
  set_has_online();
  online_ = value;
}

// -------------------------------------------------------------------

// ResChangeOnlineStatus

// required .ProtoNet.ResponseResult result = 1;
inline bool ResChangeOnlineStatus::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResChangeOnlineStatus::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResChangeOnlineStatus::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResChangeOnlineStatus::clear_result() {
  if (result_ != NULL) result_->::ProtoNet::ResponseResult::Clear();
  clear_has_result();
}
inline const ::ProtoNet::ResponseResult& ResChangeOnlineStatus::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::ProtoNet::ResponseResult* ResChangeOnlineStatus::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::ProtoNet::ResponseResult;
  return result_;
}
inline ::ProtoNet::ResponseResult* ResChangeOnlineStatus::release_result() {
  clear_has_result();
  ::ProtoNet::ResponseResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline void ResChangeOnlineStatus::set_allocated_result(::ProtoNet::ResponseResult* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// -------------------------------------------------------------------

// ResNotifySomeOneChangeOnlineStatus

// required string roomId = 1;
inline bool ResNotifySomeOneChangeOnlineStatus::has_roomid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResNotifySomeOneChangeOnlineStatus::set_has_roomid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResNotifySomeOneChangeOnlineStatus::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResNotifySomeOneChangeOnlineStatus::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& ResNotifySomeOneChangeOnlineStatus::roomid() const {
  return *roomid_;
}
inline void ResNotifySomeOneChangeOnlineStatus::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ResNotifySomeOneChangeOnlineStatus::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ResNotifySomeOneChangeOnlineStatus::set_roomid(const char* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResNotifySomeOneChangeOnlineStatus::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  return roomid_;
}
inline ::std::string* ResNotifySomeOneChangeOnlineStatus::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResNotifySomeOneChangeOnlineStatus::set_allocated_roomid(::std::string* roomid) {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomid_;
  }
  if (roomid) {
    set_has_roomid();
    roomid_ = roomid;
  } else {
    clear_has_roomid();
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .ProtoNet.SdkController controller = 2;
inline bool ResNotifySomeOneChangeOnlineStatus::has_controller() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResNotifySomeOneChangeOnlineStatus::set_has_controller() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResNotifySomeOneChangeOnlineStatus::clear_has_controller() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResNotifySomeOneChangeOnlineStatus::clear_controller() {
  if (controller_ != NULL) controller_->::ProtoNet::SdkController::Clear();
  clear_has_controller();
}
inline const ::ProtoNet::SdkController& ResNotifySomeOneChangeOnlineStatus::controller() const {
  return controller_ != NULL ? *controller_ : *default_instance_->controller_;
}
inline ::ProtoNet::SdkController* ResNotifySomeOneChangeOnlineStatus::mutable_controller() {
  set_has_controller();
  if (controller_ == NULL) controller_ = new ::ProtoNet::SdkController;
  return controller_;
}
inline ::ProtoNet::SdkController* ResNotifySomeOneChangeOnlineStatus::release_controller() {
  clear_has_controller();
  ::ProtoNet::SdkController* temp = controller_;
  controller_ = NULL;
  return temp;
}
inline void ResNotifySomeOneChangeOnlineStatus::set_allocated_controller(::ProtoNet::SdkController* controller) {
  delete controller_;
  controller_ = controller;
  if (controller) {
    set_has_controller();
  } else {
    clear_has_controller();
  }
}

// required .ProtoNet.PosBrife posBrife = 3;
inline bool ResNotifySomeOneChangeOnlineStatus::has_posbrife() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResNotifySomeOneChangeOnlineStatus::set_has_posbrife() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResNotifySomeOneChangeOnlineStatus::clear_has_posbrife() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResNotifySomeOneChangeOnlineStatus::clear_posbrife() {
  if (posbrife_ != NULL) posbrife_->::ProtoNet::PosBrife::Clear();
  clear_has_posbrife();
}
inline const ::ProtoNet::PosBrife& ResNotifySomeOneChangeOnlineStatus::posbrife() const {
  return posbrife_ != NULL ? *posbrife_ : *default_instance_->posbrife_;
}
inline ::ProtoNet::PosBrife* ResNotifySomeOneChangeOnlineStatus::mutable_posbrife() {
  set_has_posbrife();
  if (posbrife_ == NULL) posbrife_ = new ::ProtoNet::PosBrife;
  return posbrife_;
}
inline ::ProtoNet::PosBrife* ResNotifySomeOneChangeOnlineStatus::release_posbrife() {
  clear_has_posbrife();
  ::ProtoNet::PosBrife* temp = posbrife_;
  posbrife_ = NULL;
  return temp;
}
inline void ResNotifySomeOneChangeOnlineStatus::set_allocated_posbrife(::ProtoNet::PosBrife* posbrife) {
  delete posbrife_;
  posbrife_ = posbrife;
  if (posbrife) {
    set_has_posbrife();
  } else {
    clear_has_posbrife();
  }
}

// required bool online = 4;
inline bool ResNotifySomeOneChangeOnlineStatus::has_online() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResNotifySomeOneChangeOnlineStatus::set_has_online() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResNotifySomeOneChangeOnlineStatus::clear_has_online() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResNotifySomeOneChangeOnlineStatus::clear_online() {
  online_ = false;
  clear_has_online();
}
inline bool ResNotifySomeOneChangeOnlineStatus::online() const {
  return online_;
}
inline void ResNotifySomeOneChangeOnlineStatus::set_online(bool value) {
  set_has_online();
  online_ = value;
}

// -------------------------------------------------------------------

// ResNotifyBigCalculatePanel

// -------------------------------------------------------------------

// ReqCorrectTimer

// -------------------------------------------------------------------

// ResCorrectTimer

// required .ProtoNet.ResponseResult result = 1;
inline bool ResCorrectTimer::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResCorrectTimer::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResCorrectTimer::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResCorrectTimer::clear_result() {
  if (result_ != NULL) result_->::ProtoNet::ResponseResult::Clear();
  clear_has_result();
}
inline const ::ProtoNet::ResponseResult& ResCorrectTimer::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::ProtoNet::ResponseResult* ResCorrectTimer::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::ProtoNet::ResponseResult;
  return result_;
}
inline ::ProtoNet::ResponseResult* ResCorrectTimer::release_result() {
  clear_has_result();
  ::ProtoNet::ResponseResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline void ResCorrectTimer::set_allocated_result(::ProtoNet::ResponseResult* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// optional int64 leftDissolutionTimer = 2;
inline bool ResCorrectTimer::has_leftdissolutiontimer() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResCorrectTimer::set_has_leftdissolutiontimer() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResCorrectTimer::clear_has_leftdissolutiontimer() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResCorrectTimer::clear_leftdissolutiontimer() {
  leftdissolutiontimer_ = GOOGLE_LONGLONG(0);
  clear_has_leftdissolutiontimer();
}
inline ::google::protobuf::int64 ResCorrectTimer::leftdissolutiontimer() const {
  return leftdissolutiontimer_;
}
inline void ResCorrectTimer::set_leftdissolutiontimer(::google::protobuf::int64 value) {
  set_has_leftdissolutiontimer();
  leftdissolutiontimer_ = value;
}

// -------------------------------------------------------------------

// ReqQuickChangeRoom

// optional string pipeiParam = 1;
inline bool ReqQuickChangeRoom::has_pipeiparam() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqQuickChangeRoom::set_has_pipeiparam() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqQuickChangeRoom::clear_has_pipeiparam() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqQuickChangeRoom::clear_pipeiparam() {
  if (pipeiparam_ != &::google::protobuf::internal::kEmptyString) {
    pipeiparam_->clear();
  }
  clear_has_pipeiparam();
}
inline const ::std::string& ReqQuickChangeRoom::pipeiparam() const {
  return *pipeiparam_;
}
inline void ReqQuickChangeRoom::set_pipeiparam(const ::std::string& value) {
  set_has_pipeiparam();
  if (pipeiparam_ == &::google::protobuf::internal::kEmptyString) {
    pipeiparam_ = new ::std::string;
  }
  pipeiparam_->assign(value);
}
inline void ReqQuickChangeRoom::set_pipeiparam(const char* value) {
  set_has_pipeiparam();
  if (pipeiparam_ == &::google::protobuf::internal::kEmptyString) {
    pipeiparam_ = new ::std::string;
  }
  pipeiparam_->assign(value);
}
inline void ReqQuickChangeRoom::set_pipeiparam(const char* value, size_t size) {
  set_has_pipeiparam();
  if (pipeiparam_ == &::google::protobuf::internal::kEmptyString) {
    pipeiparam_ = new ::std::string;
  }
  pipeiparam_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqQuickChangeRoom::mutable_pipeiparam() {
  set_has_pipeiparam();
  if (pipeiparam_ == &::google::protobuf::internal::kEmptyString) {
    pipeiparam_ = new ::std::string;
  }
  return pipeiparam_;
}
inline ::std::string* ReqQuickChangeRoom::release_pipeiparam() {
  clear_has_pipeiparam();
  if (pipeiparam_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pipeiparam_;
    pipeiparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqQuickChangeRoom::set_allocated_pipeiparam(::std::string* pipeiparam) {
  if (pipeiparam_ != &::google::protobuf::internal::kEmptyString) {
    delete pipeiparam_;
  }
  if (pipeiparam) {
    set_has_pipeiparam();
    pipeiparam_ = pipeiparam;
  } else {
    clear_has_pipeiparam();
    pipeiparam_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ResQuickChangeRoom

// required .ProtoNet.ResponseResult result = 1;
inline bool ResQuickChangeRoom::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResQuickChangeRoom::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResQuickChangeRoom::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResQuickChangeRoom::clear_result() {
  if (result_ != NULL) result_->::ProtoNet::ResponseResult::Clear();
  clear_has_result();
}
inline const ::ProtoNet::ResponseResult& ResQuickChangeRoom::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::ProtoNet::ResponseResult* ResQuickChangeRoom::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::ProtoNet::ResponseResult;
  return result_;
}
inline ::ProtoNet::ResponseResult* ResQuickChangeRoom::release_result() {
  clear_has_result();
  ::ProtoNet::ResponseResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline void ResQuickChangeRoom::set_allocated_result(::ProtoNet::ResponseResult* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// optional int32 operate = 2;
inline bool ResQuickChangeRoom::has_operate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResQuickChangeRoom::set_has_operate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResQuickChangeRoom::clear_has_operate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResQuickChangeRoom::clear_operate() {
  operate_ = 0;
  clear_has_operate();
}
inline ::google::protobuf::int32 ResQuickChangeRoom::operate() const {
  return operate_;
}
inline void ResQuickChangeRoom::set_operate(::google::protobuf::int32 value) {
  set_has_operate();
  operate_ = value;
}

// optional int32 roomType = 3;
inline bool ResQuickChangeRoom::has_roomtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResQuickChangeRoom::set_has_roomtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResQuickChangeRoom::clear_has_roomtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResQuickChangeRoom::clear_roomtype() {
  roomtype_ = 0;
  clear_has_roomtype();
}
inline ::google::protobuf::int32 ResQuickChangeRoom::roomtype() const {
  return roomtype_;
}
inline void ResQuickChangeRoom::set_roomtype(::google::protobuf::int32 value) {
  set_has_roomtype();
  roomtype_ = value;
}

// optional .ProtoNet.ServerInfoIpsSafeDetail bestServerInfo = 4;
inline bool ResQuickChangeRoom::has_bestserverinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResQuickChangeRoom::set_has_bestserverinfo() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResQuickChangeRoom::clear_has_bestserverinfo() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResQuickChangeRoom::clear_bestserverinfo() {
  if (bestserverinfo_ != NULL) bestserverinfo_->::ProtoNet::ServerInfoIpsSafeDetail::Clear();
  clear_has_bestserverinfo();
}
inline const ::ProtoNet::ServerInfoIpsSafeDetail& ResQuickChangeRoom::bestserverinfo() const {
  return bestserverinfo_ != NULL ? *bestserverinfo_ : *default_instance_->bestserverinfo_;
}
inline ::ProtoNet::ServerInfoIpsSafeDetail* ResQuickChangeRoom::mutable_bestserverinfo() {
  set_has_bestserverinfo();
  if (bestserverinfo_ == NULL) bestserverinfo_ = new ::ProtoNet::ServerInfoIpsSafeDetail;
  return bestserverinfo_;
}
inline ::ProtoNet::ServerInfoIpsSafeDetail* ResQuickChangeRoom::release_bestserverinfo() {
  clear_has_bestserverinfo();
  ::ProtoNet::ServerInfoIpsSafeDetail* temp = bestserverinfo_;
  bestserverinfo_ = NULL;
  return temp;
}
inline void ResQuickChangeRoom::set_allocated_bestserverinfo(::ProtoNet::ServerInfoIpsSafeDetail* bestserverinfo) {
  delete bestserverinfo_;
  bestserverinfo_ = bestserverinfo;
  if (bestserverinfo) {
    set_has_bestserverinfo();
  } else {
    clear_has_bestserverinfo();
  }
}

// optional string roomId = 5;
inline bool ResQuickChangeRoom::has_roomid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResQuickChangeRoom::set_has_roomid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResQuickChangeRoom::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResQuickChangeRoom::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& ResQuickChangeRoom::roomid() const {
  return *roomid_;
}
inline void ResQuickChangeRoom::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ResQuickChangeRoom::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ResQuickChangeRoom::set_roomid(const char* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResQuickChangeRoom::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  return roomid_;
}
inline ::std::string* ResQuickChangeRoom::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResQuickChangeRoom::set_allocated_roomid(::std::string* roomid) {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomid_;
  }
  if (roomid) {
    set_has_roomid();
    roomid_ = roomid;
  } else {
    clear_has_roomid();
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .ProtoNet.ServerInfoIpsSafeDetail logicDetails = 6;
inline int ResQuickChangeRoom::logicdetails_size() const {
  return logicdetails_.size();
}
inline void ResQuickChangeRoom::clear_logicdetails() {
  logicdetails_.Clear();
}
inline const ::ProtoNet::ServerInfoIpsSafeDetail& ResQuickChangeRoom::logicdetails(int index) const {
  return logicdetails_.Get(index);
}
inline ::ProtoNet::ServerInfoIpsSafeDetail* ResQuickChangeRoom::mutable_logicdetails(int index) {
  return logicdetails_.Mutable(index);
}
inline ::ProtoNet::ServerInfoIpsSafeDetail* ResQuickChangeRoom::add_logicdetails() {
  return logicdetails_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::ServerInfoIpsSafeDetail >&
ResQuickChangeRoom::logicdetails() const {
  return logicdetails_;
}
inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::ServerInfoIpsSafeDetail >*
ResQuickChangeRoom::mutable_logicdetails() {
  return &logicdetails_;
}

// optional int32 gameId = 7;
inline bool ResQuickChangeRoom::has_gameid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ResQuickChangeRoom::set_has_gameid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ResQuickChangeRoom::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ResQuickChangeRoom::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 ResQuickChangeRoom::gameid() const {
  return gameid_;
}
inline void ResQuickChangeRoom::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional int32 timesType = 8;
inline bool ResQuickChangeRoom::has_timestype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ResQuickChangeRoom::set_has_timestype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ResQuickChangeRoom::clear_has_timestype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ResQuickChangeRoom::clear_timestype() {
  timestype_ = 0;
  clear_has_timestype();
}
inline ::google::protobuf::int32 ResQuickChangeRoom::timestype() const {
  return timestype_;
}
inline void ResQuickChangeRoom::set_timestype(::google::protobuf::int32 value) {
  set_has_timestype();
  timestype_ = value;
}

// required int32 changeServer = 9;
inline bool ResQuickChangeRoom::has_changeserver() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ResQuickChangeRoom::set_has_changeserver() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ResQuickChangeRoom::clear_has_changeserver() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ResQuickChangeRoom::clear_changeserver() {
  changeserver_ = 0;
  clear_has_changeserver();
}
inline ::google::protobuf::int32 ResQuickChangeRoom::changeserver() const {
  return changeserver_;
}
inline void ResQuickChangeRoom::set_changeserver(::google::protobuf::int32 value) {
  set_has_changeserver();
  changeserver_ = value;
}

// -------------------------------------------------------------------

// ResNotifySomeOneChangeRobot

// required int32 isRobot = 1;
inline bool ResNotifySomeOneChangeRobot::has_isrobot() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResNotifySomeOneChangeRobot::set_has_isrobot() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResNotifySomeOneChangeRobot::clear_has_isrobot() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResNotifySomeOneChangeRobot::clear_isrobot() {
  isrobot_ = 0;
  clear_has_isrobot();
}
inline ::google::protobuf::int32 ResNotifySomeOneChangeRobot::isrobot() const {
  return isrobot_;
}
inline void ResNotifySomeOneChangeRobot::set_isrobot(::google::protobuf::int32 value) {
  set_has_isrobot();
  isrobot_ = value;
}

// required string uniqueId = 2;
inline bool ResNotifySomeOneChangeRobot::has_uniqueid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResNotifySomeOneChangeRobot::set_has_uniqueid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResNotifySomeOneChangeRobot::clear_has_uniqueid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResNotifySomeOneChangeRobot::clear_uniqueid() {
  if (uniqueid_ != &::google::protobuf::internal::kEmptyString) {
    uniqueid_->clear();
  }
  clear_has_uniqueid();
}
inline const ::std::string& ResNotifySomeOneChangeRobot::uniqueid() const {
  return *uniqueid_;
}
inline void ResNotifySomeOneChangeRobot::set_uniqueid(const ::std::string& value) {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  uniqueid_->assign(value);
}
inline void ResNotifySomeOneChangeRobot::set_uniqueid(const char* value) {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  uniqueid_->assign(value);
}
inline void ResNotifySomeOneChangeRobot::set_uniqueid(const char* value, size_t size) {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  uniqueid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResNotifySomeOneChangeRobot::mutable_uniqueid() {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  return uniqueid_;
}
inline ::std::string* ResNotifySomeOneChangeRobot::release_uniqueid() {
  clear_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uniqueid_;
    uniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResNotifySomeOneChangeRobot::set_allocated_uniqueid(::std::string* uniqueid) {
  if (uniqueid_ != &::google::protobuf::internal::kEmptyString) {
    delete uniqueid_;
  }
  if (uniqueid) {
    set_has_uniqueid();
    uniqueid_ = uniqueid;
  } else {
    clear_has_uniqueid();
    uniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 pos = 3;
inline bool ResNotifySomeOneChangeRobot::has_pos() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResNotifySomeOneChangeRobot::set_has_pos() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResNotifySomeOneChangeRobot::clear_has_pos() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResNotifySomeOneChangeRobot::clear_pos() {
  pos_ = 0;
  clear_has_pos();
}
inline ::google::protobuf::int32 ResNotifySomeOneChangeRobot::pos() const {
  return pos_;
}
inline void ResNotifySomeOneChangeRobot::set_pos(::google::protobuf::int32 value) {
  set_has_pos();
  pos_ = value;
}

// -------------------------------------------------------------------

// ResNotifyChangeToOldRoom

// optional .ProtoNet.ServerInfoIpsSafeDetail bestServerInfo = 1;
inline bool ResNotifyChangeToOldRoom::has_bestserverinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResNotifyChangeToOldRoom::set_has_bestserverinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResNotifyChangeToOldRoom::clear_has_bestserverinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResNotifyChangeToOldRoom::clear_bestserverinfo() {
  if (bestserverinfo_ != NULL) bestserverinfo_->::ProtoNet::ServerInfoIpsSafeDetail::Clear();
  clear_has_bestserverinfo();
}
inline const ::ProtoNet::ServerInfoIpsSafeDetail& ResNotifyChangeToOldRoom::bestserverinfo() const {
  return bestserverinfo_ != NULL ? *bestserverinfo_ : *default_instance_->bestserverinfo_;
}
inline ::ProtoNet::ServerInfoIpsSafeDetail* ResNotifyChangeToOldRoom::mutable_bestserverinfo() {
  set_has_bestserverinfo();
  if (bestserverinfo_ == NULL) bestserverinfo_ = new ::ProtoNet::ServerInfoIpsSafeDetail;
  return bestserverinfo_;
}
inline ::ProtoNet::ServerInfoIpsSafeDetail* ResNotifyChangeToOldRoom::release_bestserverinfo() {
  clear_has_bestserverinfo();
  ::ProtoNet::ServerInfoIpsSafeDetail* temp = bestserverinfo_;
  bestserverinfo_ = NULL;
  return temp;
}
inline void ResNotifyChangeToOldRoom::set_allocated_bestserverinfo(::ProtoNet::ServerInfoIpsSafeDetail* bestserverinfo) {
  delete bestserverinfo_;
  bestserverinfo_ = bestserverinfo;
  if (bestserverinfo) {
    set_has_bestserverinfo();
  } else {
    clear_has_bestserverinfo();
  }
}

// optional string roomId = 2;
inline bool ResNotifyChangeToOldRoom::has_roomid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResNotifyChangeToOldRoom::set_has_roomid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResNotifyChangeToOldRoom::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResNotifyChangeToOldRoom::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& ResNotifyChangeToOldRoom::roomid() const {
  return *roomid_;
}
inline void ResNotifyChangeToOldRoom::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ResNotifyChangeToOldRoom::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ResNotifyChangeToOldRoom::set_roomid(const char* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResNotifyChangeToOldRoom::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  return roomid_;
}
inline ::std::string* ResNotifyChangeToOldRoom::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResNotifyChangeToOldRoom::set_allocated_roomid(::std::string* roomid) {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomid_;
  }
  if (roomid) {
    set_has_roomid();
    roomid_ = roomid;
  } else {
    clear_has_roomid();
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 gameId = 3;
inline bool ResNotifyChangeToOldRoom::has_gameid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResNotifyChangeToOldRoom::set_has_gameid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResNotifyChangeToOldRoom::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResNotifyChangeToOldRoom::clear_gameid() {
  gameid_ = 0;
  clear_has_gameid();
}
inline ::google::protobuf::int32 ResNotifyChangeToOldRoom::gameid() const {
  return gameid_;
}
inline void ResNotifyChangeToOldRoom::set_gameid(::google::protobuf::int32 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional int32 timesType = 4;
inline bool ResNotifyChangeToOldRoom::has_timestype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResNotifyChangeToOldRoom::set_has_timestype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResNotifyChangeToOldRoom::clear_has_timestype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResNotifyChangeToOldRoom::clear_timestype() {
  timestype_ = 0;
  clear_has_timestype();
}
inline ::google::protobuf::int32 ResNotifyChangeToOldRoom::timestype() const {
  return timestype_;
}
inline void ResNotifyChangeToOldRoom::set_timestype(::google::protobuf::int32 value) {
  set_has_timestype();
  timestype_ = value;
}

// optional int32 roomType = 5;
inline bool ResNotifyChangeToOldRoom::has_roomtype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ResNotifyChangeToOldRoom::set_has_roomtype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ResNotifyChangeToOldRoom::clear_has_roomtype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ResNotifyChangeToOldRoom::clear_roomtype() {
  roomtype_ = 0;
  clear_has_roomtype();
}
inline ::google::protobuf::int32 ResNotifyChangeToOldRoom::roomtype() const {
  return roomtype_;
}
inline void ResNotifyChangeToOldRoom::set_roomtype(::google::protobuf::int32 value) {
  set_has_roomtype();
  roomtype_ = value;
}

// -------------------------------------------------------------------

// ReqSitDown

// optional int32 pos = 1;
inline bool ReqSitDown::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqSitDown::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqSitDown::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqSitDown::clear_pos() {
  pos_ = 0;
  clear_has_pos();
}
inline ::google::protobuf::int32 ReqSitDown::pos() const {
  return pos_;
}
inline void ReqSitDown::set_pos(::google::protobuf::int32 value) {
  set_has_pos();
  pos_ = value;
}

// -------------------------------------------------------------------

// ResSitDown

// required .ProtoNet.ResponseResult result = 1;
inline bool ResSitDown::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResSitDown::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResSitDown::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResSitDown::clear_result() {
  if (result_ != NULL) result_->::ProtoNet::ResponseResult::Clear();
  clear_has_result();
}
inline const ::ProtoNet::ResponseResult& ResSitDown::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::ProtoNet::ResponseResult* ResSitDown::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::ProtoNet::ResponseResult;
  return result_;
}
inline ::ProtoNet::ResponseResult* ResSitDown::release_result() {
  clear_has_result();
  ::ProtoNet::ResponseResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline void ResSitDown::set_allocated_result(::ProtoNet::ResponseResult* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// -------------------------------------------------------------------

// ResNotifySomeOneSitDown

// required int32 pos = 1;
inline bool ResNotifySomeOneSitDown::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResNotifySomeOneSitDown::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResNotifySomeOneSitDown::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResNotifySomeOneSitDown::clear_pos() {
  pos_ = 0;
  clear_has_pos();
}
inline ::google::protobuf::int32 ResNotifySomeOneSitDown::pos() const {
  return pos_;
}
inline void ResNotifySomeOneSitDown::set_pos(::google::protobuf::int32 value) {
  set_has_pos();
  pos_ = value;
}

// required .ProtoNet.SdkController controller = 2;
inline bool ResNotifySomeOneSitDown::has_controller() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResNotifySomeOneSitDown::set_has_controller() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResNotifySomeOneSitDown::clear_has_controller() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResNotifySomeOneSitDown::clear_controller() {
  if (controller_ != NULL) controller_->::ProtoNet::SdkController::Clear();
  clear_has_controller();
}
inline const ::ProtoNet::SdkController& ResNotifySomeOneSitDown::controller() const {
  return controller_ != NULL ? *controller_ : *default_instance_->controller_;
}
inline ::ProtoNet::SdkController* ResNotifySomeOneSitDown::mutable_controller() {
  set_has_controller();
  if (controller_ == NULL) controller_ = new ::ProtoNet::SdkController;
  return controller_;
}
inline ::ProtoNet::SdkController* ResNotifySomeOneSitDown::release_controller() {
  clear_has_controller();
  ::ProtoNet::SdkController* temp = controller_;
  controller_ = NULL;
  return temp;
}
inline void ResNotifySomeOneSitDown::set_allocated_controller(::ProtoNet::SdkController* controller) {
  delete controller_;
  controller_ = controller;
  if (controller) {
    set_has_controller();
  } else {
    clear_has_controller();
  }
}

// -------------------------------------------------------------------

// ReqStandUp

// -------------------------------------------------------------------

// ResStandUp

// required .ProtoNet.ResponseResult result = 1;
inline bool ResStandUp::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResStandUp::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResStandUp::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResStandUp::clear_result() {
  if (result_ != NULL) result_->::ProtoNet::ResponseResult::Clear();
  clear_has_result();
}
inline const ::ProtoNet::ResponseResult& ResStandUp::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::ProtoNet::ResponseResult* ResStandUp::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::ProtoNet::ResponseResult;
  return result_;
}
inline ::ProtoNet::ResponseResult* ResStandUp::release_result() {
  clear_has_result();
  ::ProtoNet::ResponseResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline void ResStandUp::set_allocated_result(::ProtoNet::ResponseResult* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// -------------------------------------------------------------------

// ResNotifySomeOneStandUp

// required int32 pos = 1;
inline bool ResNotifySomeOneStandUp::has_pos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResNotifySomeOneStandUp::set_has_pos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResNotifySomeOneStandUp::clear_has_pos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResNotifySomeOneStandUp::clear_pos() {
  pos_ = 0;
  clear_has_pos();
}
inline ::google::protobuf::int32 ResNotifySomeOneStandUp::pos() const {
  return pos_;
}
inline void ResNotifySomeOneStandUp::set_pos(::google::protobuf::int32 value) {
  set_has_pos();
  pos_ = value;
}

// required .ProtoNet.SdkController controller = 2;
inline bool ResNotifySomeOneStandUp::has_controller() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResNotifySomeOneStandUp::set_has_controller() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResNotifySomeOneStandUp::clear_has_controller() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResNotifySomeOneStandUp::clear_controller() {
  if (controller_ != NULL) controller_->::ProtoNet::SdkController::Clear();
  clear_has_controller();
}
inline const ::ProtoNet::SdkController& ResNotifySomeOneStandUp::controller() const {
  return controller_ != NULL ? *controller_ : *default_instance_->controller_;
}
inline ::ProtoNet::SdkController* ResNotifySomeOneStandUp::mutable_controller() {
  set_has_controller();
  if (controller_ == NULL) controller_ = new ::ProtoNet::SdkController;
  return controller_;
}
inline ::ProtoNet::SdkController* ResNotifySomeOneStandUp::release_controller() {
  clear_has_controller();
  ::ProtoNet::SdkController* temp = controller_;
  controller_ = NULL;
  return temp;
}
inline void ResNotifySomeOneStandUp::set_allocated_controller(::ProtoNet::SdkController* controller) {
  delete controller_;
  controller_ = controller;
  if (controller) {
    set_has_controller();
  } else {
    clear_has_controller();
  }
}

// -------------------------------------------------------------------

// ResNotifySomeOneEnterCharge

// required string uniqueIds = 1;
inline bool ResNotifySomeOneEnterCharge::has_uniqueids() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResNotifySomeOneEnterCharge::set_has_uniqueids() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResNotifySomeOneEnterCharge::clear_has_uniqueids() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResNotifySomeOneEnterCharge::clear_uniqueids() {
  if (uniqueids_ != &::google::protobuf::internal::kEmptyString) {
    uniqueids_->clear();
  }
  clear_has_uniqueids();
}
inline const ::std::string& ResNotifySomeOneEnterCharge::uniqueids() const {
  return *uniqueids_;
}
inline void ResNotifySomeOneEnterCharge::set_uniqueids(const ::std::string& value) {
  set_has_uniqueids();
  if (uniqueids_ == &::google::protobuf::internal::kEmptyString) {
    uniqueids_ = new ::std::string;
  }
  uniqueids_->assign(value);
}
inline void ResNotifySomeOneEnterCharge::set_uniqueids(const char* value) {
  set_has_uniqueids();
  if (uniqueids_ == &::google::protobuf::internal::kEmptyString) {
    uniqueids_ = new ::std::string;
  }
  uniqueids_->assign(value);
}
inline void ResNotifySomeOneEnterCharge::set_uniqueids(const char* value, size_t size) {
  set_has_uniqueids();
  if (uniqueids_ == &::google::protobuf::internal::kEmptyString) {
    uniqueids_ = new ::std::string;
  }
  uniqueids_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResNotifySomeOneEnterCharge::mutable_uniqueids() {
  set_has_uniqueids();
  if (uniqueids_ == &::google::protobuf::internal::kEmptyString) {
    uniqueids_ = new ::std::string;
  }
  return uniqueids_;
}
inline ::std::string* ResNotifySomeOneEnterCharge::release_uniqueids() {
  clear_has_uniqueids();
  if (uniqueids_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uniqueids_;
    uniqueids_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResNotifySomeOneEnterCharge::set_allocated_uniqueids(::std::string* uniqueids) {
  if (uniqueids_ != &::google::protobuf::internal::kEmptyString) {
    delete uniqueids_;
  }
  if (uniqueids) {
    set_has_uniqueids();
    uniqueids_ = uniqueids;
  } else {
    clear_has_uniqueids();
    uniqueids_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 rechargeTime = 2;
inline bool ResNotifySomeOneEnterCharge::has_rechargetime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResNotifySomeOneEnterCharge::set_has_rechargetime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResNotifySomeOneEnterCharge::clear_has_rechargetime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResNotifySomeOneEnterCharge::clear_rechargetime() {
  rechargetime_ = 0;
  clear_has_rechargetime();
}
inline ::google::protobuf::int32 ResNotifySomeOneEnterCharge::rechargetime() const {
  return rechargetime_;
}
inline void ResNotifySomeOneEnterCharge::set_rechargetime(::google::protobuf::int32 value) {
  set_has_rechargetime();
  rechargetime_ = value;
}

// -------------------------------------------------------------------

// ResNotifyAccountsChange

// required string uniqueId = 1;
inline bool ResNotifyAccountsChange::has_uniqueid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResNotifyAccountsChange::set_has_uniqueid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResNotifyAccountsChange::clear_has_uniqueid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResNotifyAccountsChange::clear_uniqueid() {
  if (uniqueid_ != &::google::protobuf::internal::kEmptyString) {
    uniqueid_->clear();
  }
  clear_has_uniqueid();
}
inline const ::std::string& ResNotifyAccountsChange::uniqueid() const {
  return *uniqueid_;
}
inline void ResNotifyAccountsChange::set_uniqueid(const ::std::string& value) {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  uniqueid_->assign(value);
}
inline void ResNotifyAccountsChange::set_uniqueid(const char* value) {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  uniqueid_->assign(value);
}
inline void ResNotifyAccountsChange::set_uniqueid(const char* value, size_t size) {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  uniqueid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResNotifyAccountsChange::mutable_uniqueid() {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  return uniqueid_;
}
inline ::std::string* ResNotifyAccountsChange::release_uniqueid() {
  clear_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uniqueid_;
    uniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResNotifyAccountsChange::set_allocated_uniqueid(::std::string* uniqueid) {
  if (uniqueid_ != &::google::protobuf::internal::kEmptyString) {
    delete uniqueid_;
  }
  if (uniqueid) {
    set_has_uniqueid();
    uniqueid_ = uniqueid;
  } else {
    clear_has_uniqueid();
    uniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .ProtoNet.PlayerAccount counts = 2;
inline int ResNotifyAccountsChange::counts_size() const {
  return counts_.size();
}
inline void ResNotifyAccountsChange::clear_counts() {
  counts_.Clear();
}
inline const ::ProtoNet::PlayerAccount& ResNotifyAccountsChange::counts(int index) const {
  return counts_.Get(index);
}
inline ::ProtoNet::PlayerAccount* ResNotifyAccountsChange::mutable_counts(int index) {
  return counts_.Mutable(index);
}
inline ::ProtoNet::PlayerAccount* ResNotifyAccountsChange::add_counts() {
  return counts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::PlayerAccount >&
ResNotifyAccountsChange::counts() const {
  return counts_;
}
inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::PlayerAccount >*
ResNotifyAccountsChange::mutable_counts() {
  return &counts_;
}

// optional string extendStr = 3;
inline bool ResNotifyAccountsChange::has_extendstr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResNotifyAccountsChange::set_has_extendstr() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResNotifyAccountsChange::clear_has_extendstr() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResNotifyAccountsChange::clear_extendstr() {
  if (extendstr_ != &::google::protobuf::internal::kEmptyString) {
    extendstr_->clear();
  }
  clear_has_extendstr();
}
inline const ::std::string& ResNotifyAccountsChange::extendstr() const {
  return *extendstr_;
}
inline void ResNotifyAccountsChange::set_extendstr(const ::std::string& value) {
  set_has_extendstr();
  if (extendstr_ == &::google::protobuf::internal::kEmptyString) {
    extendstr_ = new ::std::string;
  }
  extendstr_->assign(value);
}
inline void ResNotifyAccountsChange::set_extendstr(const char* value) {
  set_has_extendstr();
  if (extendstr_ == &::google::protobuf::internal::kEmptyString) {
    extendstr_ = new ::std::string;
  }
  extendstr_->assign(value);
}
inline void ResNotifyAccountsChange::set_extendstr(const char* value, size_t size) {
  set_has_extendstr();
  if (extendstr_ == &::google::protobuf::internal::kEmptyString) {
    extendstr_ = new ::std::string;
  }
  extendstr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResNotifyAccountsChange::mutable_extendstr() {
  set_has_extendstr();
  if (extendstr_ == &::google::protobuf::internal::kEmptyString) {
    extendstr_ = new ::std::string;
  }
  return extendstr_;
}
inline ::std::string* ResNotifyAccountsChange::release_extendstr() {
  clear_has_extendstr();
  if (extendstr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extendstr_;
    extendstr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResNotifyAccountsChange::set_allocated_extendstr(::std::string* extendstr) {
  if (extendstr_ != &::google::protobuf::internal::kEmptyString) {
    delete extendstr_;
  }
  if (extendstr) {
    set_has_extendstr();
    extendstr_ = extendstr;
  } else {
    clear_has_extendstr();
    extendstr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 charge = 4;
inline bool ResNotifyAccountsChange::has_charge() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ResNotifyAccountsChange::set_has_charge() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ResNotifyAccountsChange::clear_has_charge() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ResNotifyAccountsChange::clear_charge() {
  charge_ = 0;
  clear_has_charge();
}
inline ::google::protobuf::int32 ResNotifyAccountsChange::charge() const {
  return charge_;
}
inline void ResNotifyAccountsChange::set_charge(::google::protobuf::int32 value) {
  set_has_charge();
  charge_ = value;
}

// -------------------------------------------------------------------

// ResNotifyChargeOver

// required string uniqueId = 1;
inline bool ResNotifyChargeOver::has_uniqueid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResNotifyChargeOver::set_has_uniqueid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResNotifyChargeOver::clear_has_uniqueid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResNotifyChargeOver::clear_uniqueid() {
  if (uniqueid_ != &::google::protobuf::internal::kEmptyString) {
    uniqueid_->clear();
  }
  clear_has_uniqueid();
}
inline const ::std::string& ResNotifyChargeOver::uniqueid() const {
  return *uniqueid_;
}
inline void ResNotifyChargeOver::set_uniqueid(const ::std::string& value) {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  uniqueid_->assign(value);
}
inline void ResNotifyChargeOver::set_uniqueid(const char* value) {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  uniqueid_->assign(value);
}
inline void ResNotifyChargeOver::set_uniqueid(const char* value, size_t size) {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  uniqueid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResNotifyChargeOver::mutable_uniqueid() {
  set_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    uniqueid_ = new ::std::string;
  }
  return uniqueid_;
}
inline ::std::string* ResNotifyChargeOver::release_uniqueid() {
  clear_has_uniqueid();
  if (uniqueid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uniqueid_;
    uniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResNotifyChargeOver::set_allocated_uniqueid(::std::string* uniqueid) {
  if (uniqueid_ != &::google::protobuf::internal::kEmptyString) {
    delete uniqueid_;
  }
  if (uniqueid) {
    set_has_uniqueid();
    uniqueid_ = uniqueid;
  } else {
    clear_has_uniqueid();
    uniqueid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ReqWatherList

// required int32 length = 1;
inline bool ReqWatherList::has_length() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqWatherList::set_has_length() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqWatherList::clear_has_length() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqWatherList::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline ::google::protobuf::int32 ReqWatherList::length() const {
  return length_;
}
inline void ReqWatherList::set_length(::google::protobuf::int32 value) {
  set_has_length();
  length_ = value;
}

// required int32 paixu = 2;
inline bool ReqWatherList::has_paixu() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqWatherList::set_has_paixu() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqWatherList::clear_has_paixu() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqWatherList::clear_paixu() {
  paixu_ = 0;
  clear_has_paixu();
}
inline ::google::protobuf::int32 ReqWatherList::paixu() const {
  return paixu_;
}
inline void ReqWatherList::set_paixu(::google::protobuf::int32 value) {
  set_has_paixu();
  paixu_ = value;
}

// -------------------------------------------------------------------

// ResWatherList

// required .ProtoNet.ResponseResult result = 1;
inline bool ResWatherList::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResWatherList::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResWatherList::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResWatherList::clear_result() {
  if (result_ != NULL) result_->::ProtoNet::ResponseResult::Clear();
  clear_has_result();
}
inline const ::ProtoNet::ResponseResult& ResWatherList::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::ProtoNet::ResponseResult* ResWatherList::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::ProtoNet::ResponseResult;
  return result_;
}
inline ::ProtoNet::ResponseResult* ResWatherList::release_result() {
  clear_has_result();
  ::ProtoNet::ResponseResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline void ResWatherList::set_allocated_result(::ProtoNet::ResponseResult* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// repeated .ProtoNet.SdkController sdkControllers = 2;
inline int ResWatherList::sdkcontrollers_size() const {
  return sdkcontrollers_.size();
}
inline void ResWatherList::clear_sdkcontrollers() {
  sdkcontrollers_.Clear();
}
inline const ::ProtoNet::SdkController& ResWatherList::sdkcontrollers(int index) const {
  return sdkcontrollers_.Get(index);
}
inline ::ProtoNet::SdkController* ResWatherList::mutable_sdkcontrollers(int index) {
  return sdkcontrollers_.Mutable(index);
}
inline ::ProtoNet::SdkController* ResWatherList::add_sdkcontrollers() {
  return sdkcontrollers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ProtoNet::SdkController >&
ResWatherList::sdkcontrollers() const {
  return sdkcontrollers_;
}
inline ::google::protobuf::RepeatedPtrField< ::ProtoNet::SdkController >*
ResWatherList::mutable_sdkcontrollers() {
  return &sdkcontrollers_;
}

// -------------------------------------------------------------------

// ReqOnceMore

// -------------------------------------------------------------------

// ResOnceMore

// required .ProtoNet.ResponseResult result = 1;
inline bool ResOnceMore::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResOnceMore::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResOnceMore::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResOnceMore::clear_result() {
  if (result_ != NULL) result_->::ProtoNet::ResponseResult::Clear();
  clear_has_result();
}
inline const ::ProtoNet::ResponseResult& ResOnceMore::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::ProtoNet::ResponseResult* ResOnceMore::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::ProtoNet::ResponseResult;
  return result_;
}
inline ::ProtoNet::ResponseResult* ResOnceMore::release_result() {
  clear_has_result();
  ::ProtoNet::ResponseResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline void ResOnceMore::set_allocated_result(::ProtoNet::ResponseResult* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// required int32 type = 2;
inline bool ResOnceMore::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResOnceMore::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResOnceMore::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResOnceMore::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ResOnceMore::type() const {
  return type_;
}
inline void ResOnceMore::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required string roomId = 3;
inline bool ResOnceMore::has_roomid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResOnceMore::set_has_roomid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResOnceMore::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResOnceMore::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& ResOnceMore::roomid() const {
  return *roomid_;
}
inline void ResOnceMore::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ResOnceMore::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ResOnceMore::set_roomid(const char* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResOnceMore::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  return roomid_;
}
inline ::std::string* ResOnceMore::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResOnceMore::set_allocated_roomid(::std::string* roomid) {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomid_;
  }
  if (roomid) {
    set_has_roomid();
    roomid_ = roomid;
  } else {
    clear_has_roomid();
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ResNotifyOnceMore

// required .ProtoNet.ResponseResult result = 1;
inline bool ResNotifyOnceMore::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResNotifyOnceMore::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResNotifyOnceMore::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResNotifyOnceMore::clear_result() {
  if (result_ != NULL) result_->::ProtoNet::ResponseResult::Clear();
  clear_has_result();
}
inline const ::ProtoNet::ResponseResult& ResNotifyOnceMore::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::ProtoNet::ResponseResult* ResNotifyOnceMore::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::ProtoNet::ResponseResult;
  return result_;
}
inline ::ProtoNet::ResponseResult* ResNotifyOnceMore::release_result() {
  clear_has_result();
  ::ProtoNet::ResponseResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline void ResNotifyOnceMore::set_allocated_result(::ProtoNet::ResponseResult* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// required int32 type = 2;
inline bool ResNotifyOnceMore::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResNotifyOnceMore::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResNotifyOnceMore::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResNotifyOnceMore::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ResNotifyOnceMore::type() const {
  return type_;
}
inline void ResNotifyOnceMore::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required string roomId = 3;
inline bool ResNotifyOnceMore::has_roomid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResNotifyOnceMore::set_has_roomid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResNotifyOnceMore::clear_has_roomid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResNotifyOnceMore::clear_roomid() {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    roomid_->clear();
  }
  clear_has_roomid();
}
inline const ::std::string& ResNotifyOnceMore::roomid() const {
  return *roomid_;
}
inline void ResNotifyOnceMore::set_roomid(const ::std::string& value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ResNotifyOnceMore::set_roomid(const char* value) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(value);
}
inline void ResNotifyOnceMore::set_roomid(const char* value, size_t size) {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  roomid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResNotifyOnceMore::mutable_roomid() {
  set_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    roomid_ = new ::std::string;
  }
  return roomid_;
}
inline ::std::string* ResNotifyOnceMore::release_roomid() {
  clear_has_roomid();
  if (roomid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = roomid_;
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResNotifyOnceMore::set_allocated_roomid(::std::string* roomid) {
  if (roomid_ != &::google::protobuf::internal::kEmptyString) {
    delete roomid_;
  }
  if (roomid) {
    set_has_roomid();
    roomid_ = roomid;
  } else {
    clear_has_roomid();
    roomid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// reqLogicServerTime

// -------------------------------------------------------------------

// resLogicServerTime

// required .ProtoNet.ResponseResult result = 1;
inline bool resLogicServerTime::has_result() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void resLogicServerTime::set_has_result() {
  _has_bits_[0] |= 0x00000001u;
}
inline void resLogicServerTime::clear_has_result() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void resLogicServerTime::clear_result() {
  if (result_ != NULL) result_->::ProtoNet::ResponseResult::Clear();
  clear_has_result();
}
inline const ::ProtoNet::ResponseResult& resLogicServerTime::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::ProtoNet::ResponseResult* resLogicServerTime::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::ProtoNet::ResponseResult;
  return result_;
}
inline ::ProtoNet::ResponseResult* resLogicServerTime::release_result() {
  clear_has_result();
  ::ProtoNet::ResponseResult* temp = result_;
  result_ = NULL;
  return temp;
}
inline void resLogicServerTime::set_allocated_result(::ProtoNet::ResponseResult* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// optional int64 serverTime = 2;
inline bool resLogicServerTime::has_servertime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void resLogicServerTime::set_has_servertime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void resLogicServerTime::clear_has_servertime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void resLogicServerTime::clear_servertime() {
  servertime_ = GOOGLE_LONGLONG(0);
  clear_has_servertime();
}
inline ::google::protobuf::int64 resLogicServerTime::servertime() const {
  return servertime_;
}
inline void resLogicServerTime::set_servertime(::google::protobuf::int64 value) {
  set_has_servertime();
  servertime_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace ProtoNet

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_MsgLogic_2eproto__INCLUDED
